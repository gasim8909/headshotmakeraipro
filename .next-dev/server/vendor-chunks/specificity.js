"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/specificity";
exports.ids = ["vendor-chunks/specificity"];
exports.modules = {

/***/ "(ssr)/./node_modules/specificity/dist/specificity.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/specificity/dist/specificity.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculate: () => (/* binding */ calculate),\n/* harmony export */   compare: () => (/* binding */ compare)\n/* harmony export */ });\n// Calculate the specificity for a selector by dividing it into simple selectors and counting them\nvar calculate = function(input) {\n\tvar selectors,\n\t\tselector,\n\t\ti,\n\t\tlen,\n\t\tresults = [];\n\n\t// Separate input by commas\n\tselectors = input.split(',');\n\n\tfor (i = 0, len = selectors.length; i < len; i += 1) {\n\t\tselector = selectors[i];\n\t\tif (selector.length > 0) {\n\t\t\tresults.push(calculateSingle(selector));\n\t\t}\n\t}\n\n\treturn results;\n};\n\n/**\n * Calculates the specificity of CSS selectors\n * http://www.w3.org/TR/css3-selectors/#specificity\n *\n * Returns an object with the following properties:\n *  - selector: the input\n *  - specificity: e.g. 0,1,0,0\n *  - parts: array with details about each part of the selector that counts towards the specificity\n *  - specificityArray: e.g. [0, 1, 0, 0]\n */\nvar calculateSingle = function(input) {\n\tvar selector = input,\n\t\tfindMatch,\n\t\ttypeCount = {\n\t\t\t'a': 0,\n\t\t\t'b': 0,\n\t\t\t'c': 0\n\t\t},\n\t\tparts = [],\n\t\t// The following regular expressions assume that selectors matching the preceding regular expressions have been removed\n\t\tattributeRegex = /(\\[[^\\]]+\\])/g,\n\t\tidRegex = /(#[^\\#\\s\\+>~\\.\\[:\\)]+)/g,\n\t\tclassRegex = /(\\.[^\\s\\+>~\\.\\[:\\)]+)/g,\n\t\tpseudoElementRegex = /(::[^\\s\\+>~\\.\\[:]+|:first-line|:first-letter|:before|:after)/gi,\n\t\t// A regex for pseudo classes with brackets - :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-type(), :lang()\n\t\t// The negation psuedo class (:not) is filtered out because specificity is calculated on its argument\n\t\t// :global and :local are filtered out - they look like psuedo classes but are an identifier for CSS Modules\n\t\tpseudoClassWithBracketsRegex = /(:(?!not|global|local)[\\w-]+\\([^\\)]*\\))/gi,\n\t\t// A regex for other pseudo classes, which don't have brackets\n\t\tpseudoClassRegex = /(:(?!not|global|local)[^\\s\\+>~\\.\\[:]+)/g,\n\t\telementRegex = /([^\\s\\+>~\\.\\[:]+)/g;\n\n\t// Find matches for a regular expression in a string and push their details to parts\n\t// Type is \"a\" for IDs, \"b\" for classes, attributes and pseudo-classes and \"c\" for elements and pseudo-elements\n\tfindMatch = function(regex, type) {\n\t\tvar matches, i, len, match, index, length;\n\t\tif (regex.test(selector)) {\n\t\t\tmatches = selector.match(regex);\n\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\ttypeCount[type] += 1;\n\t\t\t\tmatch = matches[i];\n\t\t\t\tindex = selector.indexOf(match);\n\t\t\t\tlength = match.length;\n\t\t\t\tparts.push({\n\t\t\t\t\tselector: input.substr(index, length),\n\t\t\t\t\ttype: type,\n\t\t\t\t\tindex: index,\n\t\t\t\t\tlength: length\n\t\t\t\t});\n\t\t\t\t// Replace this simple selector with whitespace so it won't be counted in further simple selectors\n\t\t\t\tselector = selector.replace(match, Array(length + 1).join(' '));\n\t\t\t}\n\t\t}\n\t};\n\n\t// Replace escaped characters with plain text, using the \"A\" character\n\t// https://www.w3.org/TR/CSS21/syndata.html#characters\n\t(function() {\n\t\tvar replaceWithPlainText = function(regex) {\n\t\t\t\tvar matches, i, len, match;\n\t\t\t\tif (regex.test(selector)) {\n\t\t\t\t\tmatches = selector.match(regex);\n\t\t\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\t\t\tmatch = matches[i];\n\t\t\t\t\t\tselector = selector.replace(match, Array(match.length + 1).join('A'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Matches a backslash followed by six hexadecimal digits followed by an optional single whitespace character\n\t\t\tescapeHexadecimalRegex = /\\\\[0-9A-Fa-f]{6}\\s?/g,\n\t\t\t// Matches a backslash followed by fewer than six hexadecimal digits followed by a mandatory single whitespace character\n\t\t\tescapeHexadecimalRegex2 = /\\\\[0-9A-Fa-f]{1,5}\\s/g,\n\t\t\t// Matches a backslash followed by any character\n\t\t\tescapeSpecialCharacter = /\\\\./g;\n\n\t\treplaceWithPlainText(escapeHexadecimalRegex);\n\t\treplaceWithPlainText(escapeHexadecimalRegex2);\n\t\treplaceWithPlainText(escapeSpecialCharacter);\n\t}());\n\n\t// Remove anything after a left brace in case a user has pasted in a rule, not just a selector\n\t(function() {\n\t\tvar regex = /{[^]*/gm,\n\t\t\tmatches, i, len, match;\n\t\tif (regex.test(selector)) {\n\t\t\tmatches = selector.match(regex);\n\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\tmatch = matches[i];\n\t\t\t\tselector = selector.replace(match, Array(match.length + 1).join(' '));\n\t\t\t}\n\t\t}\n\t}());\n\n\t// Add attribute selectors to parts collection (type b)\n\tfindMatch(attributeRegex, 'b');\n\n\t// Add ID selectors to parts collection (type a)\n\tfindMatch(idRegex, 'a');\n\n\t// Add class selectors to parts collection (type b)\n\tfindMatch(classRegex, 'b');\n\n\t// Add pseudo-element selectors to parts collection (type c)\n\tfindMatch(pseudoElementRegex, 'c');\n\n\t// Add pseudo-class selectors to parts collection (type b)\n\tfindMatch(pseudoClassWithBracketsRegex, 'b');\n\tfindMatch(pseudoClassRegex, 'b');\n\n\t// Remove universal selector and separator characters\n\tselector = selector.replace(/[\\*\\s\\+>~]/g, ' ');\n\n\t// Remove any stray dots or hashes which aren't attached to words\n\t// These may be present if the user is live-editing this selector\n\tselector = selector.replace(/[#\\.]/g, ' ');\n\n\t// Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument\n \t// Remove non-standard :local and :global CSS Module identifiers because they do not effect the specificity\n\tselector = selector.replace(/:not/g, '    ');\n\tselector = selector.replace(/:local/g, '      ');\n\tselector = selector.replace(/:global/g, '       ');\n\tselector = selector.replace(/[\\(\\)]/g, ' ');\n\n\t// The only things left should be element selectors (type c)\n\tfindMatch(elementRegex, 'c');\n\n\t// Order the parts in the order they appear in the original selector\n\t// This is neater for external apps to deal with\n\tparts.sort(function(a, b) {\n\t\treturn a.index - b.index;\n\t});\n\n\treturn {\n\t\tselector: input,\n\t\tspecificity: '0,' + typeCount.a.toString() + ',' + typeCount.b.toString() + ',' + typeCount.c.toString(),\n\t\tspecificityArray: [0, typeCount.a, typeCount.b, typeCount.c],\n\t\tparts: parts\n\t};\n};\n\n/**\n * Compares two CSS selectors for specificity\n * Alternatively you can replace one of the CSS selectors with a specificity array\n *\n *  - it returns -1 if a has a lower specificity than b\n *  - it returns 1 if a has a higher specificity than b\n *  - it returns 0 if a has the same specificity than b\n */\nvar compare = function(a, b) {\n\tvar aSpecificity,\n\t\tbSpecificity,\n\t\ti;\n\n\tif (typeof a ==='string') {\n\t\tif (a.indexOf(',') !== -1) {\n\t\t\tthrow 'Invalid CSS selector';\n\t\t} else {\n\t\t\taSpecificity = calculateSingle(a)['specificityArray'];\n\t\t}\n\t} else if (Array.isArray(a)) {\n\t\tif (a.filter(function(e) { return (typeof e === 'number'); }).length !== 4) {\n\t\t\tthrow 'Invalid specificity array';\n\t\t} else {\n\t\t\taSpecificity = a;\n\t\t}\n\t} else {\n\t\tthrow 'Invalid CSS selector or specificity array';\n\t}\n\n\tif (typeof b ==='string') {\n\t\tif (b.indexOf(',') !== -1) {\n\t\t\tthrow 'Invalid CSS selector';\n\t\t} else {\n\t\t\tbSpecificity = calculateSingle(b)['specificityArray'];\n\t\t}\n\t} else if (Array.isArray(b)) {\n\t\tif (b.filter(function(e) { return (typeof e === 'number'); }).length !== 4) {\n\t\t\tthrow 'Invalid specificity array';\n\t\t} else {\n\t\t\tbSpecificity = b;\n\t\t}\n\t} else {\n\t\tthrow 'Invalid CSS selector or specificity array';\n\t}\n\n\tfor (i = 0; i < 4; i += 1) {\n\t\tif (aSpecificity[i] < bSpecificity[i]) {\n\t\t\treturn -1;\n\t\t} else if (aSpecificity[i] > bSpecificity[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3BlY2lmaWNpdHkvZGlzdC9zcGVjaWZpY2l0eS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUU4QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHNwZWNpZmljaXR5XFxkaXN0XFxzcGVjaWZpY2l0eS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsY3VsYXRlIHRoZSBzcGVjaWZpY2l0eSBmb3IgYSBzZWxlY3RvciBieSBkaXZpZGluZyBpdCBpbnRvIHNpbXBsZSBzZWxlY3RvcnMgYW5kIGNvdW50aW5nIHRoZW1cbnZhciBjYWxjdWxhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHR2YXIgc2VsZWN0b3JzLFxuXHRcdHNlbGVjdG9yLFxuXHRcdGksXG5cdFx0bGVuLFxuXHRcdHJlc3VsdHMgPSBbXTtcblxuXHQvLyBTZXBhcmF0ZSBpbnB1dCBieSBjb21tYXNcblx0c2VsZWN0b3JzID0gaW5wdXQuc3BsaXQoJywnKTtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSBzZWxlY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRzZWxlY3RvciA9IHNlbGVjdG9yc1tpXTtcblx0XHRpZiAoc2VsZWN0b3IubGVuZ3RoID4gMCkge1xuXHRcdFx0cmVzdWx0cy5wdXNoKGNhbGN1bGF0ZVNpbmdsZShzZWxlY3RvcikpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcGVjaWZpY2l0eSBvZiBDU1Mgc2VsZWN0b3JzXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jc3BlY2lmaWNpdHlcbiAqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAtIHNlbGVjdG9yOiB0aGUgaW5wdXRcbiAqICAtIHNwZWNpZmljaXR5OiBlLmcuIDAsMSwwLDBcbiAqICAtIHBhcnRzOiBhcnJheSB3aXRoIGRldGFpbHMgYWJvdXQgZWFjaCBwYXJ0IG9mIHRoZSBzZWxlY3RvciB0aGF0IGNvdW50cyB0b3dhcmRzIHRoZSBzcGVjaWZpY2l0eVxuICogIC0gc3BlY2lmaWNpdHlBcnJheTogZS5nLiBbMCwgMSwgMCwgMF1cbiAqL1xudmFyIGNhbGN1bGF0ZVNpbmdsZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHZhciBzZWxlY3RvciA9IGlucHV0LFxuXHRcdGZpbmRNYXRjaCxcblx0XHR0eXBlQ291bnQgPSB7XG5cdFx0XHQnYSc6IDAsXG5cdFx0XHQnYic6IDAsXG5cdFx0XHQnYyc6IDBcblx0XHR9LFxuXHRcdHBhcnRzID0gW10sXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyByZWd1bGFyIGV4cHJlc3Npb25zIGFzc3VtZSB0aGF0IHNlbGVjdG9ycyBtYXRjaGluZyB0aGUgcHJlY2VkaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuIHJlbW92ZWRcblx0XHRhdHRyaWJ1dGVSZWdleCA9IC8oXFxbW15cXF1dK1xcXSkvZyxcblx0XHRpZFJlZ2V4ID0gLygjW15cXCNcXHNcXCs+flxcLlxcWzpcXCldKykvZyxcblx0XHRjbGFzc1JlZ2V4ID0gLyhcXC5bXlxcc1xcKz5+XFwuXFxbOlxcKV0rKS9nLFxuXHRcdHBzZXVkb0VsZW1lbnRSZWdleCA9IC8oOjpbXlxcc1xcKz5+XFwuXFxbOl0rfDpmaXJzdC1saW5lfDpmaXJzdC1sZXR0ZXJ8OmJlZm9yZXw6YWZ0ZXIpL2dpLFxuXHRcdC8vIEEgcmVnZXggZm9yIHBzZXVkbyBjbGFzc2VzIHdpdGggYnJhY2tldHMgLSA6bnRoLWNoaWxkKCksIDpudGgtbGFzdC1jaGlsZCgpLCA6bnRoLW9mLXR5cGUoKSwgOm50aC1sYXN0LXR5cGUoKSwgOmxhbmcoKVxuXHRcdC8vIFRoZSBuZWdhdGlvbiBwc3VlZG8gY2xhc3MgKDpub3QpIGlzIGZpbHRlcmVkIG91dCBiZWNhdXNlIHNwZWNpZmljaXR5IGlzIGNhbGN1bGF0ZWQgb24gaXRzIGFyZ3VtZW50XG5cdFx0Ly8gOmdsb2JhbCBhbmQgOmxvY2FsIGFyZSBmaWx0ZXJlZCBvdXQgLSB0aGV5IGxvb2sgbGlrZSBwc3VlZG8gY2xhc3NlcyBidXQgYXJlIGFuIGlkZW50aWZpZXIgZm9yIENTUyBNb2R1bGVzXG5cdFx0cHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCA9IC8oOig/IW5vdHxnbG9iYWx8bG9jYWwpW1xcdy1dK1xcKFteXFwpXSpcXCkpL2dpLFxuXHRcdC8vIEEgcmVnZXggZm9yIG90aGVyIHBzZXVkbyBjbGFzc2VzLCB3aGljaCBkb24ndCBoYXZlIGJyYWNrZXRzXG5cdFx0cHNldWRvQ2xhc3NSZWdleCA9IC8oOig/IW5vdHxnbG9iYWx8bG9jYWwpW15cXHNcXCs+flxcLlxcWzpdKykvZyxcblx0XHRlbGVtZW50UmVnZXggPSAvKFteXFxzXFwrPn5cXC5cXFs6XSspL2c7XG5cblx0Ly8gRmluZCBtYXRjaGVzIGZvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbiBhIHN0cmluZyBhbmQgcHVzaCB0aGVpciBkZXRhaWxzIHRvIHBhcnRzXG5cdC8vIFR5cGUgaXMgXCJhXCIgZm9yIElEcywgXCJiXCIgZm9yIGNsYXNzZXMsIGF0dHJpYnV0ZXMgYW5kIHBzZXVkby1jbGFzc2VzIGFuZCBcImNcIiBmb3IgZWxlbWVudHMgYW5kIHBzZXVkby1lbGVtZW50c1xuXHRmaW5kTWF0Y2ggPSBmdW5jdGlvbihyZWdleCwgdHlwZSkge1xuXHRcdHZhciBtYXRjaGVzLCBpLCBsZW4sIG1hdGNoLCBpbmRleCwgbGVuZ3RoO1xuXHRcdGlmIChyZWdleC50ZXN0KHNlbGVjdG9yKSkge1xuXHRcdFx0bWF0Y2hlcyA9IHNlbGVjdG9yLm1hdGNoKHJlZ2V4KTtcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IG1hdGNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRcdFx0dHlwZUNvdW50W3R5cGVdICs9IDE7XG5cdFx0XHRcdG1hdGNoID0gbWF0Y2hlc1tpXTtcblx0XHRcdFx0aW5kZXggPSBzZWxlY3Rvci5pbmRleE9mKG1hdGNoKTtcblx0XHRcdFx0bGVuZ3RoID0gbWF0Y2gubGVuZ3RoO1xuXHRcdFx0XHRwYXJ0cy5wdXNoKHtcblx0XHRcdFx0XHRzZWxlY3RvcjogaW5wdXQuc3Vic3RyKGluZGV4LCBsZW5ndGgpLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0XHRcdGxlbmd0aDogbGVuZ3RoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBSZXBsYWNlIHRoaXMgc2ltcGxlIHNlbGVjdG9yIHdpdGggd2hpdGVzcGFjZSBzbyBpdCB3b24ndCBiZSBjb3VudGVkIGluIGZ1cnRoZXIgc2ltcGxlIHNlbGVjdG9yc1xuXHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2gsIEFycmF5KGxlbmd0aCArIDEpLmpvaW4oJyAnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFJlcGxhY2UgZXNjYXBlZCBjaGFyYWN0ZXJzIHdpdGggcGxhaW4gdGV4dCwgdXNpbmcgdGhlIFwiQVwiIGNoYXJhY3RlclxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2NoYXJhY3RlcnNcblx0KGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXBsYWNlV2l0aFBsYWluVGV4dCA9IGZ1bmN0aW9uKHJlZ2V4KSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzLCBpLCBsZW4sIG1hdGNoO1xuXHRcdFx0XHRpZiAocmVnZXgudGVzdChzZWxlY3RvcikpIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gc2VsZWN0b3IubWF0Y2gocmVnZXgpO1xuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IG1hdGNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gbWF0Y2hlc1tpXTtcblx0XHRcdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaCwgQXJyYXkobWF0Y2gubGVuZ3RoICsgMSkuam9pbignQScpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBNYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IHNpeCBoZXhhZGVjaW1hbCBkaWdpdHMgZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyXG5cdFx0XHRlc2NhcGVIZXhhZGVjaW1hbFJlZ2V4ID0gL1xcXFxbMC05QS1GYS1mXXs2fVxccz8vZyxcblx0XHRcdC8vIE1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgZmV3ZXIgdGhhbiBzaXggaGV4YWRlY2ltYWwgZGlnaXRzIGZvbGxvd2VkIGJ5IGEgbWFuZGF0b3J5IHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3RlclxuXHRcdFx0ZXNjYXBlSGV4YWRlY2ltYWxSZWdleDIgPSAvXFxcXFswLTlBLUZhLWZdezEsNX1cXHMvZyxcblx0XHRcdC8vIE1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgYW55IGNoYXJhY3RlclxuXHRcdFx0ZXNjYXBlU3BlY2lhbENoYXJhY3RlciA9IC9cXFxcLi9nO1xuXG5cdFx0cmVwbGFjZVdpdGhQbGFpblRleHQoZXNjYXBlSGV4YWRlY2ltYWxSZWdleCk7XG5cdFx0cmVwbGFjZVdpdGhQbGFpblRleHQoZXNjYXBlSGV4YWRlY2ltYWxSZWdleDIpO1xuXHRcdHJlcGxhY2VXaXRoUGxhaW5UZXh0KGVzY2FwZVNwZWNpYWxDaGFyYWN0ZXIpO1xuXHR9KCkpO1xuXG5cdC8vIFJlbW92ZSBhbnl0aGluZyBhZnRlciBhIGxlZnQgYnJhY2UgaW4gY2FzZSBhIHVzZXIgaGFzIHBhc3RlZCBpbiBhIHJ1bGUsIG5vdCBqdXN0IGEgc2VsZWN0b3Jcblx0KGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWdleCA9IC97W15dKi9nbSxcblx0XHRcdG1hdGNoZXMsIGksIGxlbiwgbWF0Y2g7XG5cdFx0aWYgKHJlZ2V4LnRlc3Qoc2VsZWN0b3IpKSB7XG5cdFx0XHRtYXRjaGVzID0gc2VsZWN0b3IubWF0Y2gocmVnZXgpO1xuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbWF0Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuXHRcdFx0XHRtYXRjaCA9IG1hdGNoZXNbaV07XG5cdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaCwgQXJyYXkobWF0Y2gubGVuZ3RoICsgMSkuam9pbignICcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSk7XG5cblx0Ly8gQWRkIGF0dHJpYnV0ZSBzZWxlY3RvcnMgdG8gcGFydHMgY29sbGVjdGlvbiAodHlwZSBiKVxuXHRmaW5kTWF0Y2goYXR0cmlidXRlUmVnZXgsICdiJyk7XG5cblx0Ly8gQWRkIElEIHNlbGVjdG9ycyB0byBwYXJ0cyBjb2xsZWN0aW9uICh0eXBlIGEpXG5cdGZpbmRNYXRjaChpZFJlZ2V4LCAnYScpO1xuXG5cdC8vIEFkZCBjbGFzcyBzZWxlY3RvcnMgdG8gcGFydHMgY29sbGVjdGlvbiAodHlwZSBiKVxuXHRmaW5kTWF0Y2goY2xhc3NSZWdleCwgJ2InKTtcblxuXHQvLyBBZGQgcHNldWRvLWVsZW1lbnQgc2VsZWN0b3JzIHRvIHBhcnRzIGNvbGxlY3Rpb24gKHR5cGUgYylcblx0ZmluZE1hdGNoKHBzZXVkb0VsZW1lbnRSZWdleCwgJ2MnKTtcblxuXHQvLyBBZGQgcHNldWRvLWNsYXNzIHNlbGVjdG9ycyB0byBwYXJ0cyBjb2xsZWN0aW9uICh0eXBlIGIpXG5cdGZpbmRNYXRjaChwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4LCAnYicpO1xuXHRmaW5kTWF0Y2gocHNldWRvQ2xhc3NSZWdleCwgJ2InKTtcblxuXHQvLyBSZW1vdmUgdW5pdmVyc2FsIHNlbGVjdG9yIGFuZCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuXHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoL1tcXCpcXHNcXCs+fl0vZywgJyAnKTtcblxuXHQvLyBSZW1vdmUgYW55IHN0cmF5IGRvdHMgb3IgaGFzaGVzIHdoaWNoIGFyZW4ndCBhdHRhY2hlZCB0byB3b3Jkc1xuXHQvLyBUaGVzZSBtYXkgYmUgcHJlc2VudCBpZiB0aGUgdXNlciBpcyBsaXZlLWVkaXRpbmcgdGhpcyBzZWxlY3RvclxuXHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoL1sjXFwuXS9nLCAnICcpO1xuXG5cdC8vIFJlbW92ZSB0aGUgbmVnYXRpb24gcHN1ZWRvLWNsYXNzICg6bm90KSBidXQgbGVhdmUgaXRzIGFyZ3VtZW50IGJlY2F1c2Ugc3BlY2lmaWNpdHkgaXMgY2FsY3VsYXRlZCBvbiBpdHMgYXJndW1lbnRcbiBcdC8vIFJlbW92ZSBub24tc3RhbmRhcmQgOmxvY2FsIGFuZCA6Z2xvYmFsIENTUyBNb2R1bGUgaWRlbnRpZmllcnMgYmVjYXVzZSB0aGV5IGRvIG5vdCBlZmZlY3QgdGhlIHNwZWNpZmljaXR5XG5cdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvOm5vdC9nLCAnICAgICcpO1xuXHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLzpsb2NhbC9nLCAnICAgICAgJyk7XG5cdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvOmdsb2JhbC9nLCAnICAgICAgICcpO1xuXHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoL1tcXChcXCldL2csICcgJyk7XG5cblx0Ly8gVGhlIG9ubHkgdGhpbmdzIGxlZnQgc2hvdWxkIGJlIGVsZW1lbnQgc2VsZWN0b3JzICh0eXBlIGMpXG5cdGZpbmRNYXRjaChlbGVtZW50UmVnZXgsICdjJyk7XG5cblx0Ly8gT3JkZXIgdGhlIHBhcnRzIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhciBpbiB0aGUgb3JpZ2luYWwgc2VsZWN0b3Jcblx0Ly8gVGhpcyBpcyBuZWF0ZXIgZm9yIGV4dGVybmFsIGFwcHMgdG8gZGVhbCB3aXRoXG5cdHBhcnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRzZWxlY3RvcjogaW5wdXQsXG5cdFx0c3BlY2lmaWNpdHk6ICcwLCcgKyB0eXBlQ291bnQuYS50b1N0cmluZygpICsgJywnICsgdHlwZUNvdW50LmIudG9TdHJpbmcoKSArICcsJyArIHR5cGVDb3VudC5jLnRvU3RyaW5nKCksXG5cdFx0c3BlY2lmaWNpdHlBcnJheTogWzAsIHR5cGVDb3VudC5hLCB0eXBlQ291bnQuYiwgdHlwZUNvdW50LmNdLFxuXHRcdHBhcnRzOiBwYXJ0c1xuXHR9O1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gQ1NTIHNlbGVjdG9ycyBmb3Igc3BlY2lmaWNpdHlcbiAqIEFsdGVybmF0aXZlbHkgeW91IGNhbiByZXBsYWNlIG9uZSBvZiB0aGUgQ1NTIHNlbGVjdG9ycyB3aXRoIGEgc3BlY2lmaWNpdHkgYXJyYXlcbiAqXG4gKiAgLSBpdCByZXR1cm5zIC0xIGlmIGEgaGFzIGEgbG93ZXIgc3BlY2lmaWNpdHkgdGhhbiBiXG4gKiAgLSBpdCByZXR1cm5zIDEgaWYgYSBoYXMgYSBoaWdoZXIgc3BlY2lmaWNpdHkgdGhhbiBiXG4gKiAgLSBpdCByZXR1cm5zIDAgaWYgYSBoYXMgdGhlIHNhbWUgc3BlY2lmaWNpdHkgdGhhbiBiXG4gKi9cbnZhciBjb21wYXJlID0gZnVuY3Rpb24oYSwgYikge1xuXHR2YXIgYVNwZWNpZmljaXR5LFxuXHRcdGJTcGVjaWZpY2l0eSxcblx0XHRpO1xuXG5cdGlmICh0eXBlb2YgYSA9PT0nc3RyaW5nJykge1xuXHRcdGlmIChhLmluZGV4T2YoJywnKSAhPT0gLTEpIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIENTUyBzZWxlY3Rvcic7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFTcGVjaWZpY2l0eSA9IGNhbGN1bGF0ZVNpbmdsZShhKVsnc3BlY2lmaWNpdHlBcnJheSddO1xuXHRcdH1cblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG5cdFx0aWYgKGEuZmlsdGVyKGZ1bmN0aW9uKGUpIHsgcmV0dXJuICh0eXBlb2YgZSA9PT0gJ251bWJlcicpOyB9KS5sZW5ndGggIT09IDQpIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIHNwZWNpZmljaXR5IGFycmF5Jztcblx0XHR9IGVsc2Uge1xuXHRcdFx0YVNwZWNpZmljaXR5ID0gYTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgJ0ludmFsaWQgQ1NTIHNlbGVjdG9yIG9yIHNwZWNpZmljaXR5IGFycmF5Jztcblx0fVxuXG5cdGlmICh0eXBlb2YgYiA9PT0nc3RyaW5nJykge1xuXHRcdGlmIChiLmluZGV4T2YoJywnKSAhPT0gLTEpIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIENTUyBzZWxlY3Rvcic7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJTcGVjaWZpY2l0eSA9IGNhbGN1bGF0ZVNpbmdsZShiKVsnc3BlY2lmaWNpdHlBcnJheSddO1xuXHRcdH1cblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG5cdFx0aWYgKGIuZmlsdGVyKGZ1bmN0aW9uKGUpIHsgcmV0dXJuICh0eXBlb2YgZSA9PT0gJ251bWJlcicpOyB9KS5sZW5ndGggIT09IDQpIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIHNwZWNpZmljaXR5IGFycmF5Jztcblx0XHR9IGVsc2Uge1xuXHRcdFx0YlNwZWNpZmljaXR5ID0gYjtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgJ0ludmFsaWQgQ1NTIHNlbGVjdG9yIG9yIHNwZWNpZmljaXR5IGFycmF5Jztcblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcblx0XHRpZiAoYVNwZWNpZmljaXR5W2ldIDwgYlNwZWNpZmljaXR5W2ldKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fSBlbHNlIGlmIChhU3BlY2lmaWNpdHlbaV0gPiBiU3BlY2lmaWNpdHlbaV0pIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAwO1xufTtcblxuZXhwb3J0IHsgY2FsY3VsYXRlLCBjb21wYXJlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/specificity/dist/specificity.mjs\n");

/***/ })

};
;