"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tempo-devtools";
exports.ids = ["vendor-chunks/tempo-devtools"];
exports.modules = {

/***/ "(ssr)/./node_modules/tempo-devtools/dist/TempoDevtools.js":
/*!***********************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/TempoDevtools.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TempoDevtools = void 0;\nconst channelMessaging_1 = __webpack_require__(/*! ./channelMessaging */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/index.js\");\nexports.TempoDevtools = {\n    state: {\n        dependencies: {\n            LzString: null,\n        },\n        env: {},\n    },\n    // Initialization method\n    init: function (customEnv = {}) {\n        if (customEnv) {\n            this.state.env = Object.assign({}, customEnv);\n        }\n        (0, channelMessaging_1.initChannelMessaging)();\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9UZW1wb0RldnRvb2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQiwyQkFBMkIsbUJBQU8sQ0FBQyw4RkFBb0I7QUFDdkQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3lhaGlcXE9uZURyaXZlXFzYs9i32K0g2KfZhNmF2YPYqtioXFxHYXNzaW1cXGhlYWRzaG90bWFrZXJhaXByb1xcbm9kZV9tb2R1bGVzXFx0ZW1wby1kZXZ0b29sc1xcZGlzdFxcVGVtcG9EZXZ0b29scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGVtcG9EZXZ0b29scyA9IHZvaWQgMDtcbmNvbnN0IGNoYW5uZWxNZXNzYWdpbmdfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxNZXNzYWdpbmdcIik7XG5leHBvcnRzLlRlbXBvRGV2dG9vbHMgPSB7XG4gICAgc3RhdGU6IHtcbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7XG4gICAgICAgICAgICBMelN0cmluZzogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgICAgZW52OiB7fSxcbiAgICB9LFxuICAgIC8vIEluaXRpYWxpemF0aW9uIG1ldGhvZFxuICAgIGluaXQ6IGZ1bmN0aW9uIChjdXN0b21FbnYgPSB7fSkge1xuICAgICAgICBpZiAoY3VzdG9tRW52KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmVudiA9IE9iamVjdC5hc3NpZ24oe30sIGN1c3RvbUVudik7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGNoYW5uZWxNZXNzYWdpbmdfMS5pbml0Q2hhbm5lbE1lc3NhZ2luZykoKTtcbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/TempoDevtools.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/changeItemFunctions.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/changeItemFunctions.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateCodebaseIds = exports.applyChangeItemToDocument = exports.TEMPORARY_STYLING_CLASS_NAME = exports.ADD_CLASS_INSTANT_UPDATE_QUEUE = exports.ADD_JSX_PREFIX = exports.DUPLICATE_PLACEHOLDER_PREFIX = exports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID = void 0;\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\"));\nconst identifierUtils_1 = __webpack_require__(/*! ./identifierUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js\");\nconst changeLedgerTypes_1 = __webpack_require__(/*! ./changeLedgerTypes */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/changeLedgerTypes.js\");\nconst constantsAndTypes_1 = __webpack_require__(/*! ./constantsAndTypes */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/constantsAndTypes.js\");\nconst cssRuleUtils_1 = __webpack_require__(/*! ./cssRuleUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssRuleUtils.js\");\nconst sessionStorageUtils_1 = __webpack_require__(/*! ./sessionStorageUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js\");\nconst tempoElement_1 = __webpack_require__(/*! ./tempoElement */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\");\n// These constants match what tempo-api has\nexports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID = 'tempo-wrap-in-div-placeholder';\nexports.DUPLICATE_PLACEHOLDER_PREFIX = 'tempo-duplicate-placeholder-';\nexports.ADD_JSX_PREFIX = 'tempo-add-jsx-placeholder-';\n// Stored in memory storage, used to keep track of some possible add class instant\n// updates that need to be re-applied after a hot reload\n// (e.g. when the additional) instant updates happened during flushing\nexports.ADD_CLASS_INSTANT_UPDATE_QUEUE = 'ADD_CLASS_INSTANT_UPDATE_QUEUE';\nexports.TEMPORARY_STYLING_CLASS_NAME = 'arb89-temp-styling';\nconst getTopLevelCodebaseIdForComponent = (componentId) => {\n    let topLevelCodebaseId = null;\n    let minNumberParents = Infinity;\n    (0, jquery_1.default)(`.component-${componentId}`).each((index, element) => {\n        if ((0, jquery_1.default)(element).parents().length < minNumberParents) {\n            minNumberParents = (0, jquery_1.default)(element).parents().length;\n            topLevelCodebaseId = (0, identifierUtils_1.getCodebaseIdFromNode)(element);\n        }\n    });\n    return topLevelCodebaseId;\n};\nconst makeid = (length) => {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const charactersLength = characters.length;\n    let counter = 0;\n    while (counter < length) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n        counter += 1;\n    }\n    return result;\n};\nconst addOrEditCSSRule = (selector, rules, id) => {\n    var styleEl = document.createElement('style');\n    if (id) {\n        const existingElement = document.getElementById(id);\n        if (existingElement) {\n            existingElement.remove();\n        }\n        styleEl.id = id;\n    }\n    // Append <style> element to <head>\n    document.head.appendChild(styleEl);\n    var styleSheet = styleEl.sheet;\n    if (styleSheet.insertRule) {\n        // All browsers, except IE before version 9\n        styleSheet.insertRule(selector + '{' + rules + '}', styleSheet.cssRules.length);\n    }\n    else if (styleSheet.addRule) {\n        // IE before version 9\n        styleSheet.addRule(selector, rules, styleSheet.rules.length);\n    }\n};\nconst applyChangeItemToDocument = (parentPort, storyboardId, plainChangeItem) => {\n    var _a;\n    if (!plainChangeItem || !plainChangeItem.type) {\n        return { sendNewNavTree: false, instantUpdateSuccessful: false };\n    }\n    const changeItem = (0, changeLedgerTypes_1.reconstructChangeLedgerClass)(plainChangeItem);\n    let extraInstantUpdateData = {};\n    let instantUpdateSuccessful = false;\n    // The display: none rule is needed for a lot of instant updates, so create it if it doesn't exist\n    if (!document.getElementById(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS)) {\n        addOrEditCSSRule(`.${identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS}`, 'display: none !important', identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);\n    }\n    let sendNewNavTree = false;\n    if (changeItem.type === changeLedgerTypes_1.ChangeType.ADD_JSX) {\n        const castChangeItem = changeItem;\n        const changeFields = castChangeItem.changeFields;\n        const newAddedIds = [];\n        if (changeFields.htmlForInstantUpdate) {\n            const elementToAdd = (0, jquery_1.default)(changeFields.htmlForInstantUpdate);\n            elementToAdd.attr(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');\n            elementToAdd.attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // So that the DOM tree refresh doesn't get triggered\n            elementToAdd.attr(identifierUtils_1.TEMPO_OUTLINE_UNTIL_REFESH, 'true');\n            const ID_FOR_ELEMENT = `${exports.ADD_JSX_PREFIX}${(0, uuid_1.v4)()}`;\n            elementToAdd.attr(identifierUtils_1.TEMPO_ELEMENT_ID, ID_FOR_ELEMENT);\n            elementToAdd.addClass(ID_FOR_ELEMENT);\n            newAddedIds.push(ID_FOR_ELEMENT);\n            (0, jquery_1.default)(`.${changeFields.codebaseIdToAddTo}`).each((index, item) => {\n                if (changeFields.afterCodebaseId) {\n                    const afterElement = (0, jquery_1.default)(`.${changeFields.afterCodebaseId}`);\n                    if (!(afterElement === null || afterElement === void 0 ? void 0 : afterElement.length)) {\n                        return;\n                    }\n                    elementToAdd.insertAfter(afterElement.first());\n                }\n                else if (changeFields.beforeCodebaseId) {\n                    const beforeElement = (0, jquery_1.default)(`.${changeFields.beforeCodebaseId}`);\n                    if (!(beforeElement === null || beforeElement === void 0 ? void 0 : beforeElement.length)) {\n                        return;\n                    }\n                    elementToAdd.insertBefore(beforeElement.first());\n                }\n                else {\n                    (0, jquery_1.default)(item).append(elementToAdd);\n                }\n                sendNewNavTree = true;\n                instantUpdateSuccessful = true;\n            });\n        }\n        extraInstantUpdateData['newAddedIds'] = newAddedIds;\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.MOVE_JSX) {\n        const castChangeItem = changeItem;\n        // Find each element that matches the jsxCodebaseId\n        const sourceElements = [];\n        // See if direct matches work first\n        if ((0, jquery_1.default)(`.${castChangeItem.changeFields.codebaseIdToMove}`).length > 0) {\n            (0, jquery_1.default)(`.${castChangeItem.changeFields.codebaseIdToMove}`).each((index, element) => {\n                sourceElements.push((0, jquery_1.default)(element));\n            });\n        }\n        else {\n            // Try to find it by the component ID\n            let topLevelCodebaseId = getTopLevelCodebaseIdForComponent(castChangeItem.changeFields.codebaseIdToMove || '');\n            if (topLevelCodebaseId) {\n                (0, jquery_1.default)(`.${topLevelCodebaseId}`).each((index, element) => {\n                    sourceElements.push((0, jquery_1.default)(element));\n                });\n            }\n        }\n        // If the container is a component, drop into the codebaseId of the top-most child div\n        let containerCodebaseId = getTopLevelCodebaseIdForComponent(castChangeItem.changeFields.codebaseIdToMoveTo || '') || castChangeItem.changeFields.codebaseIdToMoveTo;\n        // For each source element, find the new matching parent element\n        const newParentElements = [];\n        sourceElements.forEach((element) => {\n            let newParentElement = null;\n            // For each parent, try to see if it either matches or contains the new parent\n            let parentElement = element.parent();\n            while (parentElement.length) {\n                // If the parent directly matches, this is it\n                if (parentElement.hasClass(containerCodebaseId)) {\n                    newParentElement = parentElement;\n                    break;\n                }\n                // Check children that match the codebase ID to drop into\n                const matchingChildren = parentElement.find(`.${containerCodebaseId}`);\n                if (matchingChildren.length) {\n                    // TODO: What if this matches more than one?\n                    newParentElement = matchingChildren.first();\n                    break;\n                }\n                parentElement = parentElement.parent();\n            }\n            if (!newParentElement) {\n                newParentElements.push(null);\n                return;\n            }\n            newParentElements.push(newParentElement);\n        });\n        // For each child/parentElement pair, move the child to the new parent\n        sourceElements.forEach((element, index) => {\n            const newParentElement = newParentElements[index];\n            if (!newParentElement.length) {\n                console.log('Could not find new parent element for instant update');\n                return;\n            }\n            sendNewNavTree = true;\n            instantUpdateSuccessful = true;\n            element.attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');\n            // If the parent hasn't changed, just move it, otherwise clone it and create a new one in the new spot\n            let useClone = !newParentElement.is(element.parent());\n            // So that nextjs hot reloading works, simply hide the element and clone it into the new spot\n            let cloneElement;\n            if (useClone) {\n                cloneElement = element.clone();\n                cloneElement.attr(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');\n                element.addClass(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);\n                element.attr(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH, 'true');\n            }\n            if (castChangeItem.changeFields.afterCodebaseId) {\n                const afterIdToUse = getTopLevelCodebaseIdForComponent(castChangeItem.changeFields.afterCodebaseId) || castChangeItem.changeFields.afterCodebaseId;\n                const afterElement = newParentElement.children(`.${afterIdToUse}`);\n                if (afterElement.length) {\n                    if (useClone && cloneElement) {\n                        cloneElement.insertAfter(afterElement.first());\n                    }\n                    else {\n                        element.insertAfter(afterElement.first());\n                    }\n                    return;\n                }\n            }\n            if (castChangeItem.changeFields.beforeCodebaseId) {\n                const beforeIdToUse = getTopLevelCodebaseIdForComponent(castChangeItem.changeFields.beforeCodebaseId) || castChangeItem.changeFields.beforeCodebaseId;\n                const beforeElement = newParentElement.children(`.${beforeIdToUse}`);\n                if (beforeElement.length) {\n                    if (useClone && cloneElement) {\n                        cloneElement.insertBefore(beforeElement.first());\n                    }\n                    else {\n                        element.insertBefore(beforeElement.first());\n                    }\n                    return;\n                }\n            }\n            if (useClone && cloneElement) {\n                cloneElement.appendTo(newParentElement);\n            }\n            else {\n                element.appendTo(newParentElement);\n            }\n        });\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.REMOVE_JSX) {\n        const castChangeItem = changeItem;\n        const parentToElementKeysRemoved = {};\n        castChangeItem.changeFields.codebaseIdsToRemove.forEach((codebaseId) => {\n            // See if direct matches work first\n            let codebaseIdToRemove;\n            if ((0, jquery_1.default)(`.${codebaseId}`).length > 0) {\n                codebaseIdToRemove = codebaseId;\n            }\n            else {\n                // Try to find it by the component ID\n                let topLevelCodebaseId = getTopLevelCodebaseIdForComponent(codebaseId || '');\n                if (!topLevelCodebaseId) {\n                    console.log('Could not find component element for instant update');\n                    return false;\n                }\n                codebaseIdToRemove = topLevelCodebaseId;\n            }\n            // For each item that is removed, save the inner HTML in case it gets deleted and we want to undo\n            (0, jquery_1.default)(`.${codebaseIdToRemove}`).each((index, item) => {\n                const elementKeyRemoved = (0, identifierUtils_1.getElementKeyFromNode)(item);\n                const parentElementKey = (0, identifierUtils_1.getElementKeyFromNode)(item.parentElement);\n                if (elementKeyRemoved && parentElementKey) {\n                    if (!parentToElementKeysRemoved[parentElementKey]) {\n                        parentToElementKeysRemoved[parentElementKey] = [];\n                    }\n                    parentToElementKeysRemoved[parentElementKey].push({\n                        outerHTML: item.outerHTML,\n                        elementKeyRemoved,\n                    });\n                }\n                item.classList.add(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);\n                item.setAttribute(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH, 'true');\n                sendNewNavTree = true;\n                instantUpdateSuccessful = true;\n            });\n        });\n        extraInstantUpdateData.parentToElementKeysRemoved =\n            parentToElementKeysRemoved;\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.ADD_CLASS ||\n        changeItem.type === changeLedgerTypes_1.ChangeType.STYLING) {\n        let className, cssEquivalent, codebaseIdToAddClass, temporaryClass, codebaseClassName, modifiers;\n        if (changeItem.type === changeLedgerTypes_1.ChangeType.ADD_CLASS) {\n            const castChangeItem = changeItem;\n            codebaseClassName = castChangeItem.changeFields.className;\n            className = castChangeItem.changeFields.className;\n            cssEquivalent = castChangeItem.changeFields.cssEquivalent;\n            codebaseIdToAddClass = castChangeItem.changeFields.codebaseIdToAddClass;\n            temporaryClass = castChangeItem.changeFields.temporaryOnly;\n            modifiers = castChangeItem.changeFields.modifiers;\n            if (temporaryClass) {\n                className = exports.TEMPORARY_STYLING_CLASS_NAME;\n            }\n        }\n        else {\n            // As of March 6, 2024 we only support tailwind STYLING changes, so treat them as adding a class\n            const castChangeItem = changeItem.changeFields;\n            className = '';\n            cssEquivalent = Object.keys(castChangeItem.stylingChanges)\n                .map((key) => {\n                if (castChangeItem.stylingChanges[key] === constantsAndTypes_1.DELETE_STYLE_CONSTANT) {\n                    return `${(0, cssRuleUtils_1.camelToSnakeCase)(key)}: unset !important;`;\n                }\n                return `${(0, cssRuleUtils_1.camelToSnakeCase)(key)}: ${castChangeItem.stylingChanges[key]};`;\n            })\n                .join('');\n            codebaseIdToAddClass = castChangeItem.codebaseId;\n            modifiers = castChangeItem.modifiers;\n        }\n        const SAFE_CLASSNAME_REGEX = /[^A-Za-z0-9_-]/g;\n        // Escape any custom classes\n        let classToAdd = (className || '')\n            .replace(SAFE_CLASSNAME_REGEX, '-') // Replace any non-alphanumeric characters with '-'\n            .replace(/^\\d/, '-$&'); // If the class starts with a digit, prepend with '-'\n        // Instead of adding the class name, generate a new class and set the\n        // css equivalent values inside it\n        // This class will be deleted after a hot reload\n        // Note - for temporary classes we want to explicitly use the same class\n        if (cssEquivalent && !temporaryClass) {\n            const msSinceJan1 = Date.now() - 1704067200000;\n            classToAdd = `${identifierUtils_1.TEMPO_INSTANT_UPDATE_STYLING_PREFIX}${msSinceJan1}-${classToAdd}`;\n        }\n        if (classToAdd) {\n            if (!temporaryClass) {\n                // Clear the temporary class on this element if it has it\n                (0, jquery_1.default)(`.${codebaseIdToAddClass}`).removeClass(exports.TEMPORARY_STYLING_CLASS_NAME);\n            }\n            if (cssEquivalent) {\n                if (modifiers && modifiers.length > 0) {\n                    const CSS_PSEUDO_MODIFIERS = [\n                        'hover',\n                        'required',\n                        'focus',\n                        'active',\n                        'invalid',\n                        'disabled',\n                    ];\n                    const pseudoModifiers = modifiers.filter((modifier) => CSS_PSEUDO_MODIFIERS.includes(modifier));\n                    const pseudoModifiersSuffix = pseudoModifiers.join(':');\n                    if (pseudoModifiers.length > 0) {\n                        const modifierClass = `${classToAdd}:${pseudoModifiersSuffix}`;\n                        addOrEditCSSRule(`.${modifierClass}`, cssEquivalent, modifierClass);\n                    }\n                    else {\n                        addOrEditCSSRule(`.${classToAdd}`, cssEquivalent, classToAdd);\n                    }\n                    const forceClasses = modifiers\n                        .map((modifier) => `.tempo-force-${modifier}`)\n                        .join('');\n                    const instantUpdateForForceClass = `${classToAdd}${forceClasses}`;\n                    addOrEditCSSRule(`.${instantUpdateForForceClass}`, cssEquivalent, instantUpdateForForceClass);\n                }\n                else {\n                    addOrEditCSSRule(`.${classToAdd}`, cssEquivalent, classToAdd);\n                }\n            }\n            const currentAddClassValues = (0, sessionStorageUtils_1.getMemoryStorageItem)(exports.ADD_CLASS_INSTANT_UPDATE_QUEUE) || [];\n            // See if direct matches work first\n            if ((0, jquery_1.default)(`.${codebaseIdToAddClass}`).length > 0) {\n                (0, jquery_1.default)(`.${codebaseIdToAddClass}`).addClass(classToAdd);\n                instantUpdateSuccessful = true;\n                currentAddClassValues.push({\n                    codebaseId: codebaseIdToAddClass,\n                    className: classToAdd,\n                });\n            }\n            else {\n                // Try to find it by the component ID\n                let topLevelCodebaseId = getTopLevelCodebaseIdForComponent(codebaseIdToAddClass || '');\n                if (topLevelCodebaseId && (0, jquery_1.default)(`.${topLevelCodebaseId}`).length > 0) {\n                    instantUpdateSuccessful = true;\n                    (0, jquery_1.default)(`.${topLevelCodebaseId}`).addClass(classToAdd);\n                    currentAddClassValues.push({\n                        codebaseId: topLevelCodebaseId,\n                        className: classToAdd,\n                    });\n                }\n            }\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(exports.ADD_CLASS_INSTANT_UPDATE_QUEUE, currentAddClassValues);\n            extraInstantUpdateData.addedClass = classToAdd;\n            extraInstantUpdateData.codebaseAddedClass = codebaseClassName;\n        }\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.REMOVE_CLASS) {\n        const removeClassChangeFields = changeItem.changeFields;\n        // See if direct matches work first\n        if ((0, jquery_1.default)(`.${removeClassChangeFields.codebaseIdToRemoveClass}`).length > 0) {\n            (0, jquery_1.default)(`.${removeClassChangeFields.codebaseIdToRemoveClass}`).removeClass(removeClassChangeFields.className);\n            instantUpdateSuccessful = true;\n        }\n        else {\n            // Try to find it by the component ID\n            let topLevelCodebaseId = getTopLevelCodebaseIdForComponent(removeClassChangeFields.codebaseIdToRemoveClass || '');\n            if (topLevelCodebaseId && (0, jquery_1.default)(`.${topLevelCodebaseId}`).length > 0) {\n                instantUpdateSuccessful = true;\n                (0, jquery_1.default)(`.${topLevelCodebaseId}`).removeClass(removeClassChangeFields.className);\n            }\n        }\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.WRAP_DIV) {\n        const changeFields = changeItem.changeFields;\n        const codebaseIdsToWrap = changeFields.codebaseIdsToWrap;\n        const firstCodebaseId = codebaseIdsToWrap[0];\n        // We assume the other codebase IDs are siblings of this codebase ID, so we\n        // find each instance of the first one and include the other items that match in it\n        // If the other items aren't all found, we do not wrap and let hot reload handle it\n        (0, jquery_1.default)(`.${firstCodebaseId}`).each((index, item) => {\n            const otherCodebaseIds = codebaseIdsToWrap.slice(1);\n            // For each codebase ID in otherCodebaseIds, retrieve the element that is a sibling of item\n            const siblings = (0, jquery_1.default)(item).siblings();\n            const allItemsToAddToNewDiv = [item];\n            let earliestItem = item;\n            let earliestIndex = (0, jquery_1.default)(item).index();\n            otherCodebaseIds.forEach((codebaseId) => {\n                const foundSibling = siblings.filter(`.${codebaseId}`).get(0);\n                if (foundSibling) {\n                    allItemsToAddToNewDiv.push(foundSibling);\n                    const index = (0, jquery_1.default)(foundSibling).index();\n                    if (index < earliestIndex) {\n                        earliestItem = foundSibling;\n                        earliestIndex = index;\n                    }\n                }\n            });\n            // TODO: What to do if they all can't be found?\n            if (allItemsToAddToNewDiv.length !== codebaseIdsToWrap.length) {\n                // For now, just add the ones that were found\n            }\n            // Create a div with a clone of the item, while hiding the item\n            // When the hot reload happens the clone gets deleted and the item is shown again\n            const newDiv = document.createElement('div');\n            newDiv.className = exports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID;\n            newDiv.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // So that the DOM tree refresh doesn't get triggered\n            newDiv.setAttribute('tempoelementid', exports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID);\n            newDiv.setAttribute('data-testid', exports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID);\n            newDiv.setAttribute(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');\n            allItemsToAddToNewDiv.forEach((elem) => {\n                newDiv.appendChild(elem.cloneNode(true));\n                elem.classList.add(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);\n                elem.setAttribute(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH, 'true');\n            });\n            // Insert the new div right before the first item\n            earliestItem.insertAdjacentElement('beforebegin', newDiv);\n            sendNewNavTree = true;\n            instantUpdateSuccessful = true;\n        });\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.DUPLICATE) {\n        const changeFileds = changeItem.changeFields;\n        const codebaseIdsToDuplicate = changeFileds.codebaseIdsToDuplicate;\n        codebaseIdsToDuplicate.forEach((codebaseIdToDuplicate) => {\n            (0, jquery_1.default)(`.${codebaseIdToDuplicate}`).each((index, item) => {\n                const clonedNode = item.cloneNode(true);\n                clonedNode.setAttribute(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');\n                clonedNode.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // So that the DOM tree refresh doesn't get triggered\n                // Set up all the correct duplicated codebase IDs\n                clonedNode.setAttribute('tempoelementid', `${exports.DUPLICATE_PLACEHOLDER_PREFIX}${codebaseIdToDuplicate}`);\n                clonedNode.setAttribute('data-testid', `${exports.DUPLICATE_PLACEHOLDER_PREFIX}${codebaseIdToDuplicate}`);\n                clonedNode.classList.add(exports.DUPLICATE_PLACEHOLDER_PREFIX + codebaseIdToDuplicate);\n                clonedNode.classList.remove(codebaseIdToDuplicate);\n                let children = Array.from(clonedNode.children);\n                while (children.length) {\n                    const child = children.pop();\n                    if (!child) {\n                        continue;\n                    }\n                    const codebaseId = child.getAttribute('tempoelementid') ||\n                        child.getAttribute('data-testid');\n                    if (!codebaseId) {\n                        continue;\n                    }\n                    child.setAttribute('tempoelementid', `${exports.DUPLICATE_PLACEHOLDER_PREFIX}${codebaseId}`);\n                    child.setAttribute('data-testid', `${exports.DUPLICATE_PLACEHOLDER_PREFIX}${codebaseId}`);\n                    child.classList.remove(codebaseId);\n                    child.classList.add(exports.DUPLICATE_PLACEHOLDER_PREFIX + codebaseId);\n                    child.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');\n                    children.push(...Array.from(child.children));\n                }\n                // Add the clones node right after the found node\n                item.insertAdjacentElement('afterend', clonedNode);\n                sendNewNavTree = true;\n                instantUpdateSuccessful = true;\n            });\n        });\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.CHANGE_TAG) {\n        const changeFields = changeItem.changeFields;\n        (0, jquery_1.default)(`.${changeFields.codebaseIdToChange}`).each((index, item) => {\n            const $newElement = (0, jquery_1.default)('<' + changeFields.newTagName + '></' + changeFields.newTagName + '>');\n            $newElement.attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // So that the DOM tree refresh doesn't get triggered\n            $newElement.attr(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');\n            const $item = (0, jquery_1.default)(item);\n            // Copy all attributes from the original element to the new element\n            jquery_1.default.each($item[0].attributes, function () {\n                $newElement.attr(this.name, this.value);\n            });\n            $item.contents().clone(true, true).appendTo($newElement);\n            // Add right before the cloned item so the unique path stays the same\n            $item.before($newElement);\n            // Hide the original item\n            $item.addClass(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);\n            $item.attr(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH, 'true');\n            sendNewNavTree = true;\n            instantUpdateSuccessful = true;\n        });\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.UNDO) {\n        const { sendNewNavTree: _sendNewNavTree, instantUpdateSuccessful: _instantUpdateSuccessful, } = applyUndoChangeItemToDocument(parentPort, changeItem);\n        sendNewNavTree = _sendNewNavTree;\n        instantUpdateSuccessful = _instantUpdateSuccessful;\n    }\n    else if (changeItem.type === changeLedgerTypes_1.ChangeType.REDO) {\n        const changeFields = changeItem.changeFields;\n        const changeToRedo = changeFields.changeToRedo;\n        if (changeLedgerTypes_1.CHANGE_TYPES_WITH_INSTANT_UNDO.includes(changeToRedo.type)) {\n            const { sendNewNavTree: _sendNewNavTree, instantUpdateSuccessful: _instantUpdateSuccessful, } = (0, exports.applyChangeItemToDocument)(parentPort, storyboardId, changeToRedo);\n            sendNewNavTree = _sendNewNavTree;\n            instantUpdateSuccessful = _instantUpdateSuccessful;\n            if (changeToRedo.prevIdToNewIdMap) {\n                (0, exports.updateCodebaseIds)(parentPort, changeToRedo.prevIdToNewIdMap, true);\n            }\n        }\n    }\n    // Immediately set the new selected element keys to prevent any delay in the outlines updating\n    let elementKeyToSelectAfterInstantUpdate = changeItem.getElementKeyToSelectAfterInstantUpdate();\n    let elementKeysToMultiselectAfterInstantUpdate = changeItem.getElementKeysToMultiselectAfterInstantUpdate();\n    if (changeItem.type === changeLedgerTypes_1.ChangeType.UNDO) {\n        elementKeyToSelectAfterInstantUpdate = changeItem.changeFields.changeToUndo.getElementKeyToSelectAfterUndoInstantUpdate();\n        elementKeysToMultiselectAfterInstantUpdate = changeItem.changeFields.changeToUndo.getElementKeysToMultiselectAfterUndoInstantUpdate();\n    }\n    if (elementKeyToSelectAfterInstantUpdate !== undefined) {\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, elementKeyToSelectAfterInstantUpdate);\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n            elementKey: elementKeyToSelectAfterInstantUpdate,\n            outerHTML: (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKeyToSelectAfterInstantUpdate}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML,\n        });\n    }\n    if (elementKeysToMultiselectAfterInstantUpdate !== undefined) {\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, elementKeysToMultiselectAfterInstantUpdate);\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,\n            elementKeys: elementKeysToMultiselectAfterInstantUpdate,\n            outerHTMLs: elementKeysToMultiselectAfterInstantUpdate === null || elementKeysToMultiselectAfterInstantUpdate === void 0 ? void 0 : elementKeysToMultiselectAfterInstantUpdate.map((elementKey) => { var _a; return (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKey}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML; }),\n        });\n    }\n    if (instantUpdateSuccessful) {\n        // Delete any elements that need to be deleted after instant updates\n        (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_DELETE_AFTER_INSTANT_UPDATE}=true]`).remove();\n    }\n    parentPort.postMessage({\n        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.INSTANT_UPDATE_DONE,\n        changeItem: plainChangeItem,\n        instantUpdateData: extraInstantUpdateData,\n        instantUpdateSuccessful,\n    });\n    return { sendNewNavTree, instantUpdateSuccessful };\n};\nexports.applyChangeItemToDocument = applyChangeItemToDocument;\nconst applyUndoChangeItemToDocument = (parentPort, changeItem) => {\n    const changeFields = changeItem.changeFields;\n    const changeToUndo = changeFields.changeToUndo;\n    if (!changeLedgerTypes_1.CHANGE_TYPES_WITH_INSTANT_UNDO.includes(changeToUndo.type)) {\n        return { sendNewNavTree: false, instantUpdateSuccessful: false };\n    }\n    let sendNewNavTree = false;\n    let instantUpdateSuccessful = false;\n    // API has completed and the IDs have been updated, reverse this change\n    if (changeToUndo.prevIdToNewIdMap) {\n        const undoCodebaseIdChanges = {};\n        Object.keys(changeToUndo.prevIdToNewIdMap).forEach((prevId) => {\n            const newId = changeToUndo.prevIdToNewIdMap[prevId];\n            undoCodebaseIdChanges[newId] = prevId;\n        });\n        // If undoing do not update the codebase IDs backwards if there are codebase IDs to set after\n        // the undo instant update is done\n        const selectedElementSpecifiedAfterUndo = changeToUndo.getElementKeyToSelectAfterUndoInstantUpdate() !== undefined;\n        (0, exports.updateCodebaseIds)(parentPort, undoCodebaseIdChanges, !selectedElementSpecifiedAfterUndo);\n    }\n    // Then undo the actual change\n    if (changeToUndo.type === changeLedgerTypes_1.ChangeType.REMOVE_JSX) {\n        // Re-add the removed JSX\n        const innerChangeFields = changeToUndo.changeFields;\n        const codebaseIdsToReadd = innerChangeFields.codebaseIdsToRemove;\n        // If it has been flushed, re-create the html elements from the saved inner HTML\n        if (changeFields.matchingActivityFlushed) {\n            const instantUpdateData = changeToUndo.getInstantUpdateData();\n            const parentToElementKeysRemoved = instantUpdateData.parentToElementKeysRemoved || {};\n            Object.entries(parentToElementKeysRemoved).forEach(([parentElementKey, itemsRemoved]) => {\n                // Sort the removed entries in order of unique path\n                const sortedItemsRemoved = Object.values(itemsRemoved).sort((a, b) => {\n                    const aElementKey = tempoElement_1.TempoElement.fromKey(a.elementKeyRemoved);\n                    const bElementKey = tempoElement_1.TempoElement.fromKey(b.elementKeyRemoved);\n                    return aElementKey.uniquePath.localeCompare(bElementKey.uniquePath);\n                });\n                // Find the parent element\n                const parentElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${parentElementKey}`).get(0);\n                if (parentElement) {\n                    // Add the removed elements back in order\n                    sortedItemsRemoved.forEach((item) => {\n                        const { elementKeyRemoved, outerHTML } = item;\n                        const element = tempoElement_1.TempoElement.fromKey(elementKeyRemoved);\n                        const indexInParent = Number(element.uniquePath.split('-').pop());\n                        const newElementFromHtml = (0, jquery_1.default)(outerHTML).get(0);\n                        // Add to the parent in the index\n                        if (newElementFromHtml) {\n                            newElementFromHtml.setAttribute(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');\n                            newElementFromHtml.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');\n                            parentElement.insertBefore(newElementFromHtml, parentElement.children[indexInParent] || null);\n                            instantUpdateSuccessful = true;\n                            sendNewNavTree = true;\n                        }\n                    });\n                }\n            });\n        }\n        else {\n            // Not flushed yet so can just re-add\n            codebaseIdsToReadd.forEach((codebaseIdToReadd) => {\n                (0, jquery_1.default)(`.${codebaseIdToReadd}`).each((index, item) => {\n                    item.classList.remove(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);\n                    item.removeAttribute(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH);\n                    sendNewNavTree = true;\n                    instantUpdateSuccessful = true;\n                });\n            });\n        }\n    }\n    else if (changeToUndo.type === changeLedgerTypes_1.ChangeType.ADD_CLASS ||\n        changeToUndo.type === changeLedgerTypes_1.ChangeType.STYLING) {\n        const instantUpdateData = changeToUndo.getInstantUpdateData();\n        const innerChangeFields = changeToUndo.changeFields;\n        const addedClass = instantUpdateData === null || instantUpdateData === void 0 ? void 0 : instantUpdateData.addedClass;\n        if (addedClass) {\n            (0, jquery_1.default)(`.${innerChangeFields.codebaseIdToAddClass}`).each((index, item) => {\n                if ((0, jquery_1.default)(item).hasClass(addedClass)) {\n                    (0, jquery_1.default)(item).removeClass(addedClass);\n                    instantUpdateSuccessful = true;\n                }\n            });\n        }\n        const codebaseAddedClass = instantUpdateData === null || instantUpdateData === void 0 ? void 0 : instantUpdateData.codebaseAddedClass;\n        if (codebaseAddedClass) {\n            (0, jquery_1.default)(`.${innerChangeFields.codebaseIdToAddClass}`).each((index, item) => {\n                if ((0, jquery_1.default)(item).hasClass(codebaseAddedClass)) {\n                    (0, jquery_1.default)(item).removeClass(codebaseAddedClass);\n                    instantUpdateSuccessful = true;\n                }\n            });\n        }\n    }\n    else if (changeToUndo.type === changeLedgerTypes_1.ChangeType.ADD_JSX) {\n        const instantUpdateData = changeToUndo.getInstantUpdateData();\n        const addedIds = instantUpdateData === null || instantUpdateData === void 0 ? void 0 : instantUpdateData.addedIds;\n        addedIds === null || addedIds === void 0 ? void 0 : addedIds.forEach((addedId) => {\n            (0, jquery_1.default)(`.${addedId}`).remove();\n            instantUpdateSuccessful = true;\n        });\n        sendNewNavTree = true;\n    }\n    return { sendNewNavTree, instantUpdateSuccessful };\n};\n/**\n * After a change is processed on the backend, we need to update the codebase ids in the document.\n */\nconst updateCodebaseIds = (parentPort, prevIdToNewIdMap, updateElementKeys) => {\n    // Update codebase ids in the document\n    const changes = [];\n    Object.entries(prevIdToNewIdMap).forEach(([prevCodebaseId, newCodebaseId]) => {\n        (0, jquery_1.default)(`.${prevCodebaseId}`).each((index, item) => {\n            changes.push({\n                item,\n                prevCodebaseId,\n                newCodebaseId,\n            });\n        });\n    });\n    // Codebase Ids can swap, so we have to apply the changes after looking all elements up\n    changes.forEach((change) => {\n        const $item = (0, jquery_1.default)(change.item);\n        const newClass = ($item.attr('class') || '').replace(new RegExp(`${change.prevCodebaseId}`, 'g'), change.newCodebaseId);\n        $item.attr('class', newClass);\n        change.item.setAttribute('tempoelementid', change.newCodebaseId);\n        change.item.setAttribute('data-testid', change.newCodebaseId);\n    });\n    if (!updateElementKeys) {\n        return Boolean(changes.length);\n    }\n    const keysToCheck = [\n        {\n            key: sessionStorageUtils_1.SELECTED_ELEMENT_KEY,\n            messageId: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n        },\n        {\n            key: sessionStorageUtils_1.HOVERED_ELEMENT_KEY,\n            messageId: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.HOVERED_ELEMENT_KEY,\n        },\n    ];\n    keysToCheck.forEach(({ key, messageId }) => {\n        var _a;\n        const elementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(key);\n        const tempoElement = tempoElement_1.TempoElement.fromKey(elementKey);\n        if (prevIdToNewIdMap[tempoElement.codebaseId]) {\n            const newElement = new tempoElement_1.TempoElement(prevIdToNewIdMap[tempoElement.codebaseId], tempoElement.storyboardId, tempoElement.uniquePath);\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(key, newElement.getKey());\n            parentPort.postMessage({\n                id: messageId,\n                elementKey: newElement.getKey(),\n                outerHTML: (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${newElement.getKey()}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML,\n            });\n        }\n    });\n    // Also update the multiselected element keys\n    const multiselectedElementKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);\n    if (multiselectedElementKeys === null || multiselectedElementKeys === void 0 ? void 0 : multiselectedElementKeys.length) {\n        const newMultiselectedElementKeys = [];\n        multiselectedElementKeys.forEach((elementKey) => {\n            const tempoElement = tempoElement_1.TempoElement.fromKey(elementKey);\n            if (prevIdToNewIdMap[tempoElement.codebaseId]) {\n                const newElement = new tempoElement_1.TempoElement(prevIdToNewIdMap[tempoElement.codebaseId], tempoElement.storyboardId, tempoElement.uniquePath);\n                newMultiselectedElementKeys.push(newElement.getKey());\n            }\n            else {\n                newMultiselectedElementKeys.push(elementKey);\n            }\n        });\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, newMultiselectedElementKeys);\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,\n            elementKeys: newMultiselectedElementKeys,\n            outerHTMLs: newMultiselectedElementKeys === null || newMultiselectedElementKeys === void 0 ? void 0 : newMultiselectedElementKeys.map((elementKey) => { var _a; return (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKey}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML; }),\n        });\n    }\n    return Boolean(changes.length);\n};\nexports.updateCodebaseIds = updateCodebaseIds;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2NoYW5nZUl0ZW1GdW5jdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxpQ0FBaUMsR0FBRyxvQ0FBb0MsR0FBRyxzQ0FBc0MsR0FBRyxzQkFBc0IsR0FBRyxvQ0FBb0MsR0FBRywyQ0FBMkM7QUFDM1AsaUNBQWlDLG1CQUFPLENBQUMsMERBQVE7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ3JELDRCQUE0QixtQkFBTyxDQUFDLDJHQUFxQjtBQUN6RCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBcUI7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWdCO0FBQy9DLDhCQUE4QixtQkFBTyxDQUFDLCtHQUF1QjtBQUM3RCx1QkFBdUIsbUJBQU8sQ0FBQyxpR0FBZ0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLDhEQUFNO0FBQzdCO0FBQ0EsMkNBQTJDO0FBQzNDLG9DQUFvQztBQUNwQyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUF5RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSxzQ0FBc0MsdUJBQXVCLEVBQUUsaUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQkFBK0I7QUFDckU7QUFDQSxtRUFBbUUsNkJBQTZCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw4QkFBOEI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBNkM7QUFDbkYsc0NBQXNDLDZDQUE2QztBQUNuRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLG9CQUFvQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBDQUEwQyxtQkFBbUI7QUFDM0Y7QUFDQSwwQkFBMEIsMENBQTBDLElBQUksb0NBQW9DO0FBQzVHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzREFBc0QsRUFBRSxZQUFZLEdBQUcsV0FBVztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXLEdBQUcsc0JBQXNCO0FBQ3JGLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQSwwREFBMEQsV0FBVyxFQUFFLGFBQWE7QUFDcEYseUNBQXlDLDJCQUEyQjtBQUNwRTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9ELDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbUJBQW1CO0FBQ3ZGO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0RBQWdEO0FBQ3RGLHNDQUFzQyxnREFBZ0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxtQkFBbUI7QUFDbkY7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsNkRBQTZELHFDQUFxQyxFQUFFLHNCQUFzQjtBQUMxSCwwREFBMEQscUNBQXFDLEVBQUUsc0JBQXNCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFDQUFxQyxFQUFFLFdBQVc7QUFDOUcseURBQXlELHFDQUFxQyxFQUFFLFdBQVc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0NBQWdDO0FBQ2xFO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLHNGQUFzRjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzRkFBc0Y7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUNBQXFDLEVBQUUscUNBQXFDO0FBQ25JLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTkFBaU4sUUFBUSx1Q0FBdUMscUNBQXFDLEVBQUUsV0FBVywrREFBK0Q7QUFDalgsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvREFBb0Q7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdFQUFnRSxxQ0FBcUMsRUFBRSxpQkFBaUI7QUFDeEg7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1Q0FBdUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVDQUF1QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxzQkFBc0I7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFDQUFxQyxFQUFFLG9CQUFvQjtBQUN0SCxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvS0FBb0ssUUFBUSx1Q0FBdUMscUNBQXFDLEVBQUUsV0FBVywrREFBK0Q7QUFDcFUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHRlbXBvLWRldnRvb2xzXFxkaXN0XFxjaGFubmVsTWVzc2FnaW5nXFxjaGFuZ2VJdGVtRnVuY3Rpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51cGRhdGVDb2RlYmFzZUlkcyA9IGV4cG9ydHMuYXBwbHlDaGFuZ2VJdGVtVG9Eb2N1bWVudCA9IGV4cG9ydHMuVEVNUE9SQVJZX1NUWUxJTkdfQ0xBU1NfTkFNRSA9IGV4cG9ydHMuQUREX0NMQVNTX0lOU1RBTlRfVVBEQVRFX1FVRVVFID0gZXhwb3J0cy5BRERfSlNYX1BSRUZJWCA9IGV4cG9ydHMuRFVQTElDQVRFX1BMQUNFSE9MREVSX1BSRUZJWCA9IGV4cG9ydHMuV1JBUF9JTl9ESVZfUExBQ0VIT0xERVJfQ09ERUJBU0VfSUQgPSB2b2lkIDA7XG5jb25zdCBqcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianF1ZXJ5XCIpKTtcbmNvbnN0IGlkZW50aWZpZXJVdGlsc18xID0gcmVxdWlyZShcIi4vaWRlbnRpZmllclV0aWxzXCIpO1xuY29uc3QgY2hhbmdlTGVkZ2VyVHlwZXNfMSA9IHJlcXVpcmUoXCIuL2NoYW5nZUxlZGdlclR5cGVzXCIpO1xuY29uc3QgY29uc3RhbnRzQW5kVHlwZXNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c0FuZFR5cGVzXCIpO1xuY29uc3QgY3NzUnVsZVV0aWxzXzEgPSByZXF1aXJlKFwiLi9jc3NSdWxlVXRpbHNcIik7XG5jb25zdCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi9zZXNzaW9uU3RvcmFnZVV0aWxzXCIpO1xuY29uc3QgdGVtcG9FbGVtZW50XzEgPSByZXF1aXJlKFwiLi90ZW1wb0VsZW1lbnRcIik7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbi8vIFRoZXNlIGNvbnN0YW50cyBtYXRjaCB3aGF0IHRlbXBvLWFwaSBoYXNcbmV4cG9ydHMuV1JBUF9JTl9ESVZfUExBQ0VIT0xERVJfQ09ERUJBU0VfSUQgPSAndGVtcG8td3JhcC1pbi1kaXYtcGxhY2Vob2xkZXInO1xuZXhwb3J0cy5EVVBMSUNBVEVfUExBQ0VIT0xERVJfUFJFRklYID0gJ3RlbXBvLWR1cGxpY2F0ZS1wbGFjZWhvbGRlci0nO1xuZXhwb3J0cy5BRERfSlNYX1BSRUZJWCA9ICd0ZW1wby1hZGQtanN4LXBsYWNlaG9sZGVyLSc7XG4vLyBTdG9yZWQgaW4gbWVtb3J5IHN0b3JhZ2UsIHVzZWQgdG8ga2VlcCB0cmFjayBvZiBzb21lIHBvc3NpYmxlIGFkZCBjbGFzcyBpbnN0YW50XG4vLyB1cGRhdGVzIHRoYXQgbmVlZCB0byBiZSByZS1hcHBsaWVkIGFmdGVyIGEgaG90IHJlbG9hZFxuLy8gKGUuZy4gd2hlbiB0aGUgYWRkaXRpb25hbCkgaW5zdGFudCB1cGRhdGVzIGhhcHBlbmVkIGR1cmluZyBmbHVzaGluZ1xuZXhwb3J0cy5BRERfQ0xBU1NfSU5TVEFOVF9VUERBVEVfUVVFVUUgPSAnQUREX0NMQVNTX0lOU1RBTlRfVVBEQVRFX1FVRVVFJztcbmV4cG9ydHMuVEVNUE9SQVJZX1NUWUxJTkdfQ0xBU1NfTkFNRSA9ICdhcmI4OS10ZW1wLXN0eWxpbmcnO1xuY29uc3QgZ2V0VG9wTGV2ZWxDb2RlYmFzZUlkRm9yQ29tcG9uZW50ID0gKGNvbXBvbmVudElkKSA9PiB7XG4gICAgbGV0IHRvcExldmVsQ29kZWJhc2VJZCA9IG51bGw7XG4gICAgbGV0IG1pbk51bWJlclBhcmVudHMgPSBJbmZpbml0eTtcbiAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC5jb21wb25lbnQtJHtjb21wb25lbnRJZH1gKS5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4ge1xuICAgICAgICBpZiAoKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGVsZW1lbnQpLnBhcmVudHMoKS5sZW5ndGggPCBtaW5OdW1iZXJQYXJlbnRzKSB7XG4gICAgICAgICAgICBtaW5OdW1iZXJQYXJlbnRzID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGVsZW1lbnQpLnBhcmVudHMoKS5sZW5ndGg7XG4gICAgICAgICAgICB0b3BMZXZlbENvZGViYXNlSWQgPSAoMCwgaWRlbnRpZmllclV0aWxzXzEuZ2V0Q29kZWJhc2VJZEZyb21Ob2RlKShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0b3BMZXZlbENvZGViYXNlSWQ7XG59O1xuY29uc3QgbWFrZWlkID0gKGxlbmd0aCkgPT4ge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBjb25zdCBjaGFyYWN0ZXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbiAgICBjb25zdCBjaGFyYWN0ZXJzTGVuZ3RoID0gY2hhcmFjdGVycy5sZW5ndGg7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSk7XG4gICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBhZGRPckVkaXRDU1NSdWxlID0gKHNlbGVjdG9yLCBydWxlcywgaWQpID0+IHtcbiAgICB2YXIgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRWxlbWVudCkge1xuICAgICAgICAgICAgZXhpc3RpbmdFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlRWwuaWQgPSBpZDtcbiAgICB9XG4gICAgLy8gQXBwZW5kIDxzdHlsZT4gZWxlbWVudCB0byA8aGVhZD5cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICAgIHZhciBzdHlsZVNoZWV0ID0gc3R5bGVFbC5zaGVldDtcbiAgICBpZiAoc3R5bGVTaGVldC5pbnNlcnRSdWxlKSB7XG4gICAgICAgIC8vIEFsbCBicm93c2VycywgZXhjZXB0IElFIGJlZm9yZSB2ZXJzaW9uIDlcbiAgICAgICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHNlbGVjdG9yICsgJ3snICsgcnVsZXMgKyAnfScsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3R5bGVTaGVldC5hZGRSdWxlKSB7XG4gICAgICAgIC8vIElFIGJlZm9yZSB2ZXJzaW9uIDlcbiAgICAgICAgc3R5bGVTaGVldC5hZGRSdWxlKHNlbGVjdG9yLCBydWxlcywgc3R5bGVTaGVldC5ydWxlcy5sZW5ndGgpO1xuICAgIH1cbn07XG5jb25zdCBhcHBseUNoYW5nZUl0ZW1Ub0RvY3VtZW50ID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgcGxhaW5DaGFuZ2VJdGVtKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghcGxhaW5DaGFuZ2VJdGVtIHx8ICFwbGFpbkNoYW5nZUl0ZW0udHlwZSkge1xuICAgICAgICByZXR1cm4geyBzZW5kTmV3TmF2VHJlZTogZmFsc2UsIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VJdGVtID0gKDAsIGNoYW5nZUxlZGdlclR5cGVzXzEucmVjb25zdHJ1Y3RDaGFuZ2VMZWRnZXJDbGFzcykocGxhaW5DaGFuZ2VJdGVtKTtcbiAgICBsZXQgZXh0cmFJbnN0YW50VXBkYXRlRGF0YSA9IHt9O1xuICAgIGxldCBpbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgIC8vIFRoZSBkaXNwbGF5OiBub25lIHJ1bGUgaXMgbmVlZGVkIGZvciBhIGxvdCBvZiBpbnN0YW50IHVwZGF0ZXMsIHNvIGNyZWF0ZSBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ESVNQTEFZX05PTkVfVU5USUxfUkVGUkVTSF9DTEFTUykpIHtcbiAgICAgICAgYWRkT3JFZGl0Q1NTUnVsZShgLiR7aWRlbnRpZmllclV0aWxzXzEuVEVNUE9fRElTUExBWV9OT05FX1VOVElMX1JFRlJFU0hfQ0xBU1N9YCwgJ2Rpc3BsYXk6IG5vbmUgIWltcG9ydGFudCcsIGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0RJU1BMQVlfTk9ORV9VTlRJTF9SRUZSRVNIX0NMQVNTKTtcbiAgICB9XG4gICAgbGV0IHNlbmROZXdOYXZUcmVlID0gZmFsc2U7XG4gICAgaWYgKGNoYW5nZUl0ZW0udHlwZSA9PT0gY2hhbmdlTGVkZ2VyVHlwZXNfMS5DaGFuZ2VUeXBlLkFERF9KU1gpIHtcbiAgICAgICAgY29uc3QgY2FzdENoYW5nZUl0ZW0gPSBjaGFuZ2VJdGVtO1xuICAgICAgICBjb25zdCBjaGFuZ2VGaWVsZHMgPSBjYXN0Q2hhbmdlSXRlbS5jaGFuZ2VGaWVsZHM7XG4gICAgICAgIGNvbnN0IG5ld0FkZGVkSWRzID0gW107XG4gICAgICAgIGlmIChjaGFuZ2VGaWVsZHMuaHRtbEZvckluc3RhbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRUb0FkZCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShjaGFuZ2VGaWVsZHMuaHRtbEZvckluc3RhbnRVcGRhdGUpO1xuICAgICAgICAgICAgZWxlbWVudFRvQWRkLmF0dHIoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fREVMRVRFX0FGVEVSX1JFRlJFU0gsICd0cnVlJyk7XG4gICAgICAgICAgICBlbGVtZW50VG9BZGQuYXR0cihpZGVudGlmaWVyVXRpbHNfMS5URU1QT19JTlNUQU5UX1VQREFURSwgJ3RydWUnKTsgLy8gU28gdGhhdCB0aGUgRE9NIHRyZWUgcmVmcmVzaCBkb2Vzbid0IGdldCB0cmlnZ2VyZWRcbiAgICAgICAgICAgIGVsZW1lbnRUb0FkZC5hdHRyKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX09VVExJTkVfVU5USUxfUkVGRVNILCAndHJ1ZScpO1xuICAgICAgICAgICAgY29uc3QgSURfRk9SX0VMRU1FTlQgPSBgJHtleHBvcnRzLkFERF9KU1hfUFJFRklYfSR7KDAsIHV1aWRfMS52NCkoKX1gO1xuICAgICAgICAgICAgZWxlbWVudFRvQWRkLmF0dHIoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fRUxFTUVOVF9JRCwgSURfRk9SX0VMRU1FTlQpO1xuICAgICAgICAgICAgZWxlbWVudFRvQWRkLmFkZENsYXNzKElEX0ZPUl9FTEVNRU5UKTtcbiAgICAgICAgICAgIG5ld0FkZGVkSWRzLnB1c2goSURfRk9SX0VMRU1FTlQpO1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtjaGFuZ2VGaWVsZHMuY29kZWJhc2VJZFRvQWRkVG99YCkuZWFjaCgoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlRmllbGRzLmFmdGVyQ29kZWJhc2VJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZnRlckVsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2NoYW5nZUZpZWxkcy5hZnRlckNvZGViYXNlSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFmdGVyRWxlbWVudCA9PT0gbnVsbCB8fCBhZnRlckVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyRWxlbWVudC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFRvQWRkLmluc2VydEFmdGVyKGFmdGVyRWxlbWVudC5maXJzdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlRmllbGRzLmJlZm9yZUNvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlRWxlbWVudCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7Y2hhbmdlRmllbGRzLmJlZm9yZUNvZGViYXNlSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJlZm9yZUVsZW1lbnQgPT09IG51bGwgfHwgYmVmb3JlRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmVmb3JlRWxlbWVudC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFRvQWRkLmluc2VydEJlZm9yZShiZWZvcmVFbGVtZW50LmZpcnN0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGl0ZW0pLmFwcGVuZChlbGVtZW50VG9BZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZW5kTmV3TmF2VHJlZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFJbnN0YW50VXBkYXRlRGF0YVsnbmV3QWRkZWRJZHMnXSA9IG5ld0FkZGVkSWRzO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2VJdGVtLnR5cGUgPT09IGNoYW5nZUxlZGdlclR5cGVzXzEuQ2hhbmdlVHlwZS5NT1ZFX0pTWCkge1xuICAgICAgICBjb25zdCBjYXN0Q2hhbmdlSXRlbSA9IGNoYW5nZUl0ZW07XG4gICAgICAgIC8vIEZpbmQgZWFjaCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUganN4Q29kZWJhc2VJZFxuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50cyA9IFtdO1xuICAgICAgICAvLyBTZWUgaWYgZGlyZWN0IG1hdGNoZXMgd29yayBmaXJzdFxuICAgICAgICBpZiAoKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtjYXN0Q2hhbmdlSXRlbS5jaGFuZ2VGaWVsZHMuY29kZWJhc2VJZFRvTW92ZX1gKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2Nhc3RDaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9Nb3ZlfWApLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaCgoMCwganF1ZXJ5XzEuZGVmYXVsdCkoZWxlbWVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBpdCBieSB0aGUgY29tcG9uZW50IElEXG4gICAgICAgICAgICBsZXQgdG9wTGV2ZWxDb2RlYmFzZUlkID0gZ2V0VG9wTGV2ZWxDb2RlYmFzZUlkRm9yQ29tcG9uZW50KGNhc3RDaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9Nb3ZlIHx8ICcnKTtcbiAgICAgICAgICAgIGlmICh0b3BMZXZlbENvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke3RvcExldmVsQ29kZWJhc2VJZH1gKS5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKCgwLCBqcXVlcnlfMS5kZWZhdWx0KShlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBpcyBhIGNvbXBvbmVudCwgZHJvcCBpbnRvIHRoZSBjb2RlYmFzZUlkIG9mIHRoZSB0b3AtbW9zdCBjaGlsZCBkaXZcbiAgICAgICAgbGV0IGNvbnRhaW5lckNvZGViYXNlSWQgPSBnZXRUb3BMZXZlbENvZGViYXNlSWRGb3JDb21wb25lbnQoY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLmNvZGViYXNlSWRUb01vdmVUbyB8fCAnJykgfHwgY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLmNvZGViYXNlSWRUb01vdmVUbztcbiAgICAgICAgLy8gRm9yIGVhY2ggc291cmNlIGVsZW1lbnQsIGZpbmQgdGhlIG5ldyBtYXRjaGluZyBwYXJlbnQgZWxlbWVudFxuICAgICAgICBjb25zdCBuZXdQYXJlbnRFbGVtZW50cyA9IFtdO1xuICAgICAgICBzb3VyY2VFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3UGFyZW50RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBwYXJlbnQsIHRyeSB0byBzZWUgaWYgaXQgZWl0aGVyIG1hdGNoZXMgb3IgY29udGFpbnMgdGhlIG5ldyBwYXJlbnRcbiAgICAgICAgICAgIGxldCBwYXJlbnRFbGVtZW50ID0gZWxlbWVudC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwYXJlbnQgZGlyZWN0bHkgbWF0Y2hlcywgdGhpcyBpcyBpdFxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50Lmhhc0NsYXNzKGNvbnRhaW5lckNvZGViYXNlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgY2hpbGRyZW4gdGhhdCBtYXRjaCB0aGUgY29kZWJhc2UgSUQgdG8gZHJvcCBpbnRvXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdDaGlsZHJlbiA9IHBhcmVudEVsZW1lbnQuZmluZChgLiR7Y29udGFpbmVyQ29kZWJhc2VJZH1gKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBpZiB0aGlzIG1hdGNoZXMgbW9yZSB0aGFuIG9uZT9cbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50RWxlbWVudCA9IG1hdGNoaW5nQ2hpbGRyZW4uZmlyc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXdQYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50RWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdQYXJlbnRFbGVtZW50cy5wdXNoKG5ld1BhcmVudEVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRm9yIGVhY2ggY2hpbGQvcGFyZW50RWxlbWVudCBwYWlyLCBtb3ZlIHRoZSBjaGlsZCB0byB0aGUgbmV3IHBhcmVudFxuICAgICAgICBzb3VyY2VFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3UGFyZW50RWxlbWVudCA9IG5ld1BhcmVudEVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghbmV3UGFyZW50RWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGZpbmQgbmV3IHBhcmVudCBlbGVtZW50IGZvciBpbnN0YW50IHVwZGF0ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmROZXdOYXZUcmVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXR0cihpZGVudGlmaWVyVXRpbHNfMS5URU1QT19JTlNUQU5UX1VQREFURSwgJ3RydWUnKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJlbnQgaGFzbid0IGNoYW5nZWQsIGp1c3QgbW92ZSBpdCwgb3RoZXJ3aXNlIGNsb25lIGl0IGFuZCBjcmVhdGUgYSBuZXcgb25lIGluIHRoZSBuZXcgc3BvdFxuICAgICAgICAgICAgbGV0IHVzZUNsb25lID0gIW5ld1BhcmVudEVsZW1lbnQuaXMoZWxlbWVudC5wYXJlbnQoKSk7XG4gICAgICAgICAgICAvLyBTbyB0aGF0IG5leHRqcyBob3QgcmVsb2FkaW5nIHdvcmtzLCBzaW1wbHkgaGlkZSB0aGUgZWxlbWVudCBhbmQgY2xvbmUgaXQgaW50byB0aGUgbmV3IHNwb3RcbiAgICAgICAgICAgIGxldCBjbG9uZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodXNlQ2xvbmUpIHtcbiAgICAgICAgICAgICAgICBjbG9uZUVsZW1lbnQgPSBlbGVtZW50LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgY2xvbmVFbGVtZW50LmF0dHIoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fREVMRVRFX0FGVEVSX1JFRlJFU0gsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ESVNQTEFZX05PTkVfVU5USUxfUkVGUkVTSF9DTEFTUyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0RPX05PVF9TSE9XX0lOX05BVl9VTlRJTF9SRUZSRVNILCAndHJ1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhc3RDaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcy5hZnRlckNvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlcklkVG9Vc2UgPSBnZXRUb3BMZXZlbENvZGViYXNlSWRGb3JDb21wb25lbnQoY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLmFmdGVyQ29kZWJhc2VJZCkgfHwgY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLmFmdGVyQ29kZWJhc2VJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlckVsZW1lbnQgPSBuZXdQYXJlbnRFbGVtZW50LmNoaWxkcmVuKGAuJHthZnRlcklkVG9Vc2V9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNsb25lICYmIGNsb25lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVFbGVtZW50Lmluc2VydEFmdGVyKGFmdGVyRWxlbWVudC5maXJzdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QWZ0ZXIoYWZ0ZXJFbGVtZW50LmZpcnN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLmJlZm9yZUNvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVJZFRvVXNlID0gZ2V0VG9wTGV2ZWxDb2RlYmFzZUlkRm9yQ29tcG9uZW50KGNhc3RDaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcy5iZWZvcmVDb2RlYmFzZUlkKSB8fCBjYXN0Q2hhbmdlSXRlbS5jaGFuZ2VGaWVsZHMuYmVmb3JlQ29kZWJhc2VJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVFbGVtZW50ID0gbmV3UGFyZW50RWxlbWVudC5jaGlsZHJlbihgLiR7YmVmb3JlSWRUb1VzZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNsb25lICYmIGNsb25lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVFbGVtZW50Lmluc2VydEJlZm9yZShiZWZvcmVFbGVtZW50LmZpcnN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoYmVmb3JlRWxlbWVudC5maXJzdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZUNsb25lICYmIGNsb25lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNsb25lRWxlbWVudC5hcHBlbmRUbyhuZXdQYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kVG8obmV3UGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2VJdGVtLnR5cGUgPT09IGNoYW5nZUxlZGdlclR5cGVzXzEuQ2hhbmdlVHlwZS5SRU1PVkVfSlNYKSB7XG4gICAgICAgIGNvbnN0IGNhc3RDaGFuZ2VJdGVtID0gY2hhbmdlSXRlbTtcbiAgICAgICAgY29uc3QgcGFyZW50VG9FbGVtZW50S2V5c1JlbW92ZWQgPSB7fTtcbiAgICAgICAgY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLmNvZGViYXNlSWRzVG9SZW1vdmUuZm9yRWFjaCgoY29kZWJhc2VJZCkgPT4ge1xuICAgICAgICAgICAgLy8gU2VlIGlmIGRpcmVjdCBtYXRjaGVzIHdvcmsgZmlyc3RcbiAgICAgICAgICAgIGxldCBjb2RlYmFzZUlkVG9SZW1vdmU7XG4gICAgICAgICAgICBpZiAoKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtjb2RlYmFzZUlkfWApLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb2RlYmFzZUlkVG9SZW1vdmUgPSBjb2RlYmFzZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgaXQgYnkgdGhlIGNvbXBvbmVudCBJRFxuICAgICAgICAgICAgICAgIGxldCB0b3BMZXZlbENvZGViYXNlSWQgPSBnZXRUb3BMZXZlbENvZGViYXNlSWRGb3JDb21wb25lbnQoY29kZWJhc2VJZCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3BMZXZlbENvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBmaW5kIGNvbXBvbmVudCBlbGVtZW50IGZvciBpbnN0YW50IHVwZGF0ZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGViYXNlSWRUb1JlbW92ZSA9IHRvcExldmVsQ29kZWJhc2VJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGl0ZW0gdGhhdCBpcyByZW1vdmVkLCBzYXZlIHRoZSBpbm5lciBIVE1MIGluIGNhc2UgaXQgZ2V0cyBkZWxldGVkIGFuZCB3ZSB3YW50IHRvIHVuZG9cbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7Y29kZWJhc2VJZFRvUmVtb3ZlfWApLmVhY2goKGluZGV4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudEtleVJlbW92ZWQgPSAoMCwgaWRlbnRpZmllclV0aWxzXzEuZ2V0RWxlbWVudEtleUZyb21Ob2RlKShpdGVtKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50S2V5ID0gKDAsIGlkZW50aWZpZXJVdGlsc18xLmdldEVsZW1lbnRLZXlGcm9tTm9kZSkoaXRlbS5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEtleVJlbW92ZWQgJiYgcGFyZW50RWxlbWVudEtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFRvRWxlbWVudEtleXNSZW1vdmVkW3BhcmVudEVsZW1lbnRLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUb0VsZW1lbnRLZXlzUmVtb3ZlZFtwYXJlbnRFbGVtZW50S2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRvRWxlbWVudEtleXNSZW1vdmVkW3BhcmVudEVsZW1lbnRLZXldLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJIVE1MOiBpdGVtLm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRLZXlSZW1vdmVkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0RJU1BMQVlfTk9ORV9VTlRJTF9SRUZSRVNIX0NMQVNTKTtcbiAgICAgICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZShpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ET19OT1RfU0hPV19JTl9OQVZfVU5USUxfUkVGUkVTSCwgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICBzZW5kTmV3TmF2VHJlZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBleHRyYUluc3RhbnRVcGRhdGVEYXRhLnBhcmVudFRvRWxlbWVudEtleXNSZW1vdmVkID1cbiAgICAgICAgICAgIHBhcmVudFRvRWxlbWVudEtleXNSZW1vdmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2VJdGVtLnR5cGUgPT09IGNoYW5nZUxlZGdlclR5cGVzXzEuQ2hhbmdlVHlwZS5BRERfQ0xBU1MgfHxcbiAgICAgICAgY2hhbmdlSXRlbS50eXBlID09PSBjaGFuZ2VMZWRnZXJUeXBlc18xLkNoYW5nZVR5cGUuU1RZTElORykge1xuICAgICAgICBsZXQgY2xhc3NOYW1lLCBjc3NFcXVpdmFsZW50LCBjb2RlYmFzZUlkVG9BZGRDbGFzcywgdGVtcG9yYXJ5Q2xhc3MsIGNvZGViYXNlQ2xhc3NOYW1lLCBtb2RpZmllcnM7XG4gICAgICAgIGlmIChjaGFuZ2VJdGVtLnR5cGUgPT09IGNoYW5nZUxlZGdlclR5cGVzXzEuQ2hhbmdlVHlwZS5BRERfQ0xBU1MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhc3RDaGFuZ2VJdGVtID0gY2hhbmdlSXRlbTtcbiAgICAgICAgICAgIGNvZGViYXNlQ2xhc3NOYW1lID0gY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNhc3RDaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcy5jbGFzc05hbWU7XG4gICAgICAgICAgICBjc3NFcXVpdmFsZW50ID0gY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLmNzc0VxdWl2YWxlbnQ7XG4gICAgICAgICAgICBjb2RlYmFzZUlkVG9BZGRDbGFzcyA9IGNhc3RDaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9BZGRDbGFzcztcbiAgICAgICAgICAgIHRlbXBvcmFyeUNsYXNzID0gY2FzdENoYW5nZUl0ZW0uY2hhbmdlRmllbGRzLnRlbXBvcmFyeU9ubHk7XG4gICAgICAgICAgICBtb2RpZmllcnMgPSBjYXN0Q2hhbmdlSXRlbS5jaGFuZ2VGaWVsZHMubW9kaWZpZXJzO1xuICAgICAgICAgICAgaWYgKHRlbXBvcmFyeUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gZXhwb3J0cy5URU1QT1JBUllfU1RZTElOR19DTEFTU19OQU1FO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXMgb2YgTWFyY2ggNiwgMjAyNCB3ZSBvbmx5IHN1cHBvcnQgdGFpbHdpbmQgU1RZTElORyBjaGFuZ2VzLCBzbyB0cmVhdCB0aGVtIGFzIGFkZGluZyBhIGNsYXNzXG4gICAgICAgICAgICBjb25zdCBjYXN0Q2hhbmdlSXRlbSA9IGNoYW5nZUl0ZW0uY2hhbmdlRmllbGRzO1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gJyc7XG4gICAgICAgICAgICBjc3NFcXVpdmFsZW50ID0gT2JqZWN0LmtleXMoY2FzdENoYW5nZUl0ZW0uc3R5bGluZ0NoYW5nZXMpXG4gICAgICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhc3RDaGFuZ2VJdGVtLnN0eWxpbmdDaGFuZ2VzW2tleV0gPT09IGNvbnN0YW50c0FuZFR5cGVzXzEuREVMRVRFX1NUWUxFX0NPTlNUQU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHsoMCwgY3NzUnVsZVV0aWxzXzEuY2FtZWxUb1NuYWtlQ2FzZSkoa2V5KX06IHVuc2V0ICFpbXBvcnRhbnQ7YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAkeygwLCBjc3NSdWxlVXRpbHNfMS5jYW1lbFRvU25ha2VDYXNlKShrZXkpfTogJHtjYXN0Q2hhbmdlSXRlbS5zdHlsaW5nQ2hhbmdlc1trZXldfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBjb2RlYmFzZUlkVG9BZGRDbGFzcyA9IGNhc3RDaGFuZ2VJdGVtLmNvZGViYXNlSWQ7XG4gICAgICAgICAgICBtb2RpZmllcnMgPSBjYXN0Q2hhbmdlSXRlbS5tb2RpZmllcnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgU0FGRV9DTEFTU05BTUVfUkVHRVggPSAvW15BLVphLXowLTlfLV0vZztcbiAgICAgICAgLy8gRXNjYXBlIGFueSBjdXN0b20gY2xhc3Nlc1xuICAgICAgICBsZXQgY2xhc3NUb0FkZCA9IChjbGFzc05hbWUgfHwgJycpXG4gICAgICAgICAgICAucmVwbGFjZShTQUZFX0NMQVNTTkFNRV9SRUdFWCwgJy0nKSAvLyBSZXBsYWNlIGFueSBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgd2l0aCAnLSdcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxkLywgJy0kJicpOyAvLyBJZiB0aGUgY2xhc3Mgc3RhcnRzIHdpdGggYSBkaWdpdCwgcHJlcGVuZCB3aXRoICctJ1xuICAgICAgICAvLyBJbnN0ZWFkIG9mIGFkZGluZyB0aGUgY2xhc3MgbmFtZSwgZ2VuZXJhdGUgYSBuZXcgY2xhc3MgYW5kIHNldCB0aGVcbiAgICAgICAgLy8gY3NzIGVxdWl2YWxlbnQgdmFsdWVzIGluc2lkZSBpdFxuICAgICAgICAvLyBUaGlzIGNsYXNzIHdpbGwgYmUgZGVsZXRlZCBhZnRlciBhIGhvdCByZWxvYWRcbiAgICAgICAgLy8gTm90ZSAtIGZvciB0ZW1wb3JhcnkgY2xhc3NlcyB3ZSB3YW50IHRvIGV4cGxpY2l0bHkgdXNlIHRoZSBzYW1lIGNsYXNzXG4gICAgICAgIGlmIChjc3NFcXVpdmFsZW50ICYmICF0ZW1wb3JhcnlDbGFzcykge1xuICAgICAgICAgICAgY29uc3QgbXNTaW5jZUphbjEgPSBEYXRlLm5vdygpIC0gMTcwNDA2NzIwMDAwMDtcbiAgICAgICAgICAgIGNsYXNzVG9BZGQgPSBgJHtpZGVudGlmaWVyVXRpbHNfMS5URU1QT19JTlNUQU5UX1VQREFURV9TVFlMSU5HX1BSRUZJWH0ke21zU2luY2VKYW4xfS0ke2NsYXNzVG9BZGR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NUb0FkZCkge1xuICAgICAgICAgICAgaWYgKCF0ZW1wb3JhcnlDbGFzcykge1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0ZW1wb3JhcnkgY2xhc3Mgb24gdGhpcyBlbGVtZW50IGlmIGl0IGhhcyBpdFxuICAgICAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7Y29kZWJhc2VJZFRvQWRkQ2xhc3N9YCkucmVtb3ZlQ2xhc3MoZXhwb3J0cy5URU1QT1JBUllfU1RZTElOR19DTEFTU19OQU1FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjc3NFcXVpdmFsZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBDU1NfUFNFVURPX01PRElGSUVSUyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdob3ZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVxdWlyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvY3VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHNldWRvTW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigobW9kaWZpZXIpID0+IENTU19QU0VVRE9fTU9ESUZJRVJTLmluY2x1ZGVzKG1vZGlmaWVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBzZXVkb01vZGlmaWVyc1N1ZmZpeCA9IHBzZXVkb01vZGlmaWVycy5qb2luKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwc2V1ZG9Nb2RpZmllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZXJDbGFzcyA9IGAke2NsYXNzVG9BZGR9OiR7cHNldWRvTW9kaWZpZXJzU3VmZml4fWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPckVkaXRDU1NSdWxlKGAuJHttb2RpZmllckNsYXNzfWAsIGNzc0VxdWl2YWxlbnQsIG1vZGlmaWVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3JFZGl0Q1NTUnVsZShgLiR7Y2xhc3NUb0FkZH1gLCBjc3NFcXVpdmFsZW50LCBjbGFzc1RvQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JjZUNsYXNzZXMgPSBtb2RpZmllcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKG1vZGlmaWVyKSA9PiBgLnRlbXBvLWZvcmNlLSR7bW9kaWZpZXJ9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFudFVwZGF0ZUZvckZvcmNlQ2xhc3MgPSBgJHtjbGFzc1RvQWRkfSR7Zm9yY2VDbGFzc2VzfWA7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9yRWRpdENTU1J1bGUoYC4ke2luc3RhbnRVcGRhdGVGb3JGb3JjZUNsYXNzfWAsIGNzc0VxdWl2YWxlbnQsIGluc3RhbnRVcGRhdGVGb3JGb3JjZUNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9yRWRpdENTU1J1bGUoYC4ke2NsYXNzVG9BZGR9YCwgY3NzRXF1aXZhbGVudCwgY2xhc3NUb0FkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VycmVudEFkZENsYXNzVmFsdWVzID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoZXhwb3J0cy5BRERfQ0xBU1NfSU5TVEFOVF9VUERBVEVfUVVFVUUpIHx8IFtdO1xuICAgICAgICAgICAgLy8gU2VlIGlmIGRpcmVjdCBtYXRjaGVzIHdvcmsgZmlyc3RcbiAgICAgICAgICAgIGlmICgoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2NvZGViYXNlSWRUb0FkZENsYXNzfWApLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2NvZGViYXNlSWRUb0FkZENsYXNzfWApLmFkZENsYXNzKGNsYXNzVG9BZGQpO1xuICAgICAgICAgICAgICAgIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QWRkQ2xhc3NWYWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGViYXNlSWQ6IGNvZGViYXNlSWRUb0FkZENsYXNzLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzVG9BZGQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBpdCBieSB0aGUgY29tcG9uZW50IElEXG4gICAgICAgICAgICAgICAgbGV0IHRvcExldmVsQ29kZWJhc2VJZCA9IGdldFRvcExldmVsQ29kZWJhc2VJZEZvckNvbXBvbmVudChjb2RlYmFzZUlkVG9BZGRDbGFzcyB8fCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRvcExldmVsQ29kZWJhc2VJZCAmJiAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke3RvcExldmVsQ29kZWJhc2VJZH1gKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHt0b3BMZXZlbENvZGViYXNlSWR9YCkuYWRkQ2xhc3MoY2xhc3NUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBZGRDbGFzc1ZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGViYXNlSWQ6IHRvcExldmVsQ29kZWJhc2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NUb0FkZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoZXhwb3J0cy5BRERfQ0xBU1NfSU5TVEFOVF9VUERBVEVfUVVFVUUsIGN1cnJlbnRBZGRDbGFzc1ZhbHVlcyk7XG4gICAgICAgICAgICBleHRyYUluc3RhbnRVcGRhdGVEYXRhLmFkZGVkQ2xhc3MgPSBjbGFzc1RvQWRkO1xuICAgICAgICAgICAgZXh0cmFJbnN0YW50VXBkYXRlRGF0YS5jb2RlYmFzZUFkZGVkQ2xhc3MgPSBjb2RlYmFzZUNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2VJdGVtLnR5cGUgPT09IGNoYW5nZUxlZGdlclR5cGVzXzEuQ2hhbmdlVHlwZS5SRU1PVkVfQ0xBU1MpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlQ2xhc3NDaGFuZ2VGaWVsZHMgPSBjaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcztcbiAgICAgICAgLy8gU2VlIGlmIGRpcmVjdCBtYXRjaGVzIHdvcmsgZmlyc3RcbiAgICAgICAgaWYgKCgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7cmVtb3ZlQ2xhc3NDaGFuZ2VGaWVsZHMuY29kZWJhc2VJZFRvUmVtb3ZlQ2xhc3N9YCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtyZW1vdmVDbGFzc0NoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9SZW1vdmVDbGFzc31gKS5yZW1vdmVDbGFzcyhyZW1vdmVDbGFzc0NoYW5nZUZpZWxkcy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgaXQgYnkgdGhlIGNvbXBvbmVudCBJRFxuICAgICAgICAgICAgbGV0IHRvcExldmVsQ29kZWJhc2VJZCA9IGdldFRvcExldmVsQ29kZWJhc2VJZEZvckNvbXBvbmVudChyZW1vdmVDbGFzc0NoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9SZW1vdmVDbGFzcyB8fCAnJyk7XG4gICAgICAgICAgICBpZiAodG9wTGV2ZWxDb2RlYmFzZUlkICYmICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7dG9wTGV2ZWxDb2RlYmFzZUlkfWApLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHt0b3BMZXZlbENvZGViYXNlSWR9YCkucmVtb3ZlQ2xhc3MocmVtb3ZlQ2xhc3NDaGFuZ2VGaWVsZHMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2VJdGVtLnR5cGUgPT09IGNoYW5nZUxlZGdlclR5cGVzXzEuQ2hhbmdlVHlwZS5XUkFQX0RJVikge1xuICAgICAgICBjb25zdCBjaGFuZ2VGaWVsZHMgPSBjaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcztcbiAgICAgICAgY29uc3QgY29kZWJhc2VJZHNUb1dyYXAgPSBjaGFuZ2VGaWVsZHMuY29kZWJhc2VJZHNUb1dyYXA7XG4gICAgICAgIGNvbnN0IGZpcnN0Q29kZWJhc2VJZCA9IGNvZGViYXNlSWRzVG9XcmFwWzBdO1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhlIG90aGVyIGNvZGViYXNlIElEcyBhcmUgc2libGluZ3Mgb2YgdGhpcyBjb2RlYmFzZSBJRCwgc28gd2VcbiAgICAgICAgLy8gZmluZCBlYWNoIGluc3RhbmNlIG9mIHRoZSBmaXJzdCBvbmUgYW5kIGluY2x1ZGUgdGhlIG90aGVyIGl0ZW1zIHRoYXQgbWF0Y2ggaW4gaXRcbiAgICAgICAgLy8gSWYgdGhlIG90aGVyIGl0ZW1zIGFyZW4ndCBhbGwgZm91bmQsIHdlIGRvIG5vdCB3cmFwIGFuZCBsZXQgaG90IHJlbG9hZCBoYW5kbGUgaXRcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtmaXJzdENvZGViYXNlSWR9YCkuZWFjaCgoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyQ29kZWJhc2VJZHMgPSBjb2RlYmFzZUlkc1RvV3JhcC5zbGljZSgxKTtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGNvZGViYXNlIElEIGluIG90aGVyQ29kZWJhc2VJZHMsIHJldHJpZXZlIHRoZSBlbGVtZW50IHRoYXQgaXMgYSBzaWJsaW5nIG9mIGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdzID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGl0ZW0pLnNpYmxpbmdzKCk7XG4gICAgICAgICAgICBjb25zdCBhbGxJdGVtc1RvQWRkVG9OZXdEaXYgPSBbaXRlbV07XG4gICAgICAgICAgICBsZXQgZWFybGllc3RJdGVtID0gaXRlbTtcbiAgICAgICAgICAgIGxldCBlYXJsaWVzdEluZGV4ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGl0ZW0pLmluZGV4KCk7XG4gICAgICAgICAgICBvdGhlckNvZGViYXNlSWRzLmZvckVhY2goKGNvZGViYXNlSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZFNpYmxpbmcgPSBzaWJsaW5ncy5maWx0ZXIoYC4ke2NvZGViYXNlSWR9YCkuZ2V0KDApO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsSXRlbXNUb0FkZFRvTmV3RGl2LnB1c2goZm91bmRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoZm91bmRTaWJsaW5nKS5pbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlYXJsaWVzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlYXJsaWVzdEl0ZW0gPSBmb3VuZFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBlYXJsaWVzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gaWYgdGhleSBhbGwgY2FuJ3QgYmUgZm91bmQ/XG4gICAgICAgICAgICBpZiAoYWxsSXRlbXNUb0FkZFRvTmV3RGl2Lmxlbmd0aCAhPT0gY29kZWJhc2VJZHNUb1dyYXAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdywganVzdCBhZGQgdGhlIG9uZXMgdGhhdCB3ZXJlIGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBkaXYgd2l0aCBhIGNsb25lIG9mIHRoZSBpdGVtLCB3aGlsZSBoaWRpbmcgdGhlIGl0ZW1cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGhvdCByZWxvYWQgaGFwcGVucyB0aGUgY2xvbmUgZ2V0cyBkZWxldGVkIGFuZCB0aGUgaXRlbSBpcyBzaG93biBhZ2FpblxuICAgICAgICAgICAgY29uc3QgbmV3RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBuZXdEaXYuY2xhc3NOYW1lID0gZXhwb3J0cy5XUkFQX0lOX0RJVl9QTEFDRUhPTERFUl9DT0RFQkFTRV9JRDtcbiAgICAgICAgICAgIG5ld0Rpdi5zZXRBdHRyaWJ1dGUoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7IC8vIFNvIHRoYXQgdGhlIERPTSB0cmVlIHJlZnJlc2ggZG9lc24ndCBnZXQgdHJpZ2dlcmVkXG4gICAgICAgICAgICBuZXdEaXYuc2V0QXR0cmlidXRlKCd0ZW1wb2VsZW1lbnRpZCcsIGV4cG9ydHMuV1JBUF9JTl9ESVZfUExBQ0VIT0xERVJfQ09ERUJBU0VfSUQpO1xuICAgICAgICAgICAgbmV3RGl2LnNldEF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnLCBleHBvcnRzLldSQVBfSU5fRElWX1BMQUNFSE9MREVSX0NPREVCQVNFX0lEKTtcbiAgICAgICAgICAgIG5ld0Rpdi5zZXRBdHRyaWJ1dGUoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fREVMRVRFX0FGVEVSX1JFRlJFU0gsICd0cnVlJyk7XG4gICAgICAgICAgICBhbGxJdGVtc1RvQWRkVG9OZXdEaXYuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgICAgICAgICAgIG5ld0Rpdi5hcHBlbmRDaGlsZChlbGVtLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0RJU1BMQVlfTk9ORV9VTlRJTF9SRUZSRVNIX0NMQVNTKTtcbiAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ET19OT1RfU0hPV19JTl9OQVZfVU5USUxfUkVGUkVTSCwgJ3RydWUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgZGl2IHJpZ2h0IGJlZm9yZSB0aGUgZmlyc3QgaXRlbVxuICAgICAgICAgICAgZWFybGllc3RJdGVtLmluc2VydEFkamFjZW50RWxlbWVudCgnYmVmb3JlYmVnaW4nLCBuZXdEaXYpO1xuICAgICAgICAgICAgc2VuZE5ld05hdlRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlSXRlbS50eXBlID09PSBjaGFuZ2VMZWRnZXJUeXBlc18xLkNoYW5nZVR5cGUuRFVQTElDQVRFKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZUZpbGVkcyA9IGNoYW5nZUl0ZW0uY2hhbmdlRmllbGRzO1xuICAgICAgICBjb25zdCBjb2RlYmFzZUlkc1RvRHVwbGljYXRlID0gY2hhbmdlRmlsZWRzLmNvZGViYXNlSWRzVG9EdXBsaWNhdGU7XG4gICAgICAgIGNvZGViYXNlSWRzVG9EdXBsaWNhdGUuZm9yRWFjaCgoY29kZWJhc2VJZFRvRHVwbGljYXRlKSA9PiB7XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2NvZGViYXNlSWRUb0R1cGxpY2F0ZX1gKS5lYWNoKChpbmRleCwgaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSBpdGVtLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBjbG9uZWROb2RlLnNldEF0dHJpYnV0ZShpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ERUxFVEVfQUZURVJfUkVGUkVTSCwgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICBjbG9uZWROb2RlLnNldEF0dHJpYnV0ZShpZGVudGlmaWVyVXRpbHNfMS5URU1QT19JTlNUQU5UX1VQREFURSwgJ3RydWUnKTsgLy8gU28gdGhhdCB0aGUgRE9NIHRyZWUgcmVmcmVzaCBkb2Vzbid0IGdldCB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAgICAvLyBTZXQgdXAgYWxsIHRoZSBjb3JyZWN0IGR1cGxpY2F0ZWQgY29kZWJhc2UgSURzXG4gICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5zZXRBdHRyaWJ1dGUoJ3RlbXBvZWxlbWVudGlkJywgYCR7ZXhwb3J0cy5EVVBMSUNBVEVfUExBQ0VIT0xERVJfUFJFRklYfSR7Y29kZWJhc2VJZFRvRHVwbGljYXRlfWApO1xuICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXRlc3RpZCcsIGAke2V4cG9ydHMuRFVQTElDQVRFX1BMQUNFSE9MREVSX1BSRUZJWH0ke2NvZGViYXNlSWRUb0R1cGxpY2F0ZX1gKTtcbiAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmNsYXNzTGlzdC5hZGQoZXhwb3J0cy5EVVBMSUNBVEVfUExBQ0VIT0xERVJfUFJFRklYICsgY29kZWJhc2VJZFRvRHVwbGljYXRlKTtcbiAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmNsYXNzTGlzdC5yZW1vdmUoY29kZWJhc2VJZFRvRHVwbGljYXRlKTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGNsb25lZE5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZWJhc2VJZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSgndGVtcG9lbGVtZW50aWQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZ2V0QXR0cmlidXRlKCdkYXRhLXRlc3RpZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgndGVtcG9lbGVtZW50aWQnLCBgJHtleHBvcnRzLkRVUExJQ0FURV9QTEFDRUhPTERFUl9QUkVGSVh9JHtjb2RlYmFzZUlkfWApO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGVzdGlkJywgYCR7ZXhwb3J0cy5EVVBMSUNBVEVfUExBQ0VIT0xERVJfUFJFRklYfSR7Y29kZWJhc2VJZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY2xhc3NMaXN0LnJlbW92ZShjb2RlYmFzZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY2xhc3NMaXN0LmFkZChleHBvcnRzLkRVUExJQ0FURV9QTEFDRUhPTERFUl9QUkVGSVggKyBjb2RlYmFzZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0lOU1RBTlRfVVBEQVRFLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKC4uLkFycmF5LmZyb20oY2hpbGQuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjbG9uZXMgbm9kZSByaWdodCBhZnRlciB0aGUgZm91bmQgbm9kZVxuICAgICAgICAgICAgICAgIGl0ZW0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGNsb25lZE5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbmROZXdOYXZUcmVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5nZUl0ZW0udHlwZSA9PT0gY2hhbmdlTGVkZ2VyVHlwZXNfMS5DaGFuZ2VUeXBlLkNIQU5HRV9UQUcpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlRmllbGRzID0gY2hhbmdlSXRlbS5jaGFuZ2VGaWVsZHM7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7Y2hhbmdlRmllbGRzLmNvZGViYXNlSWRUb0NoYW5nZX1gKS5lYWNoKChpbmRleCwgaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgJG5ld0VsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoJzwnICsgY2hhbmdlRmllbGRzLm5ld1RhZ05hbWUgKyAnPjwvJyArIGNoYW5nZUZpZWxkcy5uZXdUYWdOYW1lICsgJz4nKTtcbiAgICAgICAgICAgICRuZXdFbGVtZW50LmF0dHIoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7IC8vIFNvIHRoYXQgdGhlIERPTSB0cmVlIHJlZnJlc2ggZG9lc24ndCBnZXQgdHJpZ2dlcmVkXG4gICAgICAgICAgICAkbmV3RWxlbWVudC5hdHRyKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0RFTEVURV9BRlRFUl9SRUZSRVNILCAndHJ1ZScpO1xuICAgICAgICAgICAgY29uc3QgJGl0ZW0gPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoaXRlbSk7XG4gICAgICAgICAgICAvLyBDb3B5IGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIG9yaWdpbmFsIGVsZW1lbnQgdG8gdGhlIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBqcXVlcnlfMS5kZWZhdWx0LmVhY2goJGl0ZW1bMF0uYXR0cmlidXRlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRuZXdFbGVtZW50LmF0dHIodGhpcy5uYW1lLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGl0ZW0uY29udGVudHMoKS5jbG9uZSh0cnVlLCB0cnVlKS5hcHBlbmRUbygkbmV3RWxlbWVudCk7XG4gICAgICAgICAgICAvLyBBZGQgcmlnaHQgYmVmb3JlIHRoZSBjbG9uZWQgaXRlbSBzbyB0aGUgdW5pcXVlIHBhdGggc3RheXMgdGhlIHNhbWVcbiAgICAgICAgICAgICRpdGVtLmJlZm9yZSgkbmV3RWxlbWVudCk7XG4gICAgICAgICAgICAvLyBIaWRlIHRoZSBvcmlnaW5hbCBpdGVtXG4gICAgICAgICAgICAkaXRlbS5hZGRDbGFzcyhpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ESVNQTEFZX05PTkVfVU5USUxfUkVGUkVTSF9DTEFTUyk7XG4gICAgICAgICAgICAkaXRlbS5hdHRyKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0RPX05PVF9TSE9XX0lOX05BVl9VTlRJTF9SRUZSRVNILCAndHJ1ZScpO1xuICAgICAgICAgICAgc2VuZE5ld05hdlRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlSXRlbS50eXBlID09PSBjaGFuZ2VMZWRnZXJUeXBlc18xLkNoYW5nZVR5cGUuVU5ETykge1xuICAgICAgICBjb25zdCB7IHNlbmROZXdOYXZUcmVlOiBfc2VuZE5ld05hdlRyZWUsIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsOiBfaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwsIH0gPSBhcHBseVVuZG9DaGFuZ2VJdGVtVG9Eb2N1bWVudChwYXJlbnRQb3J0LCBjaGFuZ2VJdGVtKTtcbiAgICAgICAgc2VuZE5ld05hdlRyZWUgPSBfc2VuZE5ld05hdlRyZWU7XG4gICAgICAgIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsID0gX2luc3RhbnRVcGRhdGVTdWNjZXNzZnVsO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2VJdGVtLnR5cGUgPT09IGNoYW5nZUxlZGdlclR5cGVzXzEuQ2hhbmdlVHlwZS5SRURPKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZUZpZWxkcyA9IGNoYW5nZUl0ZW0uY2hhbmdlRmllbGRzO1xuICAgICAgICBjb25zdCBjaGFuZ2VUb1JlZG8gPSBjaGFuZ2VGaWVsZHMuY2hhbmdlVG9SZWRvO1xuICAgICAgICBpZiAoY2hhbmdlTGVkZ2VyVHlwZXNfMS5DSEFOR0VfVFlQRVNfV0lUSF9JTlNUQU5UX1VORE8uaW5jbHVkZXMoY2hhbmdlVG9SZWRvLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbmROZXdOYXZUcmVlOiBfc2VuZE5ld05hdlRyZWUsIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsOiBfaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwsIH0gPSAoMCwgZXhwb3J0cy5hcHBseUNoYW5nZUl0ZW1Ub0RvY3VtZW50KShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQsIGNoYW5nZVRvUmVkbyk7XG4gICAgICAgICAgICBzZW5kTmV3TmF2VHJlZSA9IF9zZW5kTmV3TmF2VHJlZTtcbiAgICAgICAgICAgIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsID0gX2luc3RhbnRVcGRhdGVTdWNjZXNzZnVsO1xuICAgICAgICAgICAgaWYgKGNoYW5nZVRvUmVkby5wcmV2SWRUb05ld0lkTWFwKSB7XG4gICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMudXBkYXRlQ29kZWJhc2VJZHMpKHBhcmVudFBvcnQsIGNoYW5nZVRvUmVkby5wcmV2SWRUb05ld0lkTWFwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbW1lZGlhdGVseSBzZXQgdGhlIG5ldyBzZWxlY3RlZCBlbGVtZW50IGtleXMgdG8gcHJldmVudCBhbnkgZGVsYXkgaW4gdGhlIG91dGxpbmVzIHVwZGF0aW5nXG4gICAgbGV0IGVsZW1lbnRLZXlUb1NlbGVjdEFmdGVySW5zdGFudFVwZGF0ZSA9IGNoYW5nZUl0ZW0uZ2V0RWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlKCk7XG4gICAgbGV0IGVsZW1lbnRLZXlzVG9NdWx0aXNlbGVjdEFmdGVySW5zdGFudFVwZGF0ZSA9IGNoYW5nZUl0ZW0uZ2V0RWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlKCk7XG4gICAgaWYgKGNoYW5nZUl0ZW0udHlwZSA9PT0gY2hhbmdlTGVkZ2VyVHlwZXNfMS5DaGFuZ2VUeXBlLlVORE8pIHtcbiAgICAgICAgZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlID0gY2hhbmdlSXRlbS5jaGFuZ2VGaWVsZHMuY2hhbmdlVG9VbmRvLmdldEVsZW1lbnRLZXlUb1NlbGVjdEFmdGVyVW5kb0luc3RhbnRVcGRhdGUoKTtcbiAgICAgICAgZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlID0gY2hhbmdlSXRlbS5jaGFuZ2VGaWVsZHMuY2hhbmdlVG9VbmRvLmdldEVsZW1lbnRLZXlzVG9NdWx0aXNlbGVjdEFmdGVyVW5kb0luc3RhbnRVcGRhdGUoKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRLZXlUb1NlbGVjdEFmdGVySW5zdGFudFVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5TRUxFQ1RFRF9FTEVNRU5UX0tFWSwgZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlKTtcbiAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgICBlbGVtZW50S2V5OiBlbGVtZW50S2V5VG9TZWxlY3RBZnRlckluc3RhbnRVcGRhdGUsXG4gICAgICAgICAgICBvdXRlckhUTUw6IChfYSA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7ZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlfWApLmdldCgwKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm91dGVySFRNTCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50S2V5c1RvTXVsdGlzZWxlY3RBZnRlckluc3RhbnRVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLCBlbGVtZW50S2V5c1RvTXVsdGlzZWxlY3RBZnRlckluc3RhbnRVcGRhdGUpO1xuICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMsXG4gICAgICAgICAgICBlbGVtZW50S2V5czogZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlLFxuICAgICAgICAgICAgb3V0ZXJIVE1MczogZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlID09PSBudWxsIHx8IGVsZW1lbnRLZXlzVG9NdWx0aXNlbGVjdEFmdGVySW5zdGFudFVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlLm1hcCgoZWxlbWVudEtleSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke2VsZW1lbnRLZXl9YCkuZ2V0KDApKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3V0ZXJIVE1MOyB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bCkge1xuICAgICAgICAvLyBEZWxldGUgYW55IGVsZW1lbnRzIHRoYXQgbmVlZCB0byBiZSBkZWxldGVkIGFmdGVyIGluc3RhbnQgdXBkYXRlc1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYCpbJHtpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ERUxFVEVfQUZURVJfSU5TVEFOVF9VUERBVEV9PXRydWVdYCkucmVtb3ZlKCk7XG4gICAgfVxuICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuSU5TVEFOVF9VUERBVEVfRE9ORSxcbiAgICAgICAgY2hhbmdlSXRlbTogcGxhaW5DaGFuZ2VJdGVtLFxuICAgICAgICBpbnN0YW50VXBkYXRlRGF0YTogZXh0cmFJbnN0YW50VXBkYXRlRGF0YSxcbiAgICAgICAgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwsXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc2VuZE5ld05hdlRyZWUsIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsIH07XG59O1xuZXhwb3J0cy5hcHBseUNoYW5nZUl0ZW1Ub0RvY3VtZW50ID0gYXBwbHlDaGFuZ2VJdGVtVG9Eb2N1bWVudDtcbmNvbnN0IGFwcGx5VW5kb0NoYW5nZUl0ZW1Ub0RvY3VtZW50ID0gKHBhcmVudFBvcnQsIGNoYW5nZUl0ZW0pID0+IHtcbiAgICBjb25zdCBjaGFuZ2VGaWVsZHMgPSBjaGFuZ2VJdGVtLmNoYW5nZUZpZWxkcztcbiAgICBjb25zdCBjaGFuZ2VUb1VuZG8gPSBjaGFuZ2VGaWVsZHMuY2hhbmdlVG9VbmRvO1xuICAgIGlmICghY2hhbmdlTGVkZ2VyVHlwZXNfMS5DSEFOR0VfVFlQRVNfV0lUSF9JTlNUQU5UX1VORE8uaW5jbHVkZXMoY2hhbmdlVG9VbmRvLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiB7IHNlbmROZXdOYXZUcmVlOiBmYWxzZSwgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWw6IGZhbHNlIH07XG4gICAgfVxuICAgIGxldCBzZW5kTmV3TmF2VHJlZSA9IGZhbHNlO1xuICAgIGxldCBpbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgIC8vIEFQSSBoYXMgY29tcGxldGVkIGFuZCB0aGUgSURzIGhhdmUgYmVlbiB1cGRhdGVkLCByZXZlcnNlIHRoaXMgY2hhbmdlXG4gICAgaWYgKGNoYW5nZVRvVW5kby5wcmV2SWRUb05ld0lkTWFwKSB7XG4gICAgICAgIGNvbnN0IHVuZG9Db2RlYmFzZUlkQ2hhbmdlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhjaGFuZ2VUb1VuZG8ucHJldklkVG9OZXdJZE1hcCkuZm9yRWFjaCgocHJldklkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJZCA9IGNoYW5nZVRvVW5kby5wcmV2SWRUb05ld0lkTWFwW3ByZXZJZF07XG4gICAgICAgICAgICB1bmRvQ29kZWJhc2VJZENoYW5nZXNbbmV3SWRdID0gcHJldklkO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdW5kb2luZyBkbyBub3QgdXBkYXRlIHRoZSBjb2RlYmFzZSBJRHMgYmFja3dhcmRzIGlmIHRoZXJlIGFyZSBjb2RlYmFzZSBJRHMgdG8gc2V0IGFmdGVyXG4gICAgICAgIC8vIHRoZSB1bmRvIGluc3RhbnQgdXBkYXRlIGlzIGRvbmVcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50U3BlY2lmaWVkQWZ0ZXJVbmRvID0gY2hhbmdlVG9VbmRvLmdldEVsZW1lbnRLZXlUb1NlbGVjdEFmdGVyVW5kb0luc3RhbnRVcGRhdGUoKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAoMCwgZXhwb3J0cy51cGRhdGVDb2RlYmFzZUlkcykocGFyZW50UG9ydCwgdW5kb0NvZGViYXNlSWRDaGFuZ2VzLCAhc2VsZWN0ZWRFbGVtZW50U3BlY2lmaWVkQWZ0ZXJVbmRvKTtcbiAgICB9XG4gICAgLy8gVGhlbiB1bmRvIHRoZSBhY3R1YWwgY2hhbmdlXG4gICAgaWYgKGNoYW5nZVRvVW5kby50eXBlID09PSBjaGFuZ2VMZWRnZXJUeXBlc18xLkNoYW5nZVR5cGUuUkVNT1ZFX0pTWCkge1xuICAgICAgICAvLyBSZS1hZGQgdGhlIHJlbW92ZWQgSlNYXG4gICAgICAgIGNvbnN0IGlubmVyQ2hhbmdlRmllbGRzID0gY2hhbmdlVG9VbmRvLmNoYW5nZUZpZWxkcztcbiAgICAgICAgY29uc3QgY29kZWJhc2VJZHNUb1JlYWRkID0gaW5uZXJDaGFuZ2VGaWVsZHMuY29kZWJhc2VJZHNUb1JlbW92ZTtcbiAgICAgICAgLy8gSWYgaXQgaGFzIGJlZW4gZmx1c2hlZCwgcmUtY3JlYXRlIHRoZSBodG1sIGVsZW1lbnRzIGZyb20gdGhlIHNhdmVkIGlubmVyIEhUTUxcbiAgICAgICAgaWYgKGNoYW5nZUZpZWxkcy5tYXRjaGluZ0FjdGl2aXR5Rmx1c2hlZCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFudFVwZGF0ZURhdGEgPSBjaGFuZ2VUb1VuZG8uZ2V0SW5zdGFudFVwZGF0ZURhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFRvRWxlbWVudEtleXNSZW1vdmVkID0gaW5zdGFudFVwZGF0ZURhdGEucGFyZW50VG9FbGVtZW50S2V5c1JlbW92ZWQgfHwge307XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhwYXJlbnRUb0VsZW1lbnRLZXlzUmVtb3ZlZCkuZm9yRWFjaCgoW3BhcmVudEVsZW1lbnRLZXksIGl0ZW1zUmVtb3ZlZF0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTb3J0IHRoZSByZW1vdmVkIGVudHJpZXMgaW4gb3JkZXIgb2YgdW5pcXVlIHBhdGhcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJdGVtc1JlbW92ZWQgPSBPYmplY3QudmFsdWVzKGl0ZW1zUmVtb3ZlZCkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhRWxlbWVudEtleSA9IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5mcm9tS2V5KGEuZWxlbWVudEtleVJlbW92ZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiRWxlbWVudEtleSA9IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5mcm9tS2V5KGIuZWxlbWVudEtleVJlbW92ZWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYUVsZW1lbnRLZXkudW5pcXVlUGF0aC5sb2NhbGVDb21wYXJlKGJFbGVtZW50S2V5LnVuaXF1ZVBhdGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7cGFyZW50RWxlbWVudEtleX1gKS5nZXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSByZW1vdmVkIGVsZW1lbnRzIGJhY2sgaW4gb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkSXRlbXNSZW1vdmVkLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZWxlbWVudEtleVJlbW92ZWQsIG91dGVySFRNTCB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQuZnJvbUtleShlbGVtZW50S2V5UmVtb3ZlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleEluUGFyZW50ID0gTnVtYmVyKGVsZW1lbnQudW5pcXVlUGF0aC5zcGxpdCgnLScpLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VsZW1lbnRGcm9tSHRtbCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShvdXRlckhUTUwpLmdldCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgcGFyZW50IGluIHRoZSBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0VsZW1lbnRGcm9tSHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRGcm9tSHRtbC5zZXRBdHRyaWJ1dGUoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fREVMRVRFX0FGVEVSX1JFRlJFU0gsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RWxlbWVudEZyb21IdG1sLnNldEF0dHJpYnV0ZShpZGVudGlmaWVyVXRpbHNfMS5URU1QT19JTlNUQU5UX1VQREFURSwgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShuZXdFbGVtZW50RnJvbUh0bWwsIHBhcmVudEVsZW1lbnQuY2hpbGRyZW5baW5kZXhJblBhcmVudF0gfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmROZXdOYXZUcmVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3QgZmx1c2hlZCB5ZXQgc28gY2FuIGp1c3QgcmUtYWRkXG4gICAgICAgICAgICBjb2RlYmFzZUlkc1RvUmVhZGQuZm9yRWFjaCgoY29kZWJhc2VJZFRvUmVhZGQpID0+IHtcbiAgICAgICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2NvZGViYXNlSWRUb1JlYWRkfWApLmVhY2goKGluZGV4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZShpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ESVNQTEFZX05PTkVfVU5USUxfUkVGUkVTSF9DTEFTUyk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlQXR0cmlidXRlKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0RPX05PVF9TSE9XX0lOX05BVl9VTlRJTF9SRUZSRVNIKTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZE5ld05hdlRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2VUb1VuZG8udHlwZSA9PT0gY2hhbmdlTGVkZ2VyVHlwZXNfMS5DaGFuZ2VUeXBlLkFERF9DTEFTUyB8fFxuICAgICAgICBjaGFuZ2VUb1VuZG8udHlwZSA9PT0gY2hhbmdlTGVkZ2VyVHlwZXNfMS5DaGFuZ2VUeXBlLlNUWUxJTkcpIHtcbiAgICAgICAgY29uc3QgaW5zdGFudFVwZGF0ZURhdGEgPSBjaGFuZ2VUb1VuZG8uZ2V0SW5zdGFudFVwZGF0ZURhdGEoKTtcbiAgICAgICAgY29uc3QgaW5uZXJDaGFuZ2VGaWVsZHMgPSBjaGFuZ2VUb1VuZG8uY2hhbmdlRmllbGRzO1xuICAgICAgICBjb25zdCBhZGRlZENsYXNzID0gaW5zdGFudFVwZGF0ZURhdGEgPT09IG51bGwgfHwgaW5zdGFudFVwZGF0ZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbnRVcGRhdGVEYXRhLmFkZGVkQ2xhc3M7XG4gICAgICAgIGlmIChhZGRlZENsYXNzKSB7XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lubmVyQ2hhbmdlRmllbGRzLmNvZGViYXNlSWRUb0FkZENsYXNzfWApLmVhY2goKGluZGV4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBqcXVlcnlfMS5kZWZhdWx0KShpdGVtKS5oYXNDbGFzcyhhZGRlZENsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoaXRlbSkucmVtb3ZlQ2xhc3MoYWRkZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbnRVcGRhdGVTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlYmFzZUFkZGVkQ2xhc3MgPSBpbnN0YW50VXBkYXRlRGF0YSA9PT0gbnVsbCB8fCBpbnN0YW50VXBkYXRlRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFudFVwZGF0ZURhdGEuY29kZWJhc2VBZGRlZENsYXNzO1xuICAgICAgICBpZiAoY29kZWJhc2VBZGRlZENsYXNzKSB7XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lubmVyQ2hhbmdlRmllbGRzLmNvZGViYXNlSWRUb0FkZENsYXNzfWApLmVhY2goKGluZGV4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBqcXVlcnlfMS5kZWZhdWx0KShpdGVtKS5oYXNDbGFzcyhjb2RlYmFzZUFkZGVkQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShpdGVtKS5yZW1vdmVDbGFzcyhjb2RlYmFzZUFkZGVkQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlVG9VbmRvLnR5cGUgPT09IGNoYW5nZUxlZGdlclR5cGVzXzEuQ2hhbmdlVHlwZS5BRERfSlNYKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbnRVcGRhdGVEYXRhID0gY2hhbmdlVG9VbmRvLmdldEluc3RhbnRVcGRhdGVEYXRhKCk7XG4gICAgICAgIGNvbnN0IGFkZGVkSWRzID0gaW5zdGFudFVwZGF0ZURhdGEgPT09IG51bGwgfHwgaW5zdGFudFVwZGF0ZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbnRVcGRhdGVEYXRhLmFkZGVkSWRzO1xuICAgICAgICBhZGRlZElkcyA9PT0gbnVsbCB8fCBhZGRlZElkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRkZWRJZHMuZm9yRWFjaCgoYWRkZWRJZCkgPT4ge1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHthZGRlZElkfWApLnJlbW92ZSgpO1xuICAgICAgICAgICAgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VuZE5ld05hdlRyZWUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geyBzZW5kTmV3TmF2VHJlZSwgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgfTtcbn07XG4vKipcbiAqIEFmdGVyIGEgY2hhbmdlIGlzIHByb2Nlc3NlZCBvbiB0aGUgYmFja2VuZCwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGNvZGViYXNlIGlkcyBpbiB0aGUgZG9jdW1lbnQuXG4gKi9cbmNvbnN0IHVwZGF0ZUNvZGViYXNlSWRzID0gKHBhcmVudFBvcnQsIHByZXZJZFRvTmV3SWRNYXAsIHVwZGF0ZUVsZW1lbnRLZXlzKSA9PiB7XG4gICAgLy8gVXBkYXRlIGNvZGViYXNlIGlkcyBpbiB0aGUgZG9jdW1lbnRcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMocHJldklkVG9OZXdJZE1hcCkuZm9yRWFjaCgoW3ByZXZDb2RlYmFzZUlkLCBuZXdDb2RlYmFzZUlkXSkgPT4ge1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke3ByZXZDb2RlYmFzZUlkfWApLmVhY2goKGluZGV4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgcHJldkNvZGViYXNlSWQsXG4gICAgICAgICAgICAgICAgbmV3Q29kZWJhc2VJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBDb2RlYmFzZSBJZHMgY2FuIHN3YXAsIHNvIHdlIGhhdmUgdG8gYXBwbHkgdGhlIGNoYW5nZXMgYWZ0ZXIgbG9va2luZyBhbGwgZWxlbWVudHMgdXBcbiAgICBjaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICBjb25zdCAkaXRlbSA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShjaGFuZ2UuaXRlbSk7XG4gICAgICAgIGNvbnN0IG5ld0NsYXNzID0gKCRpdGVtLmF0dHIoJ2NsYXNzJykgfHwgJycpLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtjaGFuZ2UucHJldkNvZGViYXNlSWR9YCwgJ2cnKSwgY2hhbmdlLm5ld0NvZGViYXNlSWQpO1xuICAgICAgICAkaXRlbS5hdHRyKCdjbGFzcycsIG5ld0NsYXNzKTtcbiAgICAgICAgY2hhbmdlLml0ZW0uc2V0QXR0cmlidXRlKCd0ZW1wb2VsZW1lbnRpZCcsIGNoYW5nZS5uZXdDb2RlYmFzZUlkKTtcbiAgICAgICAgY2hhbmdlLml0ZW0uc2V0QXR0cmlidXRlKCdkYXRhLXRlc3RpZCcsIGNoYW5nZS5uZXdDb2RlYmFzZUlkKTtcbiAgICB9KTtcbiAgICBpZiAoIXVwZGF0ZUVsZW1lbnRLZXlzKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGNoYW5nZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3Qga2V5c1RvQ2hlY2sgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZLFxuICAgICAgICAgICAgbWVzc2FnZUlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuSE9WRVJFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgIG1lc3NhZ2VJZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuSE9WRVJFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIGtleXNUb0NoZWNrLmZvckVhY2goKHsga2V5LCBtZXNzYWdlSWQgfSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRLZXkgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShrZXkpO1xuICAgICAgICBjb25zdCB0ZW1wb0VsZW1lbnQgPSB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQuZnJvbUtleShlbGVtZW50S2V5KTtcbiAgICAgICAgaWYgKHByZXZJZFRvTmV3SWRNYXBbdGVtcG9FbGVtZW50LmNvZGViYXNlSWRdKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudChwcmV2SWRUb05ld0lkTWFwW3RlbXBvRWxlbWVudC5jb2RlYmFzZUlkXSwgdGVtcG9FbGVtZW50LnN0b3J5Ym9hcmRJZCwgdGVtcG9FbGVtZW50LnVuaXF1ZVBhdGgpO1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoa2V5LCBuZXdFbGVtZW50LmdldEtleSgpKTtcbiAgICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgZWxlbWVudEtleTogbmV3RWxlbWVudC5nZXRLZXkoKSxcbiAgICAgICAgICAgICAgICBvdXRlckhUTUw6IChfYSA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7bmV3RWxlbWVudC5nZXRLZXkoKX1gKS5nZXQoMCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vdXRlckhUTUwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFsc28gdXBkYXRlIHRoZSBtdWx0aXNlbGVjdGVkIGVsZW1lbnQga2V5c1xuICAgIGNvbnN0IG11bHRpc2VsZWN0ZWRFbGVtZW50S2V5cyA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMpO1xuICAgIGlmIChtdWx0aXNlbGVjdGVkRWxlbWVudEtleXMgPT09IG51bGwgfHwgbXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtdWx0aXNlbGVjdGVkRWxlbWVudEtleXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5ld011bHRpc2VsZWN0ZWRFbGVtZW50S2V5cyA9IFtdO1xuICAgICAgICBtdWx0aXNlbGVjdGVkRWxlbWVudEtleXMuZm9yRWFjaCgoZWxlbWVudEtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVtcG9FbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkoZWxlbWVudEtleSk7XG4gICAgICAgICAgICBpZiAocHJldklkVG9OZXdJZE1hcFt0ZW1wb0VsZW1lbnQuY29kZWJhc2VJZF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudChwcmV2SWRUb05ld0lkTWFwW3RlbXBvRWxlbWVudC5jb2RlYmFzZUlkXSwgdGVtcG9FbGVtZW50LnN0b3J5Ym9hcmRJZCwgdGVtcG9FbGVtZW50LnVuaXF1ZVBhdGgpO1xuICAgICAgICAgICAgICAgIG5ld011bHRpc2VsZWN0ZWRFbGVtZW50S2V5cy5wdXNoKG5ld0VsZW1lbnQuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3TXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzLnB1c2goZWxlbWVudEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLCBuZXdNdWx0aXNlbGVjdGVkRWxlbWVudEtleXMpO1xuICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMsXG4gICAgICAgICAgICBlbGVtZW50S2V5czogbmV3TXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzLFxuICAgICAgICAgICAgb3V0ZXJIVE1MczogbmV3TXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzID09PSBudWxsIHx8IG5ld011bHRpc2VsZWN0ZWRFbGVtZW50S2V5cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3TXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzLm1hcCgoZWxlbWVudEtleSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke2VsZW1lbnRLZXl9YCkuZ2V0KDApKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3V0ZXJIVE1MOyB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuKGNoYW5nZXMubGVuZ3RoKTtcbn07XG5leHBvcnRzLnVwZGF0ZUNvZGViYXNlSWRzID0gdXBkYXRlQ29kZWJhc2VJZHM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/changeItemFunctions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/changeLedgerTypes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/changeLedgerTypes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reconstructChangeLedgerClass = exports.UnknownChange = exports.RedoChange = exports.UndoChange = exports.EditTextChange = exports.RemoveClassChange = exports.AddClassChange = exports.ChangeTagChange = exports.DuplicateChange = exports.WrapDivChange = exports.ChangePropChange = exports.RemoveJsxChange = exports.MoveJsxChange = exports.AddJsxChange = exports.StylingChange = exports.ChangeLedgerItem = exports.CHANGE_TYPES_WITH_INSTANT_UNDO = exports.ChangeType = exports.StylingFramework = void 0;\nconst tempoElement_1 = __webpack_require__(/*! ./tempoElement */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\");\n// Matches the file in tempo-devtools\nvar StylingFramework;\n(function (StylingFramework) {\n    StylingFramework[\"INLINE\"] = \"Inline\";\n    StylingFramework[\"CSS\"] = \"CSS\";\n    StylingFramework[\"TAILWIND\"] = \"Tailwind\";\n})(StylingFramework || (exports.StylingFramework = StylingFramework = {}));\nvar ChangeType;\n(function (ChangeType) {\n    ChangeType[\"STYLING\"] = \"STYLING\";\n    ChangeType[\"ADD_JSX\"] = \"ADD_JSX\";\n    ChangeType[\"MOVE_JSX\"] = \"MOVE_JSX\";\n    ChangeType[\"REMOVE_JSX\"] = \"REMOVE_JSX\";\n    ChangeType[\"CHANGE_PROP\"] = \"CHANGE_PROP\";\n    ChangeType[\"ADD_CLASS\"] = \"ADD_CLASS\";\n    ChangeType[\"REMOVE_CLASS\"] = \"REMOVE_CLASS\";\n    ChangeType[\"EDIT_TEXT\"] = \"EDIT_TEXT\";\n    ChangeType[\"WRAP_DIV\"] = \"WRAP_DIV\";\n    ChangeType[\"CHANGE_TAG\"] = \"CHANGE_TAG\";\n    ChangeType[\"DUPLICATE\"] = \"DUPLICATE\";\n    ChangeType[\"UNDO\"] = \"UNDO\";\n    ChangeType[\"REDO\"] = \"REDO\";\n    ChangeType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(ChangeType || (exports.ChangeType = ChangeType = {}));\n// Make sure to match this in both tempo-devtools & ** tempo-api ** (in the undo/redo file)\nexports.CHANGE_TYPES_WITH_INSTANT_UNDO = [\n    ChangeType.REMOVE_JSX,\n    ChangeType.ADD_CLASS,\n    ChangeType.STYLING,\n];\nclass ChangeLedgerItem {\n    constructor(type, changeName, changeFields, id) {\n        this.prevIdToNewIdMap = {};\n        this.id = id || (0, uuid_1.v4)();\n        this.type = type;\n        this.changeFields = changeFields;\n        this.changeName = changeName;\n        this._consumed = false;\n        this._failed = false;\n        this._instantUpdateSent = false;\n        this._instantUpdateFinished = false;\n        this._instantUpdateSuccessful = false;\n        this._sendInstantUpdate = true;\n        this.canInstantUpdateWhileFlushing = false;\n        this._apiPromise = new Promise((resolve, reject) => {\n            this._resolveApi = resolve;\n            this._rejectApi = reject;\n        });\n    }\n    resolveApi(data) {\n        var _a;\n        (_a = this._resolveApi) === null || _a === void 0 ? void 0 : _a.call(this, data);\n    }\n    rejectApi(reason) {\n        var _a;\n        if (this._apiRejectionAdded) {\n            (_a = this._rejectApi) === null || _a === void 0 ? void 0 : _a.call(this, reason);\n        }\n    }\n    needsToSendInstantUpdate() {\n        return !this._instantUpdateSent && this._sendInstantUpdate;\n    }\n    markInstantUpdateSent() {\n        this._instantUpdateSent = true;\n    }\n    markInstantUpdateFinished(instantUpdateData, instantUpdateSuccessful) {\n        this._instantUpdateFinished = true;\n        this._instantUpdateSuccessful = instantUpdateSuccessful;\n        this._instantUpdateData = instantUpdateData;\n    }\n    getInstantUpdateData() {\n        return this._instantUpdateData;\n    }\n    wasInstantUpdateSuccessful() {\n        return this._instantUpdateSuccessful;\n    }\n    isInstantUpdateFinished() {\n        return this._instantUpdateFinished;\n    }\n    markProcessedSucceeded() {\n        this._consumed = true;\n    }\n    markProcessedFailed() {\n        this._failed = true;\n        this._consumed = true;\n    }\n    isFailed() {\n        return this._failed;\n    }\n    needToProcessChange() {\n        return !this._consumed;\n    }\n    onApiResolve(onFulfilled) {\n        return this._apiPromise.then(onFulfilled);\n    }\n    onApiReject(onRejected) {\n        this._apiRejectionAdded = true;\n        return this._apiPromise.catch(onRejected);\n    }\n    doNotSendInstantUpdate() {\n        this._sendInstantUpdate = false;\n    }\n    // For selecting/deslecting new elements after instant updates\n    clearSelectedElementsAfterInstantUpdate() {\n        this.elementKeyToSelectAfterInstantUpdate = null;\n        this.elementKeysToMultiselectAfterInstantUpdate = null;\n    }\n    setSelectedElementsAfterInstantUpdate(selectedElementKey, multiselectedElementKeys) {\n        this.elementKeyToSelectAfterInstantUpdate = selectedElementKey;\n        this.elementKeysToMultiselectAfterInstantUpdate = multiselectedElementKeys;\n    }\n    clearSelectedElementsAfterUndoInstantUpdate() {\n        this.elementKeyToSelectAfterUndoInstantUpdate = null;\n        this.elementKeysToMultiselectAfterUndoInstantUpdate = null;\n    }\n    setSelectedElementsAfterUndoInstantUpdate(selectedElementKey, multiselectedElementKeys) {\n        this.elementKeyToSelectAfterUndoInstantUpdate = selectedElementKey;\n        this.elementKeysToMultiselectAfterUndoInstantUpdate =\n            multiselectedElementKeys;\n    }\n    getElementKeyToSelectAfterInstantUpdate() {\n        return this.elementKeyToSelectAfterInstantUpdate;\n    }\n    getElementKeysToMultiselectAfterInstantUpdate() {\n        return this.elementKeysToMultiselectAfterInstantUpdate;\n    }\n    getElementKeyToSelectAfterUndoInstantUpdate() {\n        return this.elementKeyToSelectAfterUndoInstantUpdate;\n    }\n    getElementKeysToMultiselectAfterUndoInstantUpdate() {\n        return this.elementKeysToMultiselectAfterUndoInstantUpdate;\n    }\n    applyAllCodebaseIdChanges(prevIdToNewIdMap) {\n        var _a, _b;\n        const getNewKey = (prevKey) => {\n            if (!prevKey) {\n                return null;\n            }\n            const tempoElement = tempoElement_1.TempoElement.fromKey(prevKey);\n            const codebaseId = tempoElement.codebaseId;\n            const newCodebaseId = prevIdToNewIdMap[codebaseId];\n            if (newCodebaseId) {\n                return new tempoElement_1.TempoElement(newCodebaseId, tempoElement.storyboardId, tempoElement.uniquePath).getKey();\n            }\n            return null;\n        };\n        /*\n         * Instant update fields\n         */\n        if (this.elementKeyToSelectAfterInstantUpdate) {\n            const newElementKey = getNewKey(this.elementKeyToSelectAfterInstantUpdate);\n            this.elementKeyToSelectAfterInstantUpdate =\n                newElementKey || this.elementKeyToSelectAfterInstantUpdate;\n        }\n        if (this.elementKeysToMultiselectAfterInstantUpdate) {\n            this.elementKeysToMultiselectAfterInstantUpdate =\n                (_a = this.elementKeysToMultiselectAfterInstantUpdate) === null || _a === void 0 ? void 0 : _a.map((key) => {\n                    const newKey = getNewKey(key);\n                    return newKey || key;\n                });\n        }\n        /*\n         * Undo instant update fields\n         */\n        if (this.elementKeyToSelectAfterUndoInstantUpdate) {\n            const newElementKey = getNewKey(this.elementKeyToSelectAfterUndoInstantUpdate);\n            this.elementKeyToSelectAfterUndoInstantUpdate =\n                newElementKey || this.elementKeyToSelectAfterUndoInstantUpdate;\n        }\n        if (this.elementKeysToMultiselectAfterUndoInstantUpdate) {\n            this.elementKeysToMultiselectAfterUndoInstantUpdate =\n                (_b = this.elementKeysToMultiselectAfterUndoInstantUpdate) === null || _b === void 0 ? void 0 : _b.map((key) => {\n                    const newKey = getNewKey(key);\n                    return newKey || key;\n                });\n        }\n        this.applyCodebaseIdChanges(prevIdToNewIdMap);\n    }\n}\nexports.ChangeLedgerItem = ChangeLedgerItem;\nclass StylingChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.STYLING, 'Styling', changeFields, id);\n        // Allow instant updates while flushing\n        this.canInstantUpdateWhileFlushing = true;\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseId, stylingChanges, stylingFramework, modifiers, customProperties, } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/styling`,\n            body: {\n                reactElement: treeElementLookup[codebaseId],\n                styling: stylingChanges,\n                stylingFramework,\n                modifiers,\n                customProperties,\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        const newCodebaseId = prevIdToNewIdMap[this.changeFields.codebaseId];\n        if (newCodebaseId) {\n            this.changeFields.codebaseId = newCodebaseId;\n        }\n    }\n}\nexports.StylingChange = StylingChange;\nclass AddJsxChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.ADD_JSX, 'Add Element', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdToAddTo, beforeCodebaseId, afterCodebaseId, addCodebaseId, addNativeTag, fileContentsToSourceFrom, fileContentsSourceFilename, propsToSet, deletedStoryboardId, htmlForInstantUpdate, } = this.changeFields;\n        const body = {\n            destinationElement: treeElementLookup[codebaseIdToAddTo],\n            beforeElement: treeElementLookup[beforeCodebaseId || ''],\n            afterElement: treeElementLookup[afterCodebaseId || ''],\n            newElement: {},\n            canvasId: activeCanvas.id,\n            deletedStoryboardId,\n            fileContentsToSourceFrom,\n            fileContentsSourceFilename,\n        };\n        if (addCodebaseId) {\n            body.newElement = Object.assign({}, treeElementLookup[addCodebaseId]);\n        }\n        else if (addNativeTag) {\n            body.newElement['type'] = 'native';\n            body.newElement['nativeTag'] = addNativeTag;\n            body.newElement['componentName'] = addNativeTag;\n        }\n        if (propsToSet) {\n            body.newElement['propsToSet'] = propsToSet;\n        }\n        if (!Object.keys(body.newElement).length) {\n            delete body.newElement;\n        }\n        const hasInstantUpdate = Boolean(htmlForInstantUpdate);\n        body['hasInstantUpdate'] = hasInstantUpdate;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/addJsxElement`,\n            body,\n            // Only show the success message if we do not have instant updates\n            successToastMessage: hasInstantUpdate ? undefined : 'Successfully added',\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        const fieldsToApply = [\n            'codebaseIdToAddTo',\n            'beforeCodebaseId',\n            'afterCodebaseId',\n            'addCodebaseId',\n        ];\n        fieldsToApply.forEach((field) => {\n            // @ts-ignore\n            const newCodebaseId = prevIdToNewIdMap[this.changeFields[field]];\n            if (newCodebaseId) {\n                // @ts-ignore\n                this.changeFields[field] = newCodebaseId;\n            }\n        });\n    }\n}\nexports.AddJsxChange = AddJsxChange;\nclass MoveJsxChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.MOVE_JSX, 'Move Element', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdToMoveTo, codebaseIdToMove, afterCodebaseId, beforeCodebaseId, expectedCurrentParentCodebaseId, } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/moveJsxElement`,\n            body: {\n                elementToMove: treeElementLookup[codebaseIdToMove],\n                newContainerElement: treeElementLookup[codebaseIdToMoveTo],\n                afterElement: treeElementLookup[afterCodebaseId || ''],\n                beforeElement: treeElementLookup[beforeCodebaseId || ''],\n                expectedCurrentParent: treeElementLookup[expectedCurrentParentCodebaseId || ''],\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        const fieldsToApply = [\n            'codebaseIdToMoveTo',\n            'codebaseIdToMove',\n            'afterCodebaseId',\n            'beforeCodebaseId',\n            'expectedCurrentParentCodebaseId',\n        ];\n        fieldsToApply.forEach((field) => {\n            // @ts-ignore\n            const newCodebaseId = prevIdToNewIdMap[this.changeFields[field]];\n            if (newCodebaseId) {\n                // @ts-ignore\n                this.changeFields[field] = newCodebaseId;\n            }\n        });\n    }\n}\nexports.MoveJsxChange = MoveJsxChange;\nclass RemoveJsxChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        // Deduplicate the codebaseIdsToRemove\n        changeFields.codebaseIdsToRemove = Array.from(new Set(changeFields.codebaseIdsToRemove));\n        super(ChangeType.REMOVE_JSX, 'Delete Element', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdsToRemove } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/removeJsxElement`,\n            body: {\n                elementsToRemove: codebaseIdsToRemove\n                    .map((codebaseId) => treeElementLookup[codebaseId])\n                    .filter((element) => element),\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        this.changeFields.codebaseIdsToRemove =\n            this.changeFields.codebaseIdsToRemove.map((codebaseId) => {\n                const newCodebaseId = prevIdToNewIdMap[codebaseId];\n                if (newCodebaseId) {\n                    return newCodebaseId;\n                }\n                return codebaseId;\n            });\n    }\n}\nexports.RemoveJsxChange = RemoveJsxChange;\nclass ChangePropChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.CHANGE_PROP, 'Change Prop', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdToChange, propName, propValue } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/changePropValue`,\n            body: {\n                elementToModify: treeElementLookup[codebaseIdToChange],\n                propName,\n                propValue,\n            },\n            successToastMessage: 'Prop changed',\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        const newCodebaseId = prevIdToNewIdMap[this.changeFields.codebaseIdToChange];\n        if (newCodebaseId) {\n            this.changeFields.codebaseIdToChange = newCodebaseId;\n        }\n    }\n}\nexports.ChangePropChange = ChangePropChange;\nclass WrapDivChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        // Deduplicate the codebaseIdsToWrap\n        changeFields.codebaseIdsToWrap = Array.from(new Set(changeFields.codebaseIdsToWrap));\n        super(ChangeType.WRAP_DIV, 'Wrap In Div', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdsToWrap } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/wrapInDiv`,\n            body: {\n                reactElements: codebaseIdsToWrap.map((codebaseId) => treeElementLookup[codebaseId]),\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        this.changeFields.codebaseIdsToWrap =\n            this.changeFields.codebaseIdsToWrap.map((codebaseId) => {\n                const newCodebaseId = prevIdToNewIdMap[codebaseId];\n                if (newCodebaseId) {\n                    return newCodebaseId;\n                }\n                return codebaseId;\n            });\n    }\n}\nexports.WrapDivChange = WrapDivChange;\nclass DuplicateChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        // Deduplicate the codebaseIdsToDuplicate\n        changeFields.codebaseIdsToDuplicate = Array.from(new Set(changeFields.codebaseIdsToDuplicate));\n        super(ChangeType.DUPLICATE, 'Duplicate', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdsToDuplicate } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/duplicate`,\n            body: {\n                reactElements: codebaseIdsToDuplicate.map((codebaseId) => treeElementLookup[codebaseId]),\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        this.changeFields.codebaseIdsToDuplicate =\n            this.changeFields.codebaseIdsToDuplicate.map((codebaseId) => {\n                const newCodebaseId = prevIdToNewIdMap[codebaseId];\n                if (newCodebaseId) {\n                    return newCodebaseId;\n                }\n                return codebaseId;\n            });\n    }\n}\nexports.DuplicateChange = DuplicateChange;\nclass ChangeTagChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.CHANGE_TAG, 'Change Tag Name', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdToChange, newTagName } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/changeElementTag`,\n            body: {\n                elementToModify: treeElementLookup[codebaseIdToChange],\n                newTag: newTagName,\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        const newCodebaseId = prevIdToNewIdMap[this.changeFields.codebaseIdToChange];\n        if (newCodebaseId) {\n            this.changeFields.codebaseIdToChange = newCodebaseId;\n        }\n    }\n}\nexports.ChangeTagChange = ChangeTagChange;\nclass AddClassChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.ADD_CLASS, 'Add Class', changeFields, id);\n        this.canInstantUpdateWhileFlushing = true;\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdToAddClass, className, addingTailwindClass, modifiers, customProperties, } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/addClass`,\n            body: {\n                reactElement: treeElementLookup[codebaseIdToAddClass],\n                className,\n                stylingFramework: addingTailwindClass\n                    ? StylingFramework.TAILWIND\n                    : null,\n                modifiers,\n                customProperties,\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        const newCodebaseId = prevIdToNewIdMap[this.changeFields.codebaseIdToAddClass];\n        if (newCodebaseId) {\n            this.changeFields.codebaseIdToAddClass = newCodebaseId;\n        }\n    }\n}\nexports.AddClassChange = AddClassChange;\nclass RemoveClassChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.REMOVE_CLASS, 'Remove Class', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdToRemoveClass, className } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/removeClass`,\n            body: {\n                reactElement: treeElementLookup[codebaseIdToRemoveClass],\n                className,\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        const newCodebaseId = prevIdToNewIdMap[this.changeFields.codebaseIdToRemoveClass];\n        if (newCodebaseId) {\n            this.changeFields.codebaseIdToRemoveClass = newCodebaseId;\n        }\n    }\n}\nexports.RemoveClassChange = RemoveClassChange;\nclass EditTextChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.EDIT_TEXT, 'Edit Text', changeFields, id);\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { codebaseIdToEditText, newText, oldText } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/mutate/editText`,\n            body: {\n                element: treeElementLookup[codebaseIdToEditText],\n                newText,\n                oldText,\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        const newCodebaseId = prevIdToNewIdMap[this.changeFields.codebaseIdToEditText];\n        if (newCodebaseId) {\n            this.changeFields.codebaseIdToEditText = newCodebaseId;\n        }\n    }\n}\nexports.EditTextChange = EditTextChange;\nclass UndoChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        var _a;\n        super(ChangeType.UNDO, 'Undo', changeFields, id);\n        if ((_a = changeFields.changeToUndo) === null || _a === void 0 ? void 0 : _a.canInstantUpdateWhileFlushing) {\n            this.canInstantUpdateWhileFlushing = true;\n        }\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { changeToUndo } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/activities/undoChangeToFiles`,\n            body: {\n                latestUuid: changeToUndo.activityId,\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        // Do nothing\n    }\n}\nexports.UndoChange = UndoChange;\nclass RedoChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        var _a;\n        super(ChangeType.REDO, 'Redo', changeFields, id);\n        if ((_a = changeFields.changeToRedo) === null || _a === void 0 ? void 0 : _a.canInstantUpdateWhileFlushing) {\n            this.canInstantUpdateWhileFlushing = true;\n        }\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        const { changeToRedo } = this.changeFields;\n        return {\n            urlPath: `canvases/${canvasId}/parseAndMutate/activities/redoChangeToFiles`,\n            body: {\n                changeToRedoId: changeToRedo.activityId,\n            },\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        // Do nothing\n    }\n}\nexports.RedoChange = RedoChange;\nclass UnknownChange extends ChangeLedgerItem {\n    constructor(changeFields, id) {\n        super(ChangeType.UNKNOWN, '', changeFields, id);\n        // Do not process unknown changes\n        this.markProcessedSucceeded();\n        this.doNotSendInstantUpdate();\n    }\n    prepareApiRequest(canvasId, treeElementLookup, activeCanvas) {\n        throw Error('Unsupported operation');\n        // For typing\n        return {\n            urlPath: ``,\n            body: {},\n        };\n    }\n    applyCodebaseIdChanges(prevIdToNewIdMap) {\n        // Do nothing\n    }\n}\nexports.UnknownChange = UnknownChange;\n/**\n * When serializing a change ledger item to a plain JS object, the class functions\n * are lost. This recreates the change item that was lost\n */\nconst reconstructChangeLedgerClass = (plainJsObject) => {\n    if (!plainJsObject || !plainJsObject.type) {\n        return null;\n    }\n    const changeType = plainJsObject.type;\n    const changeFields = plainJsObject.changeFields;\n    const id = plainJsObject.id;\n    const getChangeForType = () => {\n        switch (changeType) {\n            case ChangeType.STYLING:\n                return new StylingChange(changeFields, id);\n            case ChangeType.ADD_JSX:\n                return new AddJsxChange(changeFields, id);\n            case ChangeType.REMOVE_JSX:\n                return new RemoveJsxChange(changeFields, id);\n            case ChangeType.MOVE_JSX:\n                return new MoveJsxChange(changeFields, id);\n            case ChangeType.CHANGE_PROP:\n                return new ChangePropChange(changeFields, id);\n            case ChangeType.ADD_CLASS:\n                return new AddClassChange(changeFields, id);\n            case ChangeType.REMOVE_CLASS:\n                return new RemoveClassChange(changeFields, id);\n            case ChangeType.WRAP_DIV:\n                return new WrapDivChange(changeFields, id);\n            case ChangeType.CHANGE_TAG:\n                return new ChangeTagChange(changeFields, id);\n            case ChangeType.DUPLICATE:\n                return new DuplicateChange(changeFields, id);\n            case ChangeType.EDIT_TEXT:\n                return new EditTextChange(changeFields, id);\n            case ChangeType.UNDO:\n                changeFields.changeToUndo = (0, exports.reconstructChangeLedgerClass)(changeFields.changeToUndo);\n                return new UndoChange(changeFields, id);\n            case ChangeType.REDO:\n                changeFields.changeToRedo = (0, exports.reconstructChangeLedgerClass)(changeFields.changeToRedo);\n                return new RedoChange(changeFields, id);\n            case ChangeType.UNKNOWN:\n                return new UnknownChange(changeFields, id);\n            default:\n                throw new Error(`Unknown change type: ${changeType}`);\n        }\n    };\n    // Set all the other fields on the change object\n    const change = getChangeForType();\n    Object.keys(plainJsObject).forEach((key) => {\n        if (['type', 'changeFields', 'id'].includes(key)) {\n            return;\n        }\n        // @ts-ignore\n        change[key] = plainJsObject[key];\n    });\n    return change;\n};\nexports.reconstructChangeLedgerClass = reconstructChangeLedgerClass;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2NoYW5nZUxlZGdlclR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLHNDQUFzQyxHQUFHLGtCQUFrQixHQUFHLHdCQUF3QjtBQUNoZix1QkFBdUIsbUJBQU8sQ0FBQyxpR0FBZ0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLDhEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLHdCQUF3Qix3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3REO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RUFBNkU7QUFDN0Y7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa01BQWtNO0FBQ2xOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEdBQTRHO0FBQzVIO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFGQUFxRjtBQUNyRztBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHRlbXBvLWRldnRvb2xzXFxkaXN0XFxjaGFubmVsTWVzc2FnaW5nXFxjaGFuZ2VMZWRnZXJUeXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb25zdHJ1Y3RDaGFuZ2VMZWRnZXJDbGFzcyA9IGV4cG9ydHMuVW5rbm93bkNoYW5nZSA9IGV4cG9ydHMuUmVkb0NoYW5nZSA9IGV4cG9ydHMuVW5kb0NoYW5nZSA9IGV4cG9ydHMuRWRpdFRleHRDaGFuZ2UgPSBleHBvcnRzLlJlbW92ZUNsYXNzQ2hhbmdlID0gZXhwb3J0cy5BZGRDbGFzc0NoYW5nZSA9IGV4cG9ydHMuQ2hhbmdlVGFnQ2hhbmdlID0gZXhwb3J0cy5EdXBsaWNhdGVDaGFuZ2UgPSBleHBvcnRzLldyYXBEaXZDaGFuZ2UgPSBleHBvcnRzLkNoYW5nZVByb3BDaGFuZ2UgPSBleHBvcnRzLlJlbW92ZUpzeENoYW5nZSA9IGV4cG9ydHMuTW92ZUpzeENoYW5nZSA9IGV4cG9ydHMuQWRkSnN4Q2hhbmdlID0gZXhwb3J0cy5TdHlsaW5nQ2hhbmdlID0gZXhwb3J0cy5DaGFuZ2VMZWRnZXJJdGVtID0gZXhwb3J0cy5DSEFOR0VfVFlQRVNfV0lUSF9JTlNUQU5UX1VORE8gPSBleHBvcnRzLkNoYW5nZVR5cGUgPSBleHBvcnRzLlN0eWxpbmdGcmFtZXdvcmsgPSB2b2lkIDA7XG5jb25zdCB0ZW1wb0VsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL3RlbXBvRWxlbWVudFwiKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuLy8gTWF0Y2hlcyB0aGUgZmlsZSBpbiB0ZW1wby1kZXZ0b29sc1xudmFyIFN0eWxpbmdGcmFtZXdvcms7XG4oZnVuY3Rpb24gKFN0eWxpbmdGcmFtZXdvcmspIHtcbiAgICBTdHlsaW5nRnJhbWV3b3JrW1wiSU5MSU5FXCJdID0gXCJJbmxpbmVcIjtcbiAgICBTdHlsaW5nRnJhbWV3b3JrW1wiQ1NTXCJdID0gXCJDU1NcIjtcbiAgICBTdHlsaW5nRnJhbWV3b3JrW1wiVEFJTFdJTkRcIl0gPSBcIlRhaWx3aW5kXCI7XG59KShTdHlsaW5nRnJhbWV3b3JrIHx8IChleHBvcnRzLlN0eWxpbmdGcmFtZXdvcmsgPSBTdHlsaW5nRnJhbWV3b3JrID0ge30pKTtcbnZhciBDaGFuZ2VUeXBlO1xuKGZ1bmN0aW9uIChDaGFuZ2VUeXBlKSB7XG4gICAgQ2hhbmdlVHlwZVtcIlNUWUxJTkdcIl0gPSBcIlNUWUxJTkdcIjtcbiAgICBDaGFuZ2VUeXBlW1wiQUREX0pTWFwiXSA9IFwiQUREX0pTWFwiO1xuICAgIENoYW5nZVR5cGVbXCJNT1ZFX0pTWFwiXSA9IFwiTU9WRV9KU1hcIjtcbiAgICBDaGFuZ2VUeXBlW1wiUkVNT1ZFX0pTWFwiXSA9IFwiUkVNT1ZFX0pTWFwiO1xuICAgIENoYW5nZVR5cGVbXCJDSEFOR0VfUFJPUFwiXSA9IFwiQ0hBTkdFX1BST1BcIjtcbiAgICBDaGFuZ2VUeXBlW1wiQUREX0NMQVNTXCJdID0gXCJBRERfQ0xBU1NcIjtcbiAgICBDaGFuZ2VUeXBlW1wiUkVNT1ZFX0NMQVNTXCJdID0gXCJSRU1PVkVfQ0xBU1NcIjtcbiAgICBDaGFuZ2VUeXBlW1wiRURJVF9URVhUXCJdID0gXCJFRElUX1RFWFRcIjtcbiAgICBDaGFuZ2VUeXBlW1wiV1JBUF9ESVZcIl0gPSBcIldSQVBfRElWXCI7XG4gICAgQ2hhbmdlVHlwZVtcIkNIQU5HRV9UQUdcIl0gPSBcIkNIQU5HRV9UQUdcIjtcbiAgICBDaGFuZ2VUeXBlW1wiRFVQTElDQVRFXCJdID0gXCJEVVBMSUNBVEVcIjtcbiAgICBDaGFuZ2VUeXBlW1wiVU5ET1wiXSA9IFwiVU5ET1wiO1xuICAgIENoYW5nZVR5cGVbXCJSRURPXCJdID0gXCJSRURPXCI7XG4gICAgQ2hhbmdlVHlwZVtcIlVOS05PV05cIl0gPSBcIlVOS05PV05cIjtcbn0pKENoYW5nZVR5cGUgfHwgKGV4cG9ydHMuQ2hhbmdlVHlwZSA9IENoYW5nZVR5cGUgPSB7fSkpO1xuLy8gTWFrZSBzdXJlIHRvIG1hdGNoIHRoaXMgaW4gYm90aCB0ZW1wby1kZXZ0b29scyAmICoqIHRlbXBvLWFwaSAqKiAoaW4gdGhlIHVuZG8vcmVkbyBmaWxlKVxuZXhwb3J0cy5DSEFOR0VfVFlQRVNfV0lUSF9JTlNUQU5UX1VORE8gPSBbXG4gICAgQ2hhbmdlVHlwZS5SRU1PVkVfSlNYLFxuICAgIENoYW5nZVR5cGUuQUREX0NMQVNTLFxuICAgIENoYW5nZVR5cGUuU1RZTElORyxcbl07XG5jbGFzcyBDaGFuZ2VMZWRnZXJJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBjaGFuZ2VOYW1lLCBjaGFuZ2VGaWVsZHMsIGlkKSB7XG4gICAgICAgIHRoaXMucHJldklkVG9OZXdJZE1hcCA9IHt9O1xuICAgICAgICB0aGlzLmlkID0gaWQgfHwgKDAsIHV1aWRfMS52NCkoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VGaWVsZHMgPSBjaGFuZ2VGaWVsZHM7XG4gICAgICAgIHRoaXMuY2hhbmdlTmFtZSA9IGNoYW5nZU5hbWU7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZhaWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnN0YW50VXBkYXRlU2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnN0YW50VXBkYXRlRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VuZEluc3RhbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbkluc3RhbnRVcGRhdGVXaGlsZUZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FwaVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlQXBpID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdEFwaSA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVBcGkoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX3Jlc29sdmVBcGkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIH1cbiAgICByZWplY3RBcGkocmVhc29uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2FwaVJlamVjdGlvbkFkZGVkKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9yZWplY3RBcGkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmVlZHNUb1NlbmRJbnN0YW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2luc3RhbnRVcGRhdGVTZW50ICYmIHRoaXMuX3NlbmRJbnN0YW50VXBkYXRlO1xuICAgIH1cbiAgICBtYXJrSW5zdGFudFVwZGF0ZVNlbnQoKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbnRVcGRhdGVTZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgbWFya0luc3RhbnRVcGRhdGVGaW5pc2hlZChpbnN0YW50VXBkYXRlRGF0YSwgaW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgdGhpcy5faW5zdGFudFVwZGF0ZUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwgPSBpbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bDtcbiAgICAgICAgdGhpcy5faW5zdGFudFVwZGF0ZURhdGEgPSBpbnN0YW50VXBkYXRlRGF0YTtcbiAgICB9XG4gICAgZ2V0SW5zdGFudFVwZGF0ZURhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50VXBkYXRlRGF0YTtcbiAgICB9XG4gICAgd2FzSW5zdGFudFVwZGF0ZVN1Y2Nlc3NmdWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50VXBkYXRlU3VjY2Vzc2Z1bDtcbiAgICB9XG4gICAgaXNJbnN0YW50VXBkYXRlRmluaXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50VXBkYXRlRmluaXNoZWQ7XG4gICAgfVxuICAgIG1hcmtQcm9jZXNzZWRTdWNjZWVkZWQoKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbWFya1Byb2Nlc3NlZEZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy5fZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY29uc3VtZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpc0ZhaWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxlZDtcbiAgICB9XG4gICAgbmVlZFRvUHJvY2Vzc0NoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9jb25zdW1lZDtcbiAgICB9XG4gICAgb25BcGlSZXNvbHZlKG9uRnVsZmlsbGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcGlQcm9taXNlLnRoZW4ob25GdWxmaWxsZWQpO1xuICAgIH1cbiAgICBvbkFwaVJlamVjdChvblJlamVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2FwaVJlamVjdGlvbkFkZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwaVByb21pc2UuY2F0Y2gob25SZWplY3RlZCk7XG4gICAgfVxuICAgIGRvTm90U2VuZEluc3RhbnRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3NlbmRJbnN0YW50VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEZvciBzZWxlY3RpbmcvZGVzbGVjdGluZyBuZXcgZWxlbWVudHMgYWZ0ZXIgaW5zdGFudCB1cGRhdGVzXG4gICAgY2xlYXJTZWxlY3RlZEVsZW1lbnRzQWZ0ZXJJbnN0YW50VXBkYXRlKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRLZXlUb1NlbGVjdEFmdGVySW5zdGFudFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlID0gbnVsbDtcbiAgICB9XG4gICAgc2V0U2VsZWN0ZWRFbGVtZW50c0FmdGVySW5zdGFudFVwZGF0ZShzZWxlY3RlZEVsZW1lbnRLZXksIG11bHRpc2VsZWN0ZWRFbGVtZW50S2V5cykge1xuICAgICAgICB0aGlzLmVsZW1lbnRLZXlUb1NlbGVjdEFmdGVySW5zdGFudFVwZGF0ZSA9IHNlbGVjdGVkRWxlbWVudEtleTtcbiAgICAgICAgdGhpcy5lbGVtZW50S2V5c1RvTXVsdGlzZWxlY3RBZnRlckluc3RhbnRVcGRhdGUgPSBtdWx0aXNlbGVjdGVkRWxlbWVudEtleXM7XG4gICAgfVxuICAgIGNsZWFyU2VsZWN0ZWRFbGVtZW50c0FmdGVyVW5kb0luc3RhbnRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJVbmRvSW5zdGFudFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJVbmRvSW5zdGFudFVwZGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIHNldFNlbGVjdGVkRWxlbWVudHNBZnRlclVuZG9JbnN0YW50VXBkYXRlKHNlbGVjdGVkRWxlbWVudEtleSwgbXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJVbmRvSW5zdGFudFVwZGF0ZSA9IHNlbGVjdGVkRWxlbWVudEtleTtcbiAgICAgICAgdGhpcy5lbGVtZW50S2V5c1RvTXVsdGlzZWxlY3RBZnRlclVuZG9JbnN0YW50VXBkYXRlID1cbiAgICAgICAgICAgIG11bHRpc2VsZWN0ZWRFbGVtZW50S2V5cztcbiAgICB9XG4gICAgZ2V0RWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50S2V5VG9TZWxlY3RBZnRlckluc3RhbnRVcGRhdGU7XG4gICAgfVxuICAgIGdldEVsZW1lbnRLZXlzVG9NdWx0aXNlbGVjdEFmdGVySW5zdGFudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlO1xuICAgIH1cbiAgICBnZXRFbGVtZW50S2V5VG9TZWxlY3RBZnRlclVuZG9JbnN0YW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50S2V5VG9TZWxlY3RBZnRlclVuZG9JbnN0YW50VXBkYXRlO1xuICAgIH1cbiAgICBnZXRFbGVtZW50S2V5c1RvTXVsdGlzZWxlY3RBZnRlclVuZG9JbnN0YW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50S2V5c1RvTXVsdGlzZWxlY3RBZnRlclVuZG9JbnN0YW50VXBkYXRlO1xuICAgIH1cbiAgICBhcHBseUFsbENvZGViYXNlSWRDaGFuZ2VzKHByZXZJZFRvTmV3SWRNYXApIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZ2V0TmV3S2V5ID0gKHByZXZLZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghcHJldktleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGVtcG9FbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkocHJldktleSk7XG4gICAgICAgICAgICBjb25zdCBjb2RlYmFzZUlkID0gdGVtcG9FbGVtZW50LmNvZGViYXNlSWQ7XG4gICAgICAgICAgICBjb25zdCBuZXdDb2RlYmFzZUlkID0gcHJldklkVG9OZXdJZE1hcFtjb2RlYmFzZUlkXTtcbiAgICAgICAgICAgIGlmIChuZXdDb2RlYmFzZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQobmV3Q29kZWJhc2VJZCwgdGVtcG9FbGVtZW50LnN0b3J5Ym9hcmRJZCwgdGVtcG9FbGVtZW50LnVuaXF1ZVBhdGgpLmdldEtleSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgICAqIEluc3RhbnQgdXBkYXRlIGZpZWxkc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFbGVtZW50S2V5ID0gZ2V0TmV3S2V5KHRoaXMuZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlID1cbiAgICAgICAgICAgICAgICBuZXdFbGVtZW50S2V5IHx8IHRoaXMuZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRLZXlzVG9NdWx0aXNlbGVjdEFmdGVySW5zdGFudFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50S2V5c1RvTXVsdGlzZWxlY3RBZnRlckluc3RhbnRVcGRhdGUgPVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJJbnN0YW50VXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3S2V5ID0gZ2V0TmV3S2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdLZXkgfHwga2V5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIFVuZG8gaW5zdGFudCB1cGRhdGUgZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50S2V5VG9TZWxlY3RBZnRlclVuZG9JbnN0YW50VXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFbGVtZW50S2V5ID0gZ2V0TmV3S2V5KHRoaXMuZWxlbWVudEtleVRvU2VsZWN0QWZ0ZXJVbmRvSW5zdGFudFVwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRLZXlUb1NlbGVjdEFmdGVyVW5kb0luc3RhbnRVcGRhdGUgPVxuICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRLZXkgfHwgdGhpcy5lbGVtZW50S2V5VG9TZWxlY3RBZnRlclVuZG9JbnN0YW50VXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRLZXlzVG9NdWx0aXNlbGVjdEFmdGVyVW5kb0luc3RhbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudEtleXNUb011bHRpc2VsZWN0QWZ0ZXJVbmRvSW5zdGFudFVwZGF0ZSA9XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5lbGVtZW50S2V5c1RvTXVsdGlzZWxlY3RBZnRlclVuZG9JbnN0YW50VXBkYXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3S2V5ID0gZ2V0TmV3S2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdLZXkgfHwga2V5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHlDb2RlYmFzZUlkQ2hhbmdlcyhwcmV2SWRUb05ld0lkTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5nZUxlZGdlckl0ZW0gPSBDaGFuZ2VMZWRnZXJJdGVtO1xuY2xhc3MgU3R5bGluZ0NoYW5nZSBleHRlbmRzIENoYW5nZUxlZGdlckl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZUZpZWxkcywgaWQpIHtcbiAgICAgICAgc3VwZXIoQ2hhbmdlVHlwZS5TVFlMSU5HLCAnU3R5bGluZycsIGNoYW5nZUZpZWxkcywgaWQpO1xuICAgICAgICAvLyBBbGxvdyBpbnN0YW50IHVwZGF0ZXMgd2hpbGUgZmx1c2hpbmdcbiAgICAgICAgdGhpcy5jYW5JbnN0YW50VXBkYXRlV2hpbGVGbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIHByZXBhcmVBcGlSZXF1ZXN0KGNhbnZhc0lkLCB0cmVlRWxlbWVudExvb2t1cCwgYWN0aXZlQ2FudmFzKSB7XG4gICAgICAgIGNvbnN0IHsgY29kZWJhc2VJZCwgc3R5bGluZ0NoYW5nZXMsIHN0eWxpbmdGcmFtZXdvcmssIG1vZGlmaWVycywgY3VzdG9tUHJvcGVydGllcywgfSA9IHRoaXMuY2hhbmdlRmllbGRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsUGF0aDogYGNhbnZhc2VzLyR7Y2FudmFzSWR9L3BhcnNlQW5kTXV0YXRlL211dGF0ZS9zdHlsaW5nYCxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICByZWFjdEVsZW1lbnQ6IHRyZWVFbGVtZW50TG9va3VwW2NvZGViYXNlSWRdLFxuICAgICAgICAgICAgICAgIHN0eWxpbmc6IHN0eWxpbmdDaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHN0eWxpbmdGcmFtZXdvcmssXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgIGN1c3RvbVByb3BlcnRpZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBseUNvZGViYXNlSWRDaGFuZ2VzKHByZXZJZFRvTmV3SWRNYXApIHtcbiAgICAgICAgY29uc3QgbmV3Q29kZWJhc2VJZCA9IHByZXZJZFRvTmV3SWRNYXBbdGhpcy5jaGFuZ2VGaWVsZHMuY29kZWJhc2VJZF07XG4gICAgICAgIGlmIChuZXdDb2RlYmFzZUlkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkID0gbmV3Q29kZWJhc2VJZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3R5bGluZ0NoYW5nZSA9IFN0eWxpbmdDaGFuZ2U7XG5jbGFzcyBBZGRKc3hDaGFuZ2UgZXh0ZW5kcyBDaGFuZ2VMZWRnZXJJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VGaWVsZHMsIGlkKSB7XG4gICAgICAgIHN1cGVyKENoYW5nZVR5cGUuQUREX0pTWCwgJ0FkZCBFbGVtZW50JywgY2hhbmdlRmllbGRzLCBpZCk7XG4gICAgfVxuICAgIHByZXBhcmVBcGlSZXF1ZXN0KGNhbnZhc0lkLCB0cmVlRWxlbWVudExvb2t1cCwgYWN0aXZlQ2FudmFzKSB7XG4gICAgICAgIGNvbnN0IHsgY29kZWJhc2VJZFRvQWRkVG8sIGJlZm9yZUNvZGViYXNlSWQsIGFmdGVyQ29kZWJhc2VJZCwgYWRkQ29kZWJhc2VJZCwgYWRkTmF0aXZlVGFnLCBmaWxlQ29udGVudHNUb1NvdXJjZUZyb20sIGZpbGVDb250ZW50c1NvdXJjZUZpbGVuYW1lLCBwcm9wc1RvU2V0LCBkZWxldGVkU3Rvcnlib2FyZElkLCBodG1sRm9ySW5zdGFudFVwZGF0ZSwgfSA9IHRoaXMuY2hhbmdlRmllbGRzO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgZGVzdGluYXRpb25FbGVtZW50OiB0cmVlRWxlbWVudExvb2t1cFtjb2RlYmFzZUlkVG9BZGRUb10sXG4gICAgICAgICAgICBiZWZvcmVFbGVtZW50OiB0cmVlRWxlbWVudExvb2t1cFtiZWZvcmVDb2RlYmFzZUlkIHx8ICcnXSxcbiAgICAgICAgICAgIGFmdGVyRWxlbWVudDogdHJlZUVsZW1lbnRMb29rdXBbYWZ0ZXJDb2RlYmFzZUlkIHx8ICcnXSxcbiAgICAgICAgICAgIG5ld0VsZW1lbnQ6IHt9LFxuICAgICAgICAgICAgY2FudmFzSWQ6IGFjdGl2ZUNhbnZhcy5pZCxcbiAgICAgICAgICAgIGRlbGV0ZWRTdG9yeWJvYXJkSWQsXG4gICAgICAgICAgICBmaWxlQ29udGVudHNUb1NvdXJjZUZyb20sXG4gICAgICAgICAgICBmaWxlQ29udGVudHNTb3VyY2VGaWxlbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFkZENvZGViYXNlSWQpIHtcbiAgICAgICAgICAgIGJvZHkubmV3RWxlbWVudCA9IE9iamVjdC5hc3NpZ24oe30sIHRyZWVFbGVtZW50TG9va3VwW2FkZENvZGViYXNlSWRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZGROYXRpdmVUYWcpIHtcbiAgICAgICAgICAgIGJvZHkubmV3RWxlbWVudFsndHlwZSddID0gJ25hdGl2ZSc7XG4gICAgICAgICAgICBib2R5Lm5ld0VsZW1lbnRbJ25hdGl2ZVRhZyddID0gYWRkTmF0aXZlVGFnO1xuICAgICAgICAgICAgYm9keS5uZXdFbGVtZW50Wydjb21wb25lbnROYW1lJ10gPSBhZGROYXRpdmVUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzVG9TZXQpIHtcbiAgICAgICAgICAgIGJvZHkubmV3RWxlbWVudFsncHJvcHNUb1NldCddID0gcHJvcHNUb1NldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGJvZHkubmV3RWxlbWVudCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWxldGUgYm9keS5uZXdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0luc3RhbnRVcGRhdGUgPSBCb29sZWFuKGh0bWxGb3JJbnN0YW50VXBkYXRlKTtcbiAgICAgICAgYm9keVsnaGFzSW5zdGFudFVwZGF0ZSddID0gaGFzSW5zdGFudFVwZGF0ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybFBhdGg6IGBjYW52YXNlcy8ke2NhbnZhc0lkfS9wYXJzZUFuZE11dGF0ZS9tdXRhdGUvYWRkSnN4RWxlbWVudGAsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgLy8gT25seSBzaG93IHRoZSBzdWNjZXNzIG1lc3NhZ2UgaWYgd2UgZG8gbm90IGhhdmUgaW5zdGFudCB1cGRhdGVzXG4gICAgICAgICAgICBzdWNjZXNzVG9hc3RNZXNzYWdlOiBoYXNJbnN0YW50VXBkYXRlID8gdW5kZWZpbmVkIDogJ1N1Y2Nlc3NmdWxseSBhZGRlZCcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5Q29kZWJhc2VJZENoYW5nZXMocHJldklkVG9OZXdJZE1hcCkge1xuICAgICAgICBjb25zdCBmaWVsZHNUb0FwcGx5ID0gW1xuICAgICAgICAgICAgJ2NvZGViYXNlSWRUb0FkZFRvJyxcbiAgICAgICAgICAgICdiZWZvcmVDb2RlYmFzZUlkJyxcbiAgICAgICAgICAgICdhZnRlckNvZGViYXNlSWQnLFxuICAgICAgICAgICAgJ2FkZENvZGViYXNlSWQnLFxuICAgICAgICBdO1xuICAgICAgICBmaWVsZHNUb0FwcGx5LmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBuZXdDb2RlYmFzZUlkID0gcHJldklkVG9OZXdJZE1hcFt0aGlzLmNoYW5nZUZpZWxkc1tmaWVsZF1dO1xuICAgICAgICAgICAgaWYgKG5ld0NvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VGaWVsZHNbZmllbGRdID0gbmV3Q29kZWJhc2VJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRKc3hDaGFuZ2UgPSBBZGRKc3hDaGFuZ2U7XG5jbGFzcyBNb3ZlSnN4Q2hhbmdlIGV4dGVuZHMgQ2hhbmdlTGVkZ2VySXRlbSB7XG4gICAgY29uc3RydWN0b3IoY2hhbmdlRmllbGRzLCBpZCkge1xuICAgICAgICBzdXBlcihDaGFuZ2VUeXBlLk1PVkVfSlNYLCAnTW92ZSBFbGVtZW50JywgY2hhbmdlRmllbGRzLCBpZCk7XG4gICAgfVxuICAgIHByZXBhcmVBcGlSZXF1ZXN0KGNhbnZhc0lkLCB0cmVlRWxlbWVudExvb2t1cCwgYWN0aXZlQ2FudmFzKSB7XG4gICAgICAgIGNvbnN0IHsgY29kZWJhc2VJZFRvTW92ZVRvLCBjb2RlYmFzZUlkVG9Nb3ZlLCBhZnRlckNvZGViYXNlSWQsIGJlZm9yZUNvZGViYXNlSWQsIGV4cGVjdGVkQ3VycmVudFBhcmVudENvZGViYXNlSWQsIH0gPSB0aGlzLmNoYW5nZUZpZWxkcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybFBhdGg6IGBjYW52YXNlcy8ke2NhbnZhc0lkfS9wYXJzZUFuZE11dGF0ZS9tdXRhdGUvbW92ZUpzeEVsZW1lbnRgLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRUb01vdmU6IHRyZWVFbGVtZW50TG9va3VwW2NvZGViYXNlSWRUb01vdmVdLFxuICAgICAgICAgICAgICAgIG5ld0NvbnRhaW5lckVsZW1lbnQ6IHRyZWVFbGVtZW50TG9va3VwW2NvZGViYXNlSWRUb01vdmVUb10sXG4gICAgICAgICAgICAgICAgYWZ0ZXJFbGVtZW50OiB0cmVlRWxlbWVudExvb2t1cFthZnRlckNvZGViYXNlSWQgfHwgJyddLFxuICAgICAgICAgICAgICAgIGJlZm9yZUVsZW1lbnQ6IHRyZWVFbGVtZW50TG9va3VwW2JlZm9yZUNvZGViYXNlSWQgfHwgJyddLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ3VycmVudFBhcmVudDogdHJlZUVsZW1lbnRMb29rdXBbZXhwZWN0ZWRDdXJyZW50UGFyZW50Q29kZWJhc2VJZCB8fCAnJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBseUNvZGViYXNlSWRDaGFuZ2VzKHByZXZJZFRvTmV3SWRNYXApIHtcbiAgICAgICAgY29uc3QgZmllbGRzVG9BcHBseSA9IFtcbiAgICAgICAgICAgICdjb2RlYmFzZUlkVG9Nb3ZlVG8nLFxuICAgICAgICAgICAgJ2NvZGViYXNlSWRUb01vdmUnLFxuICAgICAgICAgICAgJ2FmdGVyQ29kZWJhc2VJZCcsXG4gICAgICAgICAgICAnYmVmb3JlQ29kZWJhc2VJZCcsXG4gICAgICAgICAgICAnZXhwZWN0ZWRDdXJyZW50UGFyZW50Q29kZWJhc2VJZCcsXG4gICAgICAgIF07XG4gICAgICAgIGZpZWxkc1RvQXBwbHkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvZGViYXNlSWQgPSBwcmV2SWRUb05ld0lkTWFwW3RoaXMuY2hhbmdlRmllbGRzW2ZpZWxkXV07XG4gICAgICAgICAgICBpZiAobmV3Q29kZWJhc2VJZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUZpZWxkc1tmaWVsZF0gPSBuZXdDb2RlYmFzZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk1vdmVKc3hDaGFuZ2UgPSBNb3ZlSnN4Q2hhbmdlO1xuY2xhc3MgUmVtb3ZlSnN4Q2hhbmdlIGV4dGVuZHMgQ2hhbmdlTGVkZ2VySXRlbSB7XG4gICAgY29uc3RydWN0b3IoY2hhbmdlRmllbGRzLCBpZCkge1xuICAgICAgICAvLyBEZWR1cGxpY2F0ZSB0aGUgY29kZWJhc2VJZHNUb1JlbW92ZVxuICAgICAgICBjaGFuZ2VGaWVsZHMuY29kZWJhc2VJZHNUb1JlbW92ZSA9IEFycmF5LmZyb20obmV3IFNldChjaGFuZ2VGaWVsZHMuY29kZWJhc2VJZHNUb1JlbW92ZSkpO1xuICAgICAgICBzdXBlcihDaGFuZ2VUeXBlLlJFTU9WRV9KU1gsICdEZWxldGUgRWxlbWVudCcsIGNoYW5nZUZpZWxkcywgaWQpO1xuICAgIH1cbiAgICBwcmVwYXJlQXBpUmVxdWVzdChjYW52YXNJZCwgdHJlZUVsZW1lbnRMb29rdXAsIGFjdGl2ZUNhbnZhcykge1xuICAgICAgICBjb25zdCB7IGNvZGViYXNlSWRzVG9SZW1vdmUgfSA9IHRoaXMuY2hhbmdlRmllbGRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsUGF0aDogYGNhbnZhc2VzLyR7Y2FudmFzSWR9L3BhcnNlQW5kTXV0YXRlL211dGF0ZS9yZW1vdmVKc3hFbGVtZW50YCxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlOiBjb2RlYmFzZUlkc1RvUmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGNvZGViYXNlSWQpID0+IHRyZWVFbGVtZW50TG9va3VwW2NvZGViYXNlSWRdKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlbGVtZW50KSA9PiBlbGVtZW50KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5Q29kZWJhc2VJZENoYW5nZXMocHJldklkVG9OZXdJZE1hcCkge1xuICAgICAgICB0aGlzLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkc1RvUmVtb3ZlID1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRmllbGRzLmNvZGViYXNlSWRzVG9SZW1vdmUubWFwKChjb2RlYmFzZUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29kZWJhc2VJZCA9IHByZXZJZFRvTmV3SWRNYXBbY29kZWJhc2VJZF07XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvZGViYXNlSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlYmFzZUlkO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZW1vdmVKc3hDaGFuZ2UgPSBSZW1vdmVKc3hDaGFuZ2U7XG5jbGFzcyBDaGFuZ2VQcm9wQ2hhbmdlIGV4dGVuZHMgQ2hhbmdlTGVkZ2VySXRlbSB7XG4gICAgY29uc3RydWN0b3IoY2hhbmdlRmllbGRzLCBpZCkge1xuICAgICAgICBzdXBlcihDaGFuZ2VUeXBlLkNIQU5HRV9QUk9QLCAnQ2hhbmdlIFByb3AnLCBjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICB9XG4gICAgcHJlcGFyZUFwaVJlcXVlc3QoY2FudmFzSWQsIHRyZWVFbGVtZW50TG9va3VwLCBhY3RpdmVDYW52YXMpIHtcbiAgICAgICAgY29uc3QgeyBjb2RlYmFzZUlkVG9DaGFuZ2UsIHByb3BOYW1lLCBwcm9wVmFsdWUgfSA9IHRoaXMuY2hhbmdlRmllbGRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsUGF0aDogYGNhbnZhc2VzLyR7Y2FudmFzSWR9L3BhcnNlQW5kTXV0YXRlL211dGF0ZS9jaGFuZ2VQcm9wVmFsdWVgLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRUb01vZGlmeTogdHJlZUVsZW1lbnRMb29rdXBbY29kZWJhc2VJZFRvQ2hhbmdlXSxcbiAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2Vzc1RvYXN0TWVzc2FnZTogJ1Byb3AgY2hhbmdlZCcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5Q29kZWJhc2VJZENoYW5nZXMocHJldklkVG9OZXdJZE1hcCkge1xuICAgICAgICBjb25zdCBuZXdDb2RlYmFzZUlkID0gcHJldklkVG9OZXdJZE1hcFt0aGlzLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9DaGFuZ2VdO1xuICAgICAgICBpZiAobmV3Q29kZWJhc2VJZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VGaWVsZHMuY29kZWJhc2VJZFRvQ2hhbmdlID0gbmV3Q29kZWJhc2VJZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbmdlUHJvcENoYW5nZSA9IENoYW5nZVByb3BDaGFuZ2U7XG5jbGFzcyBXcmFwRGl2Q2hhbmdlIGV4dGVuZHMgQ2hhbmdlTGVkZ2VySXRlbSB7XG4gICAgY29uc3RydWN0b3IoY2hhbmdlRmllbGRzLCBpZCkge1xuICAgICAgICAvLyBEZWR1cGxpY2F0ZSB0aGUgY29kZWJhc2VJZHNUb1dyYXBcbiAgICAgICAgY2hhbmdlRmllbGRzLmNvZGViYXNlSWRzVG9XcmFwID0gQXJyYXkuZnJvbShuZXcgU2V0KGNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkc1RvV3JhcCkpO1xuICAgICAgICBzdXBlcihDaGFuZ2VUeXBlLldSQVBfRElWLCAnV3JhcCBJbiBEaXYnLCBjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICB9XG4gICAgcHJlcGFyZUFwaVJlcXVlc3QoY2FudmFzSWQsIHRyZWVFbGVtZW50TG9va3VwLCBhY3RpdmVDYW52YXMpIHtcbiAgICAgICAgY29uc3QgeyBjb2RlYmFzZUlkc1RvV3JhcCB9ID0gdGhpcy5jaGFuZ2VGaWVsZHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmxQYXRoOiBgY2FudmFzZXMvJHtjYW52YXNJZH0vcGFyc2VBbmRNdXRhdGUvbXV0YXRlL3dyYXBJbkRpdmAsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgcmVhY3RFbGVtZW50czogY29kZWJhc2VJZHNUb1dyYXAubWFwKChjb2RlYmFzZUlkKSA9PiB0cmVlRWxlbWVudExvb2t1cFtjb2RlYmFzZUlkXSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBseUNvZGViYXNlSWRDaGFuZ2VzKHByZXZJZFRvTmV3SWRNYXApIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VGaWVsZHMuY29kZWJhc2VJZHNUb1dyYXAgPVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VGaWVsZHMuY29kZWJhc2VJZHNUb1dyYXAubWFwKChjb2RlYmFzZUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29kZWJhc2VJZCA9IHByZXZJZFRvTmV3SWRNYXBbY29kZWJhc2VJZF07XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvZGViYXNlSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlYmFzZUlkO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5XcmFwRGl2Q2hhbmdlID0gV3JhcERpdkNoYW5nZTtcbmNsYXNzIER1cGxpY2F0ZUNoYW5nZSBleHRlbmRzIENoYW5nZUxlZGdlckl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZUZpZWxkcywgaWQpIHtcbiAgICAgICAgLy8gRGVkdXBsaWNhdGUgdGhlIGNvZGViYXNlSWRzVG9EdXBsaWNhdGVcbiAgICAgICAgY2hhbmdlRmllbGRzLmNvZGViYXNlSWRzVG9EdXBsaWNhdGUgPSBBcnJheS5mcm9tKG5ldyBTZXQoY2hhbmdlRmllbGRzLmNvZGViYXNlSWRzVG9EdXBsaWNhdGUpKTtcbiAgICAgICAgc3VwZXIoQ2hhbmdlVHlwZS5EVVBMSUNBVEUsICdEdXBsaWNhdGUnLCBjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICB9XG4gICAgcHJlcGFyZUFwaVJlcXVlc3QoY2FudmFzSWQsIHRyZWVFbGVtZW50TG9va3VwLCBhY3RpdmVDYW52YXMpIHtcbiAgICAgICAgY29uc3QgeyBjb2RlYmFzZUlkc1RvRHVwbGljYXRlIH0gPSB0aGlzLmNoYW5nZUZpZWxkcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybFBhdGg6IGBjYW52YXNlcy8ke2NhbnZhc0lkfS9wYXJzZUFuZE11dGF0ZS9tdXRhdGUvZHVwbGljYXRlYCxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICByZWFjdEVsZW1lbnRzOiBjb2RlYmFzZUlkc1RvRHVwbGljYXRlLm1hcCgoY29kZWJhc2VJZCkgPT4gdHJlZUVsZW1lbnRMb29rdXBbY29kZWJhc2VJZF0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwbHlDb2RlYmFzZUlkQ2hhbmdlcyhwcmV2SWRUb05ld0lkTWFwKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlRmllbGRzLmNvZGViYXNlSWRzVG9EdXBsaWNhdGUgPVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VGaWVsZHMuY29kZWJhc2VJZHNUb0R1cGxpY2F0ZS5tYXAoKGNvZGViYXNlSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2RlYmFzZUlkID0gcHJldklkVG9OZXdJZE1hcFtjb2RlYmFzZUlkXTtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q29kZWJhc2VJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q29kZWJhc2VJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGViYXNlSWQ7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkR1cGxpY2F0ZUNoYW5nZSA9IER1cGxpY2F0ZUNoYW5nZTtcbmNsYXNzIENoYW5nZVRhZ0NoYW5nZSBleHRlbmRzIENoYW5nZUxlZGdlckl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZUZpZWxkcywgaWQpIHtcbiAgICAgICAgc3VwZXIoQ2hhbmdlVHlwZS5DSEFOR0VfVEFHLCAnQ2hhbmdlIFRhZyBOYW1lJywgY2hhbmdlRmllbGRzLCBpZCk7XG4gICAgfVxuICAgIHByZXBhcmVBcGlSZXF1ZXN0KGNhbnZhc0lkLCB0cmVlRWxlbWVudExvb2t1cCwgYWN0aXZlQ2FudmFzKSB7XG4gICAgICAgIGNvbnN0IHsgY29kZWJhc2VJZFRvQ2hhbmdlLCBuZXdUYWdOYW1lIH0gPSB0aGlzLmNoYW5nZUZpZWxkcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybFBhdGg6IGBjYW52YXNlcy8ke2NhbnZhc0lkfS9wYXJzZUFuZE11dGF0ZS9tdXRhdGUvY2hhbmdlRWxlbWVudFRhZ2AsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFRvTW9kaWZ5OiB0cmVlRWxlbWVudExvb2t1cFtjb2RlYmFzZUlkVG9DaGFuZ2VdLFxuICAgICAgICAgICAgICAgIG5ld1RhZzogbmV3VGFnTmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5Q29kZWJhc2VJZENoYW5nZXMocHJldklkVG9OZXdJZE1hcCkge1xuICAgICAgICBjb25zdCBuZXdDb2RlYmFzZUlkID0gcHJldklkVG9OZXdJZE1hcFt0aGlzLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9DaGFuZ2VdO1xuICAgICAgICBpZiAobmV3Q29kZWJhc2VJZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VGaWVsZHMuY29kZWJhc2VJZFRvQ2hhbmdlID0gbmV3Q29kZWJhc2VJZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbmdlVGFnQ2hhbmdlID0gQ2hhbmdlVGFnQ2hhbmdlO1xuY2xhc3MgQWRkQ2xhc3NDaGFuZ2UgZXh0ZW5kcyBDaGFuZ2VMZWRnZXJJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VGaWVsZHMsIGlkKSB7XG4gICAgICAgIHN1cGVyKENoYW5nZVR5cGUuQUREX0NMQVNTLCAnQWRkIENsYXNzJywgY2hhbmdlRmllbGRzLCBpZCk7XG4gICAgICAgIHRoaXMuY2FuSW5zdGFudFVwZGF0ZVdoaWxlRmx1c2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBwcmVwYXJlQXBpUmVxdWVzdChjYW52YXNJZCwgdHJlZUVsZW1lbnRMb29rdXAsIGFjdGl2ZUNhbnZhcykge1xuICAgICAgICBjb25zdCB7IGNvZGViYXNlSWRUb0FkZENsYXNzLCBjbGFzc05hbWUsIGFkZGluZ1RhaWx3aW5kQ2xhc3MsIG1vZGlmaWVycywgY3VzdG9tUHJvcGVydGllcywgfSA9IHRoaXMuY2hhbmdlRmllbGRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsUGF0aDogYGNhbnZhc2VzLyR7Y2FudmFzSWR9L3BhcnNlQW5kTXV0YXRlL211dGF0ZS9hZGRDbGFzc2AsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgcmVhY3RFbGVtZW50OiB0cmVlRWxlbWVudExvb2t1cFtjb2RlYmFzZUlkVG9BZGRDbGFzc10sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHN0eWxpbmdGcmFtZXdvcms6IGFkZGluZ1RhaWx3aW5kQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgPyBTdHlsaW5nRnJhbWV3b3JrLlRBSUxXSU5EXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgY3VzdG9tUHJvcGVydGllcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5Q29kZWJhc2VJZENoYW5nZXMocHJldklkVG9OZXdJZE1hcCkge1xuICAgICAgICBjb25zdCBuZXdDb2RlYmFzZUlkID0gcHJldklkVG9OZXdJZE1hcFt0aGlzLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9BZGRDbGFzc107XG4gICAgICAgIGlmIChuZXdDb2RlYmFzZUlkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9BZGRDbGFzcyA9IG5ld0NvZGViYXNlSWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFkZENsYXNzQ2hhbmdlID0gQWRkQ2xhc3NDaGFuZ2U7XG5jbGFzcyBSZW1vdmVDbGFzc0NoYW5nZSBleHRlbmRzIENoYW5nZUxlZGdlckl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZUZpZWxkcywgaWQpIHtcbiAgICAgICAgc3VwZXIoQ2hhbmdlVHlwZS5SRU1PVkVfQ0xBU1MsICdSZW1vdmUgQ2xhc3MnLCBjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICB9XG4gICAgcHJlcGFyZUFwaVJlcXVlc3QoY2FudmFzSWQsIHRyZWVFbGVtZW50TG9va3VwLCBhY3RpdmVDYW52YXMpIHtcbiAgICAgICAgY29uc3QgeyBjb2RlYmFzZUlkVG9SZW1vdmVDbGFzcywgY2xhc3NOYW1lIH0gPSB0aGlzLmNoYW5nZUZpZWxkcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybFBhdGg6IGBjYW52YXNlcy8ke2NhbnZhc0lkfS9wYXJzZUFuZE11dGF0ZS9tdXRhdGUvcmVtb3ZlQ2xhc3NgLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIHJlYWN0RWxlbWVudDogdHJlZUVsZW1lbnRMb29rdXBbY29kZWJhc2VJZFRvUmVtb3ZlQ2xhc3NdLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5Q29kZWJhc2VJZENoYW5nZXMocHJldklkVG9OZXdJZE1hcCkge1xuICAgICAgICBjb25zdCBuZXdDb2RlYmFzZUlkID0gcHJldklkVG9OZXdJZE1hcFt0aGlzLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9SZW1vdmVDbGFzc107XG4gICAgICAgIGlmIChuZXdDb2RlYmFzZUlkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZUZpZWxkcy5jb2RlYmFzZUlkVG9SZW1vdmVDbGFzcyA9IG5ld0NvZGViYXNlSWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlbW92ZUNsYXNzQ2hhbmdlID0gUmVtb3ZlQ2xhc3NDaGFuZ2U7XG5jbGFzcyBFZGl0VGV4dENoYW5nZSBleHRlbmRzIENoYW5nZUxlZGdlckl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZUZpZWxkcywgaWQpIHtcbiAgICAgICAgc3VwZXIoQ2hhbmdlVHlwZS5FRElUX1RFWFQsICdFZGl0IFRleHQnLCBjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICB9XG4gICAgcHJlcGFyZUFwaVJlcXVlc3QoY2FudmFzSWQsIHRyZWVFbGVtZW50TG9va3VwLCBhY3RpdmVDYW52YXMpIHtcbiAgICAgICAgY29uc3QgeyBjb2RlYmFzZUlkVG9FZGl0VGV4dCwgbmV3VGV4dCwgb2xkVGV4dCB9ID0gdGhpcy5jaGFuZ2VGaWVsZHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmxQYXRoOiBgY2FudmFzZXMvJHtjYW52YXNJZH0vcGFyc2VBbmRNdXRhdGUvbXV0YXRlL2VkaXRUZXh0YCxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0cmVlRWxlbWVudExvb2t1cFtjb2RlYmFzZUlkVG9FZGl0VGV4dF0sXG4gICAgICAgICAgICAgICAgbmV3VGV4dCxcbiAgICAgICAgICAgICAgICBvbGRUZXh0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwbHlDb2RlYmFzZUlkQ2hhbmdlcyhwcmV2SWRUb05ld0lkTWFwKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvZGViYXNlSWQgPSBwcmV2SWRUb05ld0lkTWFwW3RoaXMuY2hhbmdlRmllbGRzLmNvZGViYXNlSWRUb0VkaXRUZXh0XTtcbiAgICAgICAgaWYgKG5ld0NvZGViYXNlSWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRmllbGRzLmNvZGViYXNlSWRUb0VkaXRUZXh0ID0gbmV3Q29kZWJhc2VJZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRWRpdFRleHRDaGFuZ2UgPSBFZGl0VGV4dENoYW5nZTtcbmNsYXNzIFVuZG9DaGFuZ2UgZXh0ZW5kcyBDaGFuZ2VMZWRnZXJJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VGaWVsZHMsIGlkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoQ2hhbmdlVHlwZS5VTkRPLCAnVW5kbycsIGNoYW5nZUZpZWxkcywgaWQpO1xuICAgICAgICBpZiAoKF9hID0gY2hhbmdlRmllbGRzLmNoYW5nZVRvVW5kbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbkluc3RhbnRVcGRhdGVXaGlsZUZsdXNoaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNhbkluc3RhbnRVcGRhdGVXaGlsZUZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlQXBpUmVxdWVzdChjYW52YXNJZCwgdHJlZUVsZW1lbnRMb29rdXAsIGFjdGl2ZUNhbnZhcykge1xuICAgICAgICBjb25zdCB7IGNoYW5nZVRvVW5kbyB9ID0gdGhpcy5jaGFuZ2VGaWVsZHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmxQYXRoOiBgY2FudmFzZXMvJHtjYW52YXNJZH0vcGFyc2VBbmRNdXRhdGUvYWN0aXZpdGllcy91bmRvQ2hhbmdlVG9GaWxlc2AsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0VXVpZDogY2hhbmdlVG9VbmRvLmFjdGl2aXR5SWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBseUNvZGViYXNlSWRDaGFuZ2VzKHByZXZJZFRvTmV3SWRNYXApIHtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cbn1cbmV4cG9ydHMuVW5kb0NoYW5nZSA9IFVuZG9DaGFuZ2U7XG5jbGFzcyBSZWRvQ2hhbmdlIGV4dGVuZHMgQ2hhbmdlTGVkZ2VySXRlbSB7XG4gICAgY29uc3RydWN0b3IoY2hhbmdlRmllbGRzLCBpZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKENoYW5nZVR5cGUuUkVETywgJ1JlZG8nLCBjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICAgICAgaWYgKChfYSA9IGNoYW5nZUZpZWxkcy5jaGFuZ2VUb1JlZG8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5JbnN0YW50VXBkYXRlV2hpbGVGbHVzaGluZykge1xuICAgICAgICAgICAgdGhpcy5jYW5JbnN0YW50VXBkYXRlV2hpbGVGbHVzaGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUFwaVJlcXVlc3QoY2FudmFzSWQsIHRyZWVFbGVtZW50TG9va3VwLCBhY3RpdmVDYW52YXMpIHtcbiAgICAgICAgY29uc3QgeyBjaGFuZ2VUb1JlZG8gfSA9IHRoaXMuY2hhbmdlRmllbGRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsUGF0aDogYGNhbnZhc2VzLyR7Y2FudmFzSWR9L3BhcnNlQW5kTXV0YXRlL2FjdGl2aXRpZXMvcmVkb0NoYW5nZVRvRmlsZXNgLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIGNoYW5nZVRvUmVkb0lkOiBjaGFuZ2VUb1JlZG8uYWN0aXZpdHlJZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5Q29kZWJhc2VJZENoYW5nZXMocHJldklkVG9OZXdJZE1hcCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxufVxuZXhwb3J0cy5SZWRvQ2hhbmdlID0gUmVkb0NoYW5nZTtcbmNsYXNzIFVua25vd25DaGFuZ2UgZXh0ZW5kcyBDaGFuZ2VMZWRnZXJJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VGaWVsZHMsIGlkKSB7XG4gICAgICAgIHN1cGVyKENoYW5nZVR5cGUuVU5LTk9XTiwgJycsIGNoYW5nZUZpZWxkcywgaWQpO1xuICAgICAgICAvLyBEbyBub3QgcHJvY2VzcyB1bmtub3duIGNoYW5nZXNcbiAgICAgICAgdGhpcy5tYXJrUHJvY2Vzc2VkU3VjY2VlZGVkKCk7XG4gICAgICAgIHRoaXMuZG9Ob3RTZW5kSW5zdGFudFVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcmVwYXJlQXBpUmVxdWVzdChjYW52YXNJZCwgdHJlZUVsZW1lbnRMb29rdXAsIGFjdGl2ZUNhbnZhcykge1xuICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgb3BlcmF0aW9uJyk7XG4gICAgICAgIC8vIEZvciB0eXBpbmdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybFBhdGg6IGBgLFxuICAgICAgICAgICAgYm9keToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5Q29kZWJhc2VJZENoYW5nZXMocHJldklkVG9OZXdJZE1hcCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxufVxuZXhwb3J0cy5Vbmtub3duQ2hhbmdlID0gVW5rbm93bkNoYW5nZTtcbi8qKlxuICogV2hlbiBzZXJpYWxpemluZyBhIGNoYW5nZSBsZWRnZXIgaXRlbSB0byBhIHBsYWluIEpTIG9iamVjdCwgdGhlIGNsYXNzIGZ1bmN0aW9uc1xuICogYXJlIGxvc3QuIFRoaXMgcmVjcmVhdGVzIHRoZSBjaGFuZ2UgaXRlbSB0aGF0IHdhcyBsb3N0XG4gKi9cbmNvbnN0IHJlY29uc3RydWN0Q2hhbmdlTGVkZ2VyQ2xhc3MgPSAocGxhaW5Kc09iamVjdCkgPT4ge1xuICAgIGlmICghcGxhaW5Kc09iamVjdCB8fCAhcGxhaW5Kc09iamVjdC50eXBlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VUeXBlID0gcGxhaW5Kc09iamVjdC50eXBlO1xuICAgIGNvbnN0IGNoYW5nZUZpZWxkcyA9IHBsYWluSnNPYmplY3QuY2hhbmdlRmllbGRzO1xuICAgIGNvbnN0IGlkID0gcGxhaW5Kc09iamVjdC5pZDtcbiAgICBjb25zdCBnZXRDaGFuZ2VGb3JUeXBlID0gKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGNoYW5nZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ2hhbmdlVHlwZS5TVFlMSU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3R5bGluZ0NoYW5nZShjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICAgICAgICAgIGNhc2UgQ2hhbmdlVHlwZS5BRERfSlNYOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkSnN4Q2hhbmdlKGNoYW5nZUZpZWxkcywgaWQpO1xuICAgICAgICAgICAgY2FzZSBDaGFuZ2VUeXBlLlJFTU9WRV9KU1g6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVKc3hDaGFuZ2UoY2hhbmdlRmllbGRzLCBpZCk7XG4gICAgICAgICAgICBjYXNlIENoYW5nZVR5cGUuTU9WRV9KU1g6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb3ZlSnN4Q2hhbmdlKGNoYW5nZUZpZWxkcywgaWQpO1xuICAgICAgICAgICAgY2FzZSBDaGFuZ2VUeXBlLkNIQU5HRV9QUk9QOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbmdlUHJvcENoYW5nZShjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICAgICAgICAgIGNhc2UgQ2hhbmdlVHlwZS5BRERfQ0xBU1M6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRDbGFzc0NoYW5nZShjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICAgICAgICAgIGNhc2UgQ2hhbmdlVHlwZS5SRU1PVkVfQ0xBU1M6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVDbGFzc0NoYW5nZShjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICAgICAgICAgIGNhc2UgQ2hhbmdlVHlwZS5XUkFQX0RJVjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdyYXBEaXZDaGFuZ2UoY2hhbmdlRmllbGRzLCBpZCk7XG4gICAgICAgICAgICBjYXNlIENoYW5nZVR5cGUuQ0hBTkdFX1RBRzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoYW5nZVRhZ0NoYW5nZShjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICAgICAgICAgIGNhc2UgQ2hhbmdlVHlwZS5EVVBMSUNBVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEdXBsaWNhdGVDaGFuZ2UoY2hhbmdlRmllbGRzLCBpZCk7XG4gICAgICAgICAgICBjYXNlIENoYW5nZVR5cGUuRURJVF9URVhUOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRWRpdFRleHRDaGFuZ2UoY2hhbmdlRmllbGRzLCBpZCk7XG4gICAgICAgICAgICBjYXNlIENoYW5nZVR5cGUuVU5ETzpcbiAgICAgICAgICAgICAgICBjaGFuZ2VGaWVsZHMuY2hhbmdlVG9VbmRvID0gKDAsIGV4cG9ydHMucmVjb25zdHJ1Y3RDaGFuZ2VMZWRnZXJDbGFzcykoY2hhbmdlRmllbGRzLmNoYW5nZVRvVW5kbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRvQ2hhbmdlKGNoYW5nZUZpZWxkcywgaWQpO1xuICAgICAgICAgICAgY2FzZSBDaGFuZ2VUeXBlLlJFRE86XG4gICAgICAgICAgICAgICAgY2hhbmdlRmllbGRzLmNoYW5nZVRvUmVkbyA9ICgwLCBleHBvcnRzLnJlY29uc3RydWN0Q2hhbmdlTGVkZ2VyQ2xhc3MpKGNoYW5nZUZpZWxkcy5jaGFuZ2VUb1JlZG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVkb0NoYW5nZShjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICAgICAgICAgIGNhc2UgQ2hhbmdlVHlwZS5VTktOT1dOOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5rbm93bkNoYW5nZShjaGFuZ2VGaWVsZHMsIGlkKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNoYW5nZSB0eXBlOiAke2NoYW5nZVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFNldCBhbGwgdGhlIG90aGVyIGZpZWxkcyBvbiB0aGUgY2hhbmdlIG9iamVjdFxuICAgIGNvbnN0IGNoYW5nZSA9IGdldENoYW5nZUZvclR5cGUoKTtcbiAgICBPYmplY3Qua2V5cyhwbGFpbkpzT2JqZWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKFsndHlwZScsICdjaGFuZ2VGaWVsZHMnLCAnaWQnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjaGFuZ2Vba2V5XSA9IHBsYWluSnNPYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbmdlO1xufTtcbmV4cG9ydHMucmVjb25zdHJ1Y3RDaGFuZ2VMZWRnZXJDbGFzcyA9IHJlY29uc3RydWN0Q2hhbmdlTGVkZ2VyQ2xhc3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/changeLedgerTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/channelMessagingFunctions.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/channelMessagingFunctions.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initChannelMessagingFunctions = void 0;\nconst identifierUtils_1 = __webpack_require__(/*! ./identifierUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js\");\nconst sessionStorageUtils_1 = __webpack_require__(/*! ./sessionStorageUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js\");\nconst navTreeUtils_1 = __webpack_require__(/*! ./navTreeUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/navTreeUtils.js\");\n// @ts-ignore\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\"));\nconst lodash_1 = __importDefault(__webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\"));\nconst outlineUtils_1 = __webpack_require__(/*! ./outlineUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/outlineUtils.js\");\nconst cssFunctions_1 = __webpack_require__(/*! ./cssFunctions */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssFunctions.js\");\nconst constantsAndTypes_1 = __webpack_require__(/*! ./constantsAndTypes */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/constantsAndTypes.js\");\nconst changeItemFunctions_1 = __webpack_require__(/*! ./changeItemFunctions */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/changeItemFunctions.js\");\nconst resqUtils_1 = __webpack_require__(/*! ./resqUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/resqUtils.js\");\nconst tempoElement_1 = __webpack_require__(/*! ./tempoElement */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js\");\nconst editTextUtils_1 = __webpack_require__(/*! ./editTextUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/editTextUtils.js\");\nconst PIXELS_TO_MOVE_BEFORE_DRAG = 20;\nconst IMMEDIATELY_REMOVE_POINTER_LOCK = 'IMMEDIATELY_REMOVE_POINTER_LOCK';\nconst LAST_NAV_TREE_REFRESH_TIME = 'LAST_NAV_TREE_REFRESH_TIME';\n// TODO: Change all of this to be a react wrapper library\nconst initChannelMessagingFunctions = () => {\n    // @ts-ignore\n    String.prototype.hashCode = function () {\n        var hash = 0, i, chr;\n        if (this.length === 0)\n            return hash;\n        for (i = 0; i < this.length; i++) {\n            chr = this.charCodeAt(i);\n            hash = (hash << 5) - hash + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    };\n    // We want to make event listeners non-passive, and to do so have to check\n    // that browsers support EventListenerOptions in the first place.\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n    let passiveSupported = false;\n    const makePassiveEventOption = () => {\n        try {\n            const options = {\n                get passive() {\n                    // This function will be called when the browser\n                    //   attempts to access the passive property.\n                    passiveSupported = true;\n                    return false;\n                },\n            };\n            return options;\n        }\n        catch (err) {\n            passiveSupported = false;\n            return passiveSupported;\n        }\n    };\n    /**\n     * Taken from: https://stackoverflow.com/questions/3219758/detect-changes-in-the-dom\n     *\n     * Returns the function to disconnect the observer\n     */\n    const observeDOM = (function () {\n        // @ts-ignore\n        var MutationObserver = \n        // @ts-ignore\n        window.MutationObserver || window.WebKitMutationObserver;\n        return function (obj, callback) {\n            if (!obj || obj.nodeType !== 1)\n                return () => { };\n            if (MutationObserver) {\n                // define a new observer\n                var mutationObserver = new MutationObserver(callback);\n                // have the observer observe foo for changes in children\n                mutationObserver.observe(obj, {\n                    childList: true,\n                    subtree: true,\n                    attributes: true,\n                });\n                return () => {\n                    mutationObserver.disconnect();\n                };\n            }\n            // browser support fallback\n            // @ts-ignore\n            else if (window.addEventListener) {\n                obj.addEventListener('DOMNodeInserted', callback, false);\n                obj.addEventListener('DOMNodeRemoved', callback, false);\n                return () => {\n                    obj.removeEventListener('DOMNodeInserted', callback, false);\n                    obj.removeEventListener('DOMNodeRemoved', callback, false);\n                };\n            }\n            return () => { };\n        };\n    })();\n    /**\n     * When selecting in normal mode (not meta key), can select one level down, a sibling\n     * or a parent of the selected element\n     */\n    const getSelectableNavNode = (e) => {\n        const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE);\n        // Move up the tree until you find the first valid nav node\n        let firstNavNode = null;\n        let searchNode = e.target;\n        while (searchNode && !firstNavNode) {\n            firstNavNode =\n                elementKeyToNavNode[(0, identifierUtils_1.getElementKeyFromNode)(searchNode) || ''];\n            searchNode = searchNode.parentElement;\n        }\n        if (!firstNavNode) {\n            return constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD;\n        }\n        const isNavNodeMatch = (navTreeNode) => {\n            var _a, _b, _c, _d;\n            if (selectedElement.isEmpty()) {\n                // This function cannot be called if there is no selected element, see code logic below the function\n                throw Error('No selected element when isNavNodeMatch called');\n            }\n            if (!navTreeNode) {\n                return false;\n            }\n            // If there is no codebase ID it should not be selectable as there is nothing we can do with it\n            if (!navTreeNode.tempoElement.codebaseId.startsWith('tempo-') ||\n                navTreeNode.tempoElement.codebaseId === navTreeUtils_1.SKIP_ROOT_CODEBASE_ID) {\n                return false;\n            }\n            // If it matches, we already passed all possible children, so re-select it\n            if (selectedElement.isEqual(navTreeNode.tempoElement)) {\n                return true;\n            }\n            // Any parent is ok to select\n            if (navTreeNode.tempoElement.isParentOf(selectedElement)) {\n                return true;\n            }\n            // Check parents\n            // Pick the first parent with a codebase ID\n            let parent = navTreeNode.parent;\n            while (parent && !parent.tempoElement.codebaseId.startsWith('tempo-')) {\n                parent = parent.parent;\n            }\n            // One level down\n            if ((_a = parent === null || parent === void 0 ? void 0 : parent.tempoElement) === null || _a === void 0 ? void 0 : _a.isEqual(selectedElement)) {\n                return true;\n            }\n            // Sibling of any parent\n            const selectedNode = elementKeyToNavNode[selectedElement.getKey()];\n            if (selectedNode &&\n                ((_d = (_c = (_b = navTreeNode.parent) === null || _b === void 0 ? void 0 : _b.children) === null || _c === void 0 ? void 0 : _c.includes) === null || _d === void 0 ? void 0 : _d.call(_c, selectedNode))) {\n                return true;\n            }\n            return false;\n        };\n        let foundNavNode = null;\n        let searchNavNode = firstNavNode;\n        while (searchNavNode) {\n            if (!selectedElement.isEmpty() && !selectedElement.isStoryboard()) {\n                // If there is a selected element key loop from this element up the stack to find the element that is the direct child\n                // of the expected selected element, so that you can only hover one level deeper than you've selected\n                if (isNavNodeMatch(searchNavNode)) {\n                    foundNavNode = searchNavNode;\n                    // Exit the loop as we found the node that matches\n                    break;\n                }\n            }\n            else {\n                // If there is no selected element key, or the selection is the storyboard itself, loop up to the top-most element with a codebase ID\n                if (searchNavNode.tempoElement.codebaseId &&\n                    searchNavNode.tempoElement.codebaseId.startsWith('tempo-')) {\n                    foundNavNode = searchNavNode;\n                    // Note: we do not exit the loop here as we want to keep searching for the top-most element\n                }\n            }\n            searchNavNode = searchNavNode.parent;\n        }\n        return foundNavNode || null;\n    };\n    const onPointerOver = (e, parentPort, storyboardId, selectBottomMostElement) => {\n        const passedThrough = passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        const editingTextInfo = (0, editTextUtils_1.getEditingInfo)();\n        // Allow on pointer over events if editing (so we can click out)\n        if (e.altKey || (passedThrough && !editingTextInfo)) {\n            return;\n        }\n        if ((0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext')) {\n            return;\n        }\n        const currentHoveredKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);\n        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};\n        let hoveredNavNode;\n        if (e.metaKey || e.ctrlKey || selectBottomMostElement) {\n            const elementKey = (0, identifierUtils_1.getElementKeyFromNode)(e.target);\n            hoveredNavNode = elementKeyToNavNode[elementKey];\n            // Special case -> this is the top-most node so it should trigger a hover on the storyboard\n            if (!hoveredNavNode && e.target.parentNode === document.body) {\n                hoveredNavNode = constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD;\n            }\n        }\n        else {\n            hoveredNavNode = getSelectableNavNode(e);\n        }\n        const currentSelectedKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        const currentSelectedElement = tempoElement_1.TempoElement.fromKey(currentSelectedKey);\n        // If the user is holding shift, only allow selecting siblings\n        if (e.shiftKey && hoveredNavNode && currentSelectedKey) {\n            // Trying to select the entire storyboard, allow only if the other selected element is also a storyboard\n            if (typeof hoveredNavNode === 'string' &&\n                !currentSelectedElement.isStoryboard()) {\n                hoveredNavNode = null;\n            }\n            if (typeof hoveredNavNode !== 'string' &&\n                !(hoveredNavNode === null || hoveredNavNode === void 0 ? void 0 : hoveredNavNode.tempoElement.isSiblingOf(currentSelectedElement))) {\n                hoveredNavNode = null;\n            }\n        }\n        if (!hoveredNavNode) {\n            if (currentHoveredKey !== null) {\n                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, null);\n                parentPort.postMessage({\n                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.HOVERED_ELEMENT_KEY,\n                    elementKey: null,\n                });\n                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n            }\n            return;\n        }\n        if (typeof hoveredNavNode === 'string') {\n            if (hoveredNavNode === constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD) {\n                const storyboardKey = tempoElement_1.TempoElement.forStoryboard(storyboardId).getKey();\n                if (currentHoveredKey !== storyboardKey) {\n                    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, storyboardKey);\n                    parentPort.postMessage({\n                        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.HOVERED_ELEMENT_KEY,\n                        elementKey: storyboardKey,\n                    });\n                    (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n                }\n            }\n            return;\n        }\n        const tempoElementKey = hoveredNavNode.tempoElement.getKey();\n        if (currentHoveredKey !== tempoElementKey) {\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.HOVERED_ELEMENT_KEY,\n                elementKey: tempoElementKey,\n            });\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, tempoElementKey);\n            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n        }\n    };\n    const clearHoveredElements = (parentPort, storyboardId) => {\n        const currentHoveredKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);\n        if (!currentHoveredKey) {\n            return;\n        }\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.HOVERED_ELEMENT_KEY,\n            elementKey: null,\n        });\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, null);\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    const onPointerMove = (e, parentPort, storyboardId) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        // If no buttons are pressed the drag end event may not have correctly triggered\n        // reset the drag state\n        let mouseDragData = (0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext');\n        if (!e.buttons && mouseDragData) {\n            (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', null);\n            if (mouseDragData === null || mouseDragData === void 0 ? void 0 : mouseDragData.dragging) {\n                parentPort.postMessage({\n                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_CANCEL_EVENT,\n                    event: {},\n                });\n            }\n            mouseDragData = null;\n        }\n        const importantFields = {\n            pageX: e.pageX,\n            pageY: e.pageY,\n            clientX: e.clientX,\n            clientY: e.clientY,\n        };\n        (0, sessionStorageUtils_1.setMemoryStorageItem)('mousePos', importantFields);\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MOUSE_MOVE_EVENT,\n            event: importantFields,\n        });\n        if (mouseDragData && !mouseDragData.dragging) {\n            const zoomPerc = (0, sessionStorageUtils_1.getMemoryStorageItem)('zoomPerc') || 1;\n            const totalMovementPixels = Math.abs(mouseDragData.pageX - e.pageX) +\n                Math.abs(mouseDragData.pageY - e.pageY);\n            // Start the drag event if the user has moved enough\n            if (totalMovementPixels >= PIXELS_TO_MOVE_BEFORE_DRAG / zoomPerc) {\n                // Reselect the parent if there was one to select\n                if (mouseDragData.parentSelectedElementKey) {\n                    const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};\n                    const navNodeToSelect = elementKeyToNavNode[mouseDragData.parentSelectedElementKey];\n                    if (navNodeToSelect) {\n                        parentPort.postMessage({\n                            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                            elementKey: mouseDragData.parentSelectedElementKey,\n                            outerHTML: (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${mouseDragData.parentSelectedElementKey}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML,\n                        });\n                        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, mouseDragData.parentSelectedElementKey);\n                    }\n                }\n                const aiContextSelection = (0, sessionStorageUtils_1.getMemoryStorageItem)('aiContext');\n                // Don't enable dragging if the AI context is enabled\n                if (!aiContextSelection) {\n                    (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', Object.assign(Object.assign({}, mouseDragData), { dragging: true }));\n                    const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n                    const selectedElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectedElementKey}`).get(0);\n                    // Trigger the drag start event\n                    parentPort.postMessage({\n                        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_START_EVENT,\n                        event: mouseDragData,\n                        outerHTML: selectedElement === null || selectedElement === void 0 ? void 0 : selectedElement.outerHTML,\n                    });\n                    const bodyObject = (0, jquery_1.default)('body').get(0);\n                    // HACK: March 8, 2024\n                    // Without this workaround events stay inside the iframe so it's not possible to\n                    // track mouse movements outside the iframe when clicking & dragging.\n                    // Set the pointer lock and immediately remove it so that\n                    // the events start to propagate upwards in the outer application.\n                    (0, sessionStorageUtils_1.setMemoryStorageItem)(IMMEDIATELY_REMOVE_POINTER_LOCK, true);\n                    yield (bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.requestPointerLock());\n                }\n            }\n        }\n        if ((0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext')) {\n            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n        }\n    });\n    const getParentDomElementForNavNode = (navNode) => {\n        if (!navNode) {\n            return null;\n        }\n        if (!(navNode === null || navNode === void 0 ? void 0 : navNode.isComponent)) {\n            const childDomElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${navNode.tempoElement.getKey()}`).get(0);\n            return childDomElement === null || childDomElement === void 0 ? void 0 : childDomElement.parentElement;\n        }\n        // This is the list of real DOM elements that are at the top level of this component\n        const elementKeyToLookupList = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_LOOKUP_LIST) || {};\n        const lookupList = elementKeyToLookupList[navNode.tempoElement.getKey()] || [];\n        let childDomElement;\n        lookupList.forEach((lookupElementKey) => {\n            if (childDomElement) {\n                return;\n            }\n            childDomElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${lookupElementKey}`).get(0);\n        });\n        return childDomElement === null || childDomElement === void 0 ? void 0 : childDomElement.parentElement;\n    };\n    const onPointerDown = (e, parentPort, storyboardId) => {\n        // This variable determines which button was used\n        // 1 -> left, 2 -> middle, 3 -> right\n        if (e.which !== 1) {\n            return;\n        }\n        // Allow the edit dynamic text button to be clicked\n        if ((0, identifierUtils_1.hasClass)(e.target, identifierUtils_1.EDIT_TEXT_BUTTON)) {\n            return;\n        }\n        const passedThrough = passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        if (passedThrough) {\n            return;\n        }\n        const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n        const selectedNavNode = onSelectElement(e, parentPort, storyboardId);\n        const useSelectedIfDragging = !selectedElement.isEmpty() &&\n            selectedElement.isParentOf(selectedNavNode === null || selectedNavNode === void 0 ? void 0 : selectedNavNode.tempoElement);\n        let offsetX, offsetY;\n        if (selectedNavNode === null || selectedNavNode === void 0 ? void 0 : selectedNavNode.pageBoundingBox) {\n            offsetX =\n                selectedNavNode.pageBoundingBox.pageX +\n                    selectedNavNode.pageBoundingBox.width / 2 -\n                    e.pageX;\n            offsetY =\n                selectedNavNode.pageBoundingBox.pageY +\n                    selectedNavNode.pageBoundingBox.height / 2 -\n                    e.pageY;\n        }\n        const importantFields = {\n            pageX: e.pageX,\n            pageY: e.pageY,\n            // The difference between where the user clicked and the center of the element\n            offsetX,\n            offsetY,\n            // Used to reselect the parent if the user starts to move\n            parentSelectedElementKey: useSelectedIfDragging\n                ? selectedElementKey\n                : null,\n        };\n        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};\n        // Get the parent element (actual DOM element) that this node is being dragged inside\n        // To do this pick one child element that is being dragged (can be multiple children if the node being dragged is a component),\n        // and get its parent in the DOM\n        const navNodeToUseForDragging = useSelectedIfDragging\n            ? elementKeyToNavNode[selectedElementKey]\n            : selectedNavNode;\n        const parentDomElement = getParentDomElementForNavNode(navNodeToUseForDragging);\n        if (parentDomElement) {\n            importantFields['selectedParentDisplay'] = (0, cssFunctions_1.cssEval)(parentDomElement, 'display');\n            importantFields['selectedParentFlexDirection'] = (0, cssFunctions_1.cssEval)(parentDomElement, 'flex-direction');\n        }\n        const aiContextSelection = (0, sessionStorageUtils_1.getMemoryStorageItem)('aiContext');\n        // Don't enable dragging if the AI context is enabled\n        if (!aiContextSelection) {\n            (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', importantFields);\n        }\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    const onPointerUp = (e, parentPort, storyboardId) => {\n        passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        const mouseDragData = (0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext');\n        (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', null);\n        if (mouseDragData === null || mouseDragData === void 0 ? void 0 : mouseDragData.dragging) {\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_END_EVENT,\n                event: {},\n            });\n        }\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    const onSelectElement = (e, parentPort, storyboardId) => {\n        var _a, _b, _c;\n        const driveModeEnabled = !!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId);\n        if (driveModeEnabled) {\n            return null;\n        }\n        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};\n        let selectedNavNode;\n        if (e.metaKey || e.ctrlKey) {\n            const elementKey = (0, identifierUtils_1.getElementKeyFromNode)(e.target);\n            selectedNavNode = elementKeyToNavNode[elementKey];\n            // Special case -> this is the top-most node so it should trigger a select on the storyboard\n            if (!selectedNavNode && e.target.parentNode === document.body) {\n                selectedNavNode = constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD;\n            }\n        }\n        else {\n            selectedNavNode = getSelectableNavNode(e);\n        }\n        const currentSelectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        // If this is not a valid nav node, it's not something we track - deselect all\n        if (!selectedNavNode) {\n            if (currentSelectedElementKey) {\n                parentPort.postMessage({\n                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                    elementKey: null,\n                });\n                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, null);\n                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n            }\n            return null;\n        }\n        const currentSelectedElement = tempoElement_1.TempoElement.fromKey(currentSelectedElementKey);\n        const currentMultiSelectedKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS) || [];\n        let newSelectedElement = typeof selectedNavNode === 'string'\n            ? tempoElement_1.TempoElement.forStoryboard(storyboardId)\n            : selectedNavNode.tempoElement;\n        let newMultiSelectKeys = [];\n        // If the user is holding shift, check if we can multi-select (something has to be already selected)\n        // Note: this logic generally matches the logic in the iframe slice on tempo-web\n        if (e.shiftKey && currentSelectedElementKey) {\n            // First check if we are deselecting\n            const elementToDeselect = currentMultiSelectedKeys\n                .map((elementKey) => tempoElement_1.TempoElement.fromKey(elementKey))\n                .find((element) => {\n                return (element.isParentOf(newSelectedElement) ||\n                    element.isEqual(newSelectedElement));\n            });\n            if (elementToDeselect) {\n                newMultiSelectKeys = currentMultiSelectedKeys.filter((elementKey) => {\n                    return elementKey !== elementToDeselect.getKey();\n                });\n                // Pick a new element to be the main selected element\n                // Note, if the length is 1, there is logic further down to handle that case explicitly (to exit multiselect mode)\n                if (elementToDeselect.isEqual(currentSelectedElement) &&\n                    newMultiSelectKeys.length > 1) {\n                    parentPort.postMessage({\n                        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                        elementKey: newMultiSelectKeys[0],\n                        outerHTML: (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${newMultiSelectKeys[0]}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML,\n                    });\n                    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, newMultiSelectKeys[0]);\n                }\n                // Check if we can add this element\n            }\n            else if (currentSelectedElement.isSiblingOf(newSelectedElement)) {\n                if (currentMultiSelectedKeys === null || currentMultiSelectedKeys === void 0 ? void 0 : currentMultiSelectedKeys.length) {\n                    newMultiSelectKeys = currentMultiSelectedKeys.concat([\n                        newSelectedElement.getKey(),\n                    ]);\n                }\n                else {\n                    newMultiSelectKeys = [\n                        currentSelectedElementKey,\n                        newSelectedElement.getKey(),\n                    ];\n                }\n            }\n            else {\n                // This case the user is trying to multiselect but it's not something that's allowed, just return but don't make any changes\n                return null;\n            }\n        }\n        // In multiselect mode, set the necessary values\n        if (newMultiSelectKeys.length > 1) {\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,\n                elementKeys: newMultiSelectKeys,\n                outerHTMLs: newMultiSelectKeys === null || newMultiSelectKeys === void 0 ? void 0 : newMultiSelectKeys.map((elementKey) => { var _a; return (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKey}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML; }),\n            });\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, newMultiSelectKeys);\n            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n            (0, editTextUtils_1.teardownEditableText)(parentPort, storyboardId);\n            return null; // Cannot perform regular actions on any particular node\n        }\n        // Special case - multiselecting but deselecting down to 1, stop the multiselect mode\n        if (newMultiSelectKeys.length === 1) {\n            newSelectedElement = tempoElement_1.TempoElement.fromKey(newMultiSelectKeys[0]);\n        }\n        const clearMultiSelectState = () => {\n            // Not multi-selecting, so clear the multiselect state\n            // Want to do this after setting the selected element to prevent flashing\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,\n                elementKeys: [],\n                outerHTMLs: [],\n            });\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, null);\n        };\n        // Selecting the storyboard from within\n        if (newSelectedElement.isStoryboard()) {\n            if (newSelectedElement.getKey() !== currentSelectedElementKey) {\n                parentPort.postMessage({\n                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                    elementKey: newSelectedElement.getKey(),\n                    outerHTML: (_b = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${newSelectedElement.getKey()}`).get(0)) === null || _b === void 0 ? void 0 : _b.outerHTML,\n                });\n                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, newSelectedElement.getKey());\n                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n            }\n            (0, editTextUtils_1.teardownEditableText)(parentPort, storyboardId);\n            clearMultiSelectState();\n            return null;\n        }\n        if ((0, editTextUtils_1.currentlyEditing)()) {\n            const editingInfo = (0, editTextUtils_1.getEditingInfo)();\n            if ((editingInfo === null || editingInfo === void 0 ? void 0 : editingInfo.key) !== currentSelectedElementKey) {\n                (0, editTextUtils_1.teardownEditableText)(parentPort, storyboardId);\n            }\n            clearMultiSelectState();\n            return null;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        if ((0, editTextUtils_1.canEditText)(newSelectedElement) &&\n            newSelectedElement.getKey() === currentSelectedElementKey) {\n            (0, editTextUtils_1.setupEditableText)(newSelectedElement, parentPort, storyboardId);\n        }\n        if (newSelectedElement.getKey() === currentSelectedElementKey) {\n            clearMultiSelectState();\n            return selectedNavNode;\n        }\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n            elementKey: newSelectedElement.getKey(),\n            outerHTML: (_c = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${newSelectedElement.getKey()}`).get(0)) === null || _c === void 0 ? void 0 : _c.outerHTML,\n        });\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, newSelectedElement.getKey());\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n        clearMultiSelectState();\n        return selectedNavNode;\n    };\n    /**\n     * Returns if events were passed through\n     */\n    const passThroughEventsIfNeeded = (e, parentPort, storyboardId) => {\n        var _a, _b;\n        const driveModeEnabled = !!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId);\n        const editingTextInfo = (0, editTextUtils_1.getEditingInfo)();\n        if (driveModeEnabled || editingTextInfo) {\n            return true;\n        }\n        (_a = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _a === void 0 ? void 0 : _a.call(e);\n        (_b = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _b === void 0 ? void 0 : _b.call(e);\n        return false;\n    };\n    const onClickElementContextMenu = (e, parentPort, storyboardId) => {\n        var _a;\n        const passedThrough = passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        if (passedThrough) {\n            return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        // Mouse down is called when a user clicks the context menu, but not mouse up, so clear the mouse down\n        (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', null);\n        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};\n        let requestedNavNode;\n        if (e.metaKey || e.ctrlKey) {\n            const elementKey = (0, identifierUtils_1.getElementKeyFromNode)(e.target);\n            requestedNavNode = elementKeyToNavNode[elementKey];\n            // Special case -> this is the top-most node so it should trigger a context menu on the storyboard\n            if (!requestedNavNode && e.target.parentNode === document.body) {\n                requestedNavNode = constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD;\n            }\n        }\n        else {\n            requestedNavNode = getSelectableNavNode(e);\n        }\n        const currentSelectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        const currentMultiSelectedKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);\n        if (!requestedNavNode || typeof requestedNavNode === 'string') {\n            if (requestedNavNode === constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD &&\n                !(currentMultiSelectedKeys === null || currentMultiSelectedKeys === void 0 ? void 0 : currentMultiSelectedKeys.length)) {\n                const storyboardKey = tempoElement_1.TempoElement.forStoryboard(storyboardId).getKey();\n                if (currentSelectedElementKey === storyboardKey) {\n                    return;\n                }\n                parentPort.postMessage({\n                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                    elementKey: storyboardKey,\n                });\n                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, storyboardKey);\n                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n            }\n            return;\n        }\n        let contextRequestedElementKey = null;\n        const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n        // Don't select any children as the user might be right clicking a node they selected\n        if (!requestedNavNode.tempoElement.isEqual(selectedElement) &&\n            !selectedElement.isParentOf(requestedNavNode.tempoElement) &&\n            !(currentMultiSelectedKeys === null || currentMultiSelectedKeys === void 0 ? void 0 : currentMultiSelectedKeys.length) // Also don't select anything new if in multiselect mode\n        ) {\n            contextRequestedElementKey = requestedNavNode.tempoElement.getKey();\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                elementKey: contextRequestedElementKey,\n                outerHTML: (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${contextRequestedElementKey}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML,\n            });\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, contextRequestedElementKey);\n            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n        }\n        const importantFields = {\n            clientX: e.clientX,\n            clientY: e.clientY,\n        };\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.CONTEXT_REQUESTED,\n            event: importantFields,\n        });\n    };\n    const buildAndSendNavTree = (parentPort, storyboardId, treeElementLookup, scopeLookup, storyboardComponentElement) => {\n        let treeElements = treeElementLookup;\n        if (!treeElements) {\n            treeElements = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP) || {};\n        }\n        let scopes = scopeLookup;\n        if (!scopes) {\n            scopes = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SCOPE_LOOKUP) || {};\n        }\n        let storyboardComponent = storyboardComponentElement;\n        if (storyboardComponentElement === 'EXPLICIT_NONE') {\n            storyboardComponent = null;\n        }\n        else if (!storyboardComponent) {\n            storyboardComponent = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.STORYBOARD_COMPONENT) || {};\n        }\n        const rootReactElement = (0, resqUtils_1.getRootReactElement)();\n        const reactTree = (0, resqUtils_1.buildNodeTree)(rootReactElement, null);\n        const lookupIdToReactTreeMap = {};\n        (0, resqUtils_1.buildTreeLookupMap)(reactTree, lookupIdToReactTreeMap);\n        const knownComponentNames = new Set();\n        const knownComponentInstanceNames = new Set();\n        if (treeElements) {\n            Object.values(treeElements).forEach((treeElement) => {\n                if (treeElement.type === 'component' ||\n                    treeElement.type === 'storybook-component') {\n                    knownComponentNames.add(treeElement.componentName);\n                }\n                if (treeElement.type === 'component-instance') {\n                    knownComponentInstanceNames.add(treeElement.componentName);\n                }\n            });\n        }\n        const elementKeyToLookupList = {};\n        const elementKeyToNavNode = {};\n        const builtNavTree = (0, navTreeUtils_1.buildNavForNode)(storyboardId, undefined, (0, jquery_1.default)('body').get(0), '', 'root', scopes, treeElements, lookupIdToReactTreeMap, knownComponentNames, knownComponentInstanceNames, elementKeyToLookupList, elementKeyToNavNode);\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_LOOKUP_LIST, elementKeyToLookupList);\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.CURRENT_NAV_TREE, builtNavTree);\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE, elementKeyToNavNode);\n        (0, resqUtils_1.clearLookupsFromTree)(reactTree);\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.NAV_TREE,\n            navTree: builtNavTree,\n            outerHtml: document.documentElement.outerHTML,\n        });\n        // Run callbacks\n        (0, navTreeUtils_1.runNavTreeBuiltCallbacks)();\n    };\n    const onFlushStart = () => {\n        // Find all instant update styling classes to delete\n        const classesToDelete = [];\n        (0, jquery_1.default)(`*[class*=${identifierUtils_1.TEMPO_INSTANT_UPDATE_STYLING_PREFIX}]`).each((i, element) => {\n            const classes = (element.getAttribute('class') || '').split(' ');\n            classes.forEach((className) => {\n                if (className.startsWith(identifierUtils_1.TEMPO_INSTANT_UPDATE_STYLING_PREFIX)) {\n                    classesToDelete.push(className);\n                }\n            });\n        });\n        (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH}=true]`).attr(identifierUtils_1.TEMPO_QUEUE_DELETE_AFTER_HOT_RELOAD, 'true');\n        // Clear the add class instant update queue as those items will be applied in the hot reload\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(changeItemFunctions_1.ADD_CLASS_INSTANT_UPDATE_QUEUE, []);\n        (0, sessionStorageUtils_1.setMemoryStorageItem)('POST_HOT_RELOAD_CLEAR', {\n            classesToDelete,\n        });\n    };\n    const clearInstantUpdatesAndSendNavTree = (parentPort, storyboardId) => {\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(LAST_NAV_TREE_REFRESH_TIME, new Date());\n        const { classesToDelete } = (0, sessionStorageUtils_1.getMemoryStorageItem)('POST_HOT_RELOAD_CLEAR') || {};\n        // Delete all instant update changed elements\n        (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_QUEUE_DELETE_AFTER_HOT_RELOAD}=true]`).remove();\n        // Clear the added display nones\n        (0, jquery_1.default)(`.${identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS}`).removeClass(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);\n        (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_INSTANT_UPDATE}=true]`).removeAttr(identifierUtils_1.TEMPO_INSTANT_UPDATE);\n        (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH}=true]`).removeAttr(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH);\n        (0, jquery_1.default)(`.${changeItemFunctions_1.TEMPORARY_STYLING_CLASS_NAME}`).removeClass(changeItemFunctions_1.TEMPORARY_STYLING_CLASS_NAME);\n        // Any classes marked to delete before the hot reload\n        classesToDelete === null || classesToDelete === void 0 ? void 0 : classesToDelete.forEach((cls) => {\n            (0, jquery_1.default)(`.${cls}`).removeClass(cls);\n        });\n        const newAddClassQueue = (0, sessionStorageUtils_1.getMemoryStorageItem)(changeItemFunctions_1.ADD_CLASS_INSTANT_UPDATE_QUEUE) || [];\n        // Any attributes that start with the styling prefix leftover mean that the class needs to be re-applied\n        // these are classes that were added in instant updates while the hot reload was in progress\n        newAddClassQueue.forEach((item) => {\n            if (!item) {\n                return;\n            }\n            const { codebaseId, className } = item;\n            if (codebaseId && className) {\n                (0, jquery_1.default)(`.${codebaseId}`).attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');\n                (0, jquery_1.default)(`.${codebaseId}`).addClass(className);\n            }\n        });\n        // Rebuild the nav tree on DOM changed after some time has passed\n        // this gives the react fiber time to be fully reconciled\n        try {\n            setTimeout(() => {\n                buildAndSendNavTree(parentPort, storyboardId);\n                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n            }, 300);\n        }\n        catch (e) {\n            console.error('ERROR: Could not re-create nav tree on DOM change, ' + e);\n        }\n    };\n    const onDOMChanged = (mutations, parentPort, storyboardId, \n    // If set to true this is called from the shadow root for the nextjs build watcher (the spinning triangle)\n    fromNextJsLoader) => {\n        var _a;\n        // Udpate the href in the parent container\n        if ((0, sessionStorageUtils_1.getMemoryStorageItem)('href') !== window.location.href) {\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.LATEST_HREF,\n                href: window.location.href,\n            });\n            (0, sessionStorageUtils_1.setMemoryStorageItem)('href', window.location.href);\n        }\n        // Check if we should refresh the nav tree\n        let refreshNavTree = false;\n        if (fromNextJsLoader) {\n            // From the nextjs loader, refresh when the loader gets hidden (means refresh is done)\n            const mutationTarget = (_a = mutations === null || mutations === void 0 ? void 0 : mutations[0]) === null || _a === void 0 ? void 0 : _a.target;\n            if (mutationTarget && mutationTarget.id === 'container') {\n                const currentlyHotReloading = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOT_RELOADING);\n                if (mutationTarget.classList.contains('visible')) {\n                    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOT_RELOADING, true);\n                }\n                else {\n                    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOT_RELOADING, false);\n                    refreshNavTree = true;\n                }\n            }\n        }\n        else {\n            mutations.forEach((e) => {\n                // If the class attribute has changed on an element we have to reparse the nav tree to add the element key\n                if (e.type === 'attributes' &&\n                    e.attributeName === 'class' &&\n                    e.target &&\n                    !(0, outlineUtils_1.isNodeOutline)(e.target) &&\n                    !(0, identifierUtils_1.isMovingElement)(e.target) &&\n                    // And not a script\n                    // Bug found on Oct 8, 2024, for some reason the script kept triggering a reload\n                    !e.target.tagName.toLowerCase().includes('script')) {\n                    const elementKey = (0, identifierUtils_1.getElementKeyFromNode)(e.target);\n                    const uniqueLookup = (0, identifierUtils_1.getUniqueLookupFromNode)(e.target);\n                    // An element which doesn't have an element key has changed\n                    if (!elementKey && !uniqueLookup && !(0, identifierUtils_1.isElementInSvg)(e.target)) {\n                        refreshNavTree = true;\n                    }\n                    return;\n                }\n                [e.addedNodes, e.removedNodes].forEach((nodeList) => {\n                    if (!nodeList) {\n                        return;\n                    }\n                    nodeList.forEach((node) => {\n                        if (!(0, outlineUtils_1.isNodeOutline)(node) && !(0, identifierUtils_1.isMovingElement)(node)) {\n                            refreshNavTree = true;\n                        }\n                    });\n                });\n            });\n        }\n        if (!refreshNavTree) {\n            return;\n        }\n        // In these cases we don't want to trigger a nav tree refresh right away\n        // since the hot reload may not have happened yet. So we set a timeout and only\n        // trigger a nav tree refresh if another one hasn't happened in between\n        if (fromNextJsLoader) {\n            const triggerTime = new Date();\n            setTimeout(() => {\n                const lastRefreshTime = (0, sessionStorageUtils_1.getMemoryStorageItem)(LAST_NAV_TREE_REFRESH_TIME);\n                // Don't re-clear and send if another refresh has happened in the meantime\n                if (!lastRefreshTime || lastRefreshTime < triggerTime) {\n                    clearInstantUpdatesAndSendNavTree(parentPort, storyboardId);\n                }\n            }, 1000);\n            return;\n        }\n        clearInstantUpdatesAndSendNavTree(parentPort, storyboardId);\n    };\n    const onWheel = (e, parentPort, storyboardId) => {\n        const passedThrough = passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        const isScrollShortcut = e.altKey;\n        const isZoomShortcut = e.ctrlKey || e.metaKey;\n        // If the user wants to scroll (either by being in drive mode, or by holding alt)\n        // and they aren't trying to zoom, fallback to default behaviour.\n        if (!isZoomShortcut && (passedThrough || isScrollShortcut)) {\n            return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        const importantFields = {\n            deltaX: e.deltaX,\n            deltaY: e.deltaY,\n            wheelDelta: e.wheelDelta,\n            x: e.x,\n            y: e.y,\n            altKey: e.altKey,\n            ctrlKey: e.ctrlKey,\n            shiftKey: e.shiftKey,\n            metaKey: e.metaKey,\n        };\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.WHEEL_EVENT,\n            event: importantFields,\n        });\n    };\n    const activeElementMetadata = () => {\n        const activeElement = document.activeElement;\n        let tagName, isContentEditable, elementType;\n        if (activeElement) {\n            tagName = activeElement.tagName;\n            if (activeElement instanceof HTMLElement) {\n                isContentEditable = activeElement.isContentEditable;\n            }\n            if (activeElement instanceof HTMLInputElement) {\n                elementType = activeElement.type;\n            }\n        }\n        return {\n            tagName: tagName,\n            isContentEditable: isContentEditable,\n            elementType: elementType,\n        };\n    };\n    const onKeyDown = (e, parentPort) => {\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.KEY_DOWN_EVENT,\n            event: {\n                key: e.key,\n                metaKey: e.metaKey,\n                shiftKey: e.shiftKey,\n                ctrlKey: e.ctrlKey,\n                activeElement: Object.assign({}, activeElementMetadata()),\n            },\n        });\n    };\n    const onKeyUp = (e, parentPort) => {\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.KEY_UP_EVENT,\n            event: {\n                key: e.key,\n                metaKey: e.metaKey,\n                shiftKey: e.shiftKey,\n                ctrlKey: e.ctrlKey,\n                activeElement: Object.assign({}, activeElementMetadata()),\n            },\n        });\n    };\n    const throttledUpdateOutlines = lodash_1.default.throttle((parentPort, storyboardId) => (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId), 15);\n    const onScroll = (e, parentPort, storyboardId) => {\n        throttledUpdateOutlines(parentPort, storyboardId);\n    };\n    // Need to register functions on the window for channel messaging to use them\n    // @ts-ignore\n    window.initProject = (parentPort, storyboardId, treeElementLookup, scopeLookup, storyboardComponentElement, options = {}, storyboardType, savedComponentFilename, originalStoryboardUrl) => {\n        const passive = makePassiveEventOption();\n        passive['capture'] = true;\n        const body$ = (0, jquery_1.default)('body');\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP, treeElementLookup);\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SCOPE_LOOKUP, scopeLookup);\n        if (storyboardComponentElement) {\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.STORYBOARD_COMPONENT, storyboardComponentElement);\n        }\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.STORYBOARD_TYPE, storyboardType);\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SAVED_STORYBOARD_COMPONENT_FILENAME, savedComponentFilename);\n        // The URL that was originally loaded for this storyboard, it may be different from href\n        // if the user navigated away to a new route\n        if (originalStoryboardUrl) {\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.ORIGINAL_STORYBOARD_URL, originalStoryboardUrl);\n        }\n        // Clear iframe outlines\n        (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n        // Register event listeners\n        const bodyObject = body$.get(0);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('click', (e) => {\n            passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointerover', (e) => {\n            onPointerOver(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointerdown', (e) => {\n            onPointerDown(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointerup', (e) => {\n            onPointerUp(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointermove', (e) => {\n            onPointerMove(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointerleave', (e) => {\n            passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('contextmenu', (e) => {\n            onClickElementContextMenu(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('dblclick', (e) => {\n            passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mouseover', (e) => {\n            passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mouseout', (e) => {\n            passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mousemove', (e) => {\n            passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mousedown', (e) => {\n            passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mouseup', (e) => {\n            passThroughEventsIfNeeded(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('wheel', (e) => {\n            onWheel(e, parentPort, storyboardId);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('keydown', (e) => {\n            onKeyDown(e, parentPort);\n        }, passive);\n        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('keyup', (e) => {\n            onKeyUp(e, parentPort);\n        }, passive);\n        window.addEventListener('scroll', (e) => {\n            onScroll(e, parentPort, storyboardId);\n        }, passive);\n        // Hack: this is used to\n        document.addEventListener('pointerlockchange', () => {\n            if (document.pointerLockElement &&\n                (0, sessionStorageUtils_1.getMemoryStorageItem)(IMMEDIATELY_REMOVE_POINTER_LOCK)) {\n                document.exitPointerLock();\n                (0, sessionStorageUtils_1.setMemoryStorageItem)(IMMEDIATELY_REMOVE_POINTER_LOCK, false);\n            }\n        }, false);\n        observeDOM(bodyObject, (e) => {\n            onDOMChanged(e, parentPort, storyboardId);\n        });\n        // If this is NextJS, also listen to the shadow root of the __next-build-watcher\n        // This triggeres the onDOMChanged when the hot reload symbol shows up\n        const nextBuildWatcher = document.getElementById('__next-build-watcher');\n        if (nextBuildWatcher && nextBuildWatcher.shadowRoot) {\n            Array.from(nextBuildWatcher.shadowRoot.children).forEach((child) => {\n                observeDOM(child, (e) => {\n                    onDOMChanged(e, parentPort, storyboardId, true);\n                });\n            });\n        }\n        if (options.driveModeEnabled) {\n            enableDriveMode(parentPort, storyboardId);\n        }\n        else {\n            disableDriveMode(parentPort, storyboardId);\n        }\n        if (options.aiContextSelection) {\n            (0, sessionStorageUtils_1.setMemoryStorageItem)('aiContext', true);\n            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n        }\n        else {\n            (0, sessionStorageUtils_1.setMemoryStorageItem)('aiContext', false);\n            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n        }\n        // Build the Nav Tree and send it back\n        try {\n            buildAndSendNavTree(parentPort, storyboardId, treeElementLookup, scopeLookup, storyboardComponentElement || 'EXPLICIT_NONE');\n        }\n        catch (e) {\n            console.log(e);\n            console.error('Error building nav tree: ' + e);\n        }\n    };\n    const enableDriveMode = (parentPort, storyboardId) => {\n        // @ts-ignore\n        if (!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId)) {\n            // @ts-ignore\n            (0, sessionStorageUtils_1.setSessionStorageItem)('driveModeEnabled', 'enabled', storyboardId);\n            clearHoveredElements(parentPort, storyboardId);\n            (0, outlineUtils_1.clearAllOutlines)();\n        }\n        (0, jquery_1.default)('body').css('cursor', '');\n    };\n    const disableDriveMode = (parentPort, storyboardId) => {\n        // @ts-ignore\n        if ((0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId)) {\n            // @ts-ignore\n            (0, sessionStorageUtils_1.removeSessionStorageItem)('driveModeEnabled', storyboardId);\n            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n            clearHoveredElements(parentPort, storyboardId);\n        }\n        (0, jquery_1.default)('body').attr('style', function (i, s) {\n            return (s || '') + 'cursor: default !important;';\n        });\n    };\n    // @ts-ignore\n    window.enableDriveMode = (parentPort, storyboardId) => {\n        enableDriveMode(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.disableDriveMode = (parentPort, storyboardId) => {\n        disableDriveMode(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.setNewLookups = (parentPort, storyboardId, treeElementLookup, scopeLookup) => {\n        const prevTreeElemntLookup = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP) || {};\n        const prevScopeLookup = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SCOPE_LOOKUP) || {};\n        const newTreeElements = Object.assign({}, prevTreeElemntLookup);\n        // Delete any tree elements that were set to nul\n        Object.keys(treeElementLookup).forEach((key) => {\n            if (treeElementLookup[key]) {\n                newTreeElements[key] = treeElementLookup[key];\n            }\n            else if (newTreeElements[key]) {\n                delete newTreeElements[key];\n            }\n        });\n        const newScopes = Object.assign({}, prevScopeLookup);\n        // Delete any scopes that were set to nul\n        Object.keys(scopeLookup).forEach((key) => {\n            if (scopeLookup[key]) {\n                newScopes[key] = scopeLookup[key];\n            }\n            else if (newScopes[key]) {\n                delete newScopes[key];\n            }\n        });\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP, newTreeElements);\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SCOPE_LOOKUP, newScopes);\n    };\n    // @ts-ignore\n    window.setHoveredElement = (parentPort, storyboardId, elementKey) => {\n        const driveModeEnabled = !!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId);\n        if (driveModeEnabled) {\n            return;\n        }\n        const prevHoveredElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);\n        if (prevHoveredElementKey === elementKey) {\n            return;\n        }\n        if (elementKey) {\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, elementKey);\n        }\n        else {\n            (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);\n        }\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.setSelectedElement = (parentPort, storyboardId, elementKey) => {\n        var _a, _b;\n        const prevSelectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        if (prevSelectedElementKey === elementKey) {\n            return;\n        }\n        if (elementKey) {\n            const tempoElement = tempoElement_1.TempoElement.fromKey(elementKey);\n            let elementKeyToExtract = elementKey;\n            if (tempoElement.isStoryboard(storyboardId)) {\n                // Pass back the outerHTML of the top level node\n                const topLevelNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.CURRENT_NAV_TREE);\n                const topLevelElementKey = (_a = topLevelNode === null || topLevelNode === void 0 ? void 0 : topLevelNode.tempoElement) === null || _a === void 0 ? void 0 : _a.getKey();\n                if (topLevelElementKey) {\n                    elementKeyToExtract = topLevelElementKey;\n                }\n            }\n            // Send back the message just to set the outerHTML only\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                doNotSetElementKey: true,\n                outerHTML: (_b = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKeyToExtract}`).get(0)) === null || _b === void 0 ? void 0 : _b.outerHTML,\n            });\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, elementKey);\n        }\n        else {\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                doNotSetElementKey: true,\n                outerHTML: null,\n            });\n            (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        }\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.setMultiselectedElementKeys = (parentPort, storyboardId, elementKeys) => {\n        const prevMultiSelectedElementKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);\n        const prevSet = new Set(prevMultiSelectedElementKeys || []);\n        const newSet = new Set(elementKeys || []);\n        const setsEqual = prevSet.size === newSet.size &&\n            [...prevSet].every((value) => newSet.has(value));\n        if (setsEqual) {\n            return;\n        }\n        if (elementKeys) {\n            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, elementKeys);\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,\n                doNotSetElementKeys: true,\n                outerHTMLs: elementKeys === null || elementKeys === void 0 ? void 0 : elementKeys.map((elementKey) => { var _a; return (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKey}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML; }),\n            });\n        }\n        else {\n            (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,\n                doNotSetElementKeys: true,\n                outerHTMLs: [],\n            });\n        }\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.processRulesForSelectedElement = (parentPort, storyboardId, cssElementLookup, selectedElementKey) => {\n        (0, cssFunctions_1.processRulesForSelectedElement)(parentPort, cssElementLookup, selectedElementKey);\n    };\n    // @ts-ignore\n    window.setModifiersForSelectedElement = (parentPort, storyboardId, modifiers, selectedElementKey) => {\n        (0, cssFunctions_1.setModifiersForSelectedElement)(parentPort, modifiers, selectedElementKey);\n    };\n    // @ts-ignore\n    window.getCssEvals = (parentPort, storyboardId, selectedElementKey) => {\n        (0, cssFunctions_1.getCssEvals)(parentPort, selectedElementKey);\n    };\n    // @ts-ignore\n    window.ruleMatchesElement = (parentPort, storyboardId, messageId, rule, selectedElementKey) => {\n        (0, cssFunctions_1.ruleMatchesElement)(parentPort, messageId, rule, selectedElementKey);\n    };\n    // @ts-ignore\n    window.getElementClassList = (parentPort, storyboardId, selectedElementKey) => {\n        (0, cssFunctions_1.getElementClassList)(parentPort, selectedElementKey);\n    };\n    // @ts-ignore\n    window.applyChangeItemToDocument = (parentPort, storyboardId, changeItem) => __awaiter(void 0, void 0, void 0, function* () {\n        const { sendNewNavTree } = (0, changeItemFunctions_1.applyChangeItemToDocument)(parentPort, storyboardId, changeItem);\n        // Update the nav tree & outlines\n        if (sendNewNavTree) {\n            buildAndSendNavTree(parentPort, storyboardId);\n        }\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    });\n    // @ts-ignore\n    window.updateCodebaseIds = (parentPort, storyboardId, prevIdToNewIdMap, newTreeElementLookup, newScopeLookup) => {\n        const sendNewNavTree = (0, changeItemFunctions_1.updateCodebaseIds)(parentPort, prevIdToNewIdMap, true);\n        if (sendNewNavTree) {\n            buildAndSendNavTree(parentPort, storyboardId, newTreeElementLookup, newScopeLookup);\n        }\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.dispatchEvent = (parentPort, storyboardId, eventName, eventDetails) => {\n        const event = new CustomEvent(eventName, Object.assign({}, eventDetails));\n        document.dispatchEvent(event);\n    };\n    // @ts-ignore\n    window.updateOutlines = (parentPort, storyboardId) => {\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.goBack = (parentPort, storyboardId) => {\n        if (document.referrer !== '') {\n            window.history.back();\n        }\n    };\n    // @ts-ignore\n    window.goForward = (parentPort, storyboardId) => {\n        window.history.forward();\n    };\n    // @ts-ignore\n    window.refresh = (parentPort, storyboardId) => {\n        window.location.reload();\n    };\n    // @ts-ignore\n    window.syntheticMouseOver = (parentPort, storyboardId, coords, dontHoverInsideSelected, selectBottomMostElement) => {\n        const target = document.elementFromPoint(coords.x, coords.y);\n        // If this is true we don't want to trigger a hover event inside a selected element, instead just set hovering on the selected element\n        if (dontHoverInsideSelected) {\n            const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n            const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n            if (!selectedElement.isEmpty()) {\n                const selectedDomElement = document.querySelector(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectedElementKey}`);\n                if (selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.contains(target)) {\n                    onPointerOver({ target: selectedDomElement }, parentPort, storyboardId);\n                    return;\n                }\n            }\n        }\n        onPointerOver({ target }, parentPort, storyboardId, selectBottomMostElement);\n    };\n    // @ts-ignore\n    window.syntheticMouseMove = (parentPort, storyboardId, syntheticEvent) => {\n        const eventWithClient = Object.assign(Object.assign({}, syntheticEvent), { pageX: syntheticEvent.clientX +\n                (document.documentElement.scrollLeft || document.body.scrollLeft), pageY: syntheticEvent.clientY +\n                (document.documentElement.scrollTop || document.body.scrollTop) });\n        onPointerMove(eventWithClient, parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.syntheticMouseUp = (parentPort, storyboardId, syntheticEvent) => {\n        onPointerUp(syntheticEvent, parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.clearHoveredOutlines = (parentPort, storyboardId) => {\n        if ((0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY)) {\n            clearHoveredElements(parentPort, storyboardId);\n        }\n    };\n    // @ts-ignore\n    window.setZoomPerc = (parentPort, storyboardId, zoomPerc) => {\n        (0, sessionStorageUtils_1.setMemoryStorageItem)('zoomPerc', zoomPerc.toString());\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.setAiContext = (parentPort, storyboardId, aiContext) => {\n        (0, sessionStorageUtils_1.setMemoryStorageItem)('aiContext', !!aiContext);\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.tempMoveElement = (parentPort, storyboardId, nodeToMoveElementKey, newIndex) => {\n        var _a, _b, _c, _d, _e;\n        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};\n        const navNodeToMove = elementKeyToNavNode[nodeToMoveElementKey];\n        if (!navNodeToMove) {\n            return;\n        }\n        const nodeToMoveElement = tempoElement_1.TempoElement.fromKey(nodeToMoveElementKey);\n        const domElementsToMove = [];\n        // In components, there may be multiple elements that need to be moved, the eleemntKeyToLookupList\n        // are all the real DOM elements in a component\n        // For non-components, the eleemntKeyToLookupList points to a list of itself\n        const elementKeyToLookupList = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_LOOKUP_LIST) || {};\n        const lookupList = elementKeyToLookupList[navNodeToMove.tempoElement.getKey()] || [];\n        lookupList.forEach((lookupElementKey) => {\n            domElementsToMove.push((0, jquery_1.default)('body').find(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${lookupElementKey}`).get(0));\n        });\n        const parentDomElement = (_a = domElementsToMove[0]) === null || _a === void 0 ? void 0 : _a.parentElement;\n        const parentNavNode = navNodeToMove.parent;\n        if (parentDomElement && parentNavNode) {\n            const currentIndex = (_b = parentNavNode === null || parentNavNode === void 0 ? void 0 : parentNavNode.children) === null || _b === void 0 ? void 0 : _b.indexOf(navNodeToMove);\n            const numChildren = (_c = parentNavNode === null || parentNavNode === void 0 ? void 0 : parentNavNode.children) === null || _c === void 0 ? void 0 : _c.length;\n            if (currentIndex !== newIndex) {\n                Array.from(parentDomElement.children).forEach((child) => {\n                    (0, jquery_1.default)(child).attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');\n                });\n                (0, jquery_1.default)(parentDomElement).attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');\n                if (newIndex === numChildren - 1) {\n                    domElementsToMove.forEach((element) => {\n                        element.parentElement.appendChild(element);\n                    });\n                }\n                else {\n                    // If the current index is before the new index then we need to adjust by 1 to account for the shift in indices\n                    const beforeNode = currentIndex > newIndex\n                        ? parentNavNode === null || parentNavNode === void 0 ? void 0 : parentNavNode.children[newIndex]\n                        : parentNavNode === null || parentNavNode === void 0 ? void 0 : parentNavNode.children[newIndex + 1];\n                    const lookupListForBefore = elementKeyToLookupList[(_d = beforeNode === null || beforeNode === void 0 ? void 0 : beforeNode.tempoElement) === null || _d === void 0 ? void 0 : _d.getKey()] || [];\n                    if (!lookupListForBefore.length) {\n                        console.log('Cannot find element to insert before in lookup list');\n                        return;\n                    }\n                    const beforeDomElement = (0, jquery_1.default)('body')\n                        .find(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${lookupListForBefore[0]}`)\n                        .get(0);\n                    if (!beforeDomElement) {\n                        console.log('Cannot find element to insert before');\n                        return;\n                    }\n                    domElementsToMove.forEach((element) => {\n                        element.parentElement.insertBefore(element, beforeDomElement);\n                    });\n                }\n                // Update the selected element key to the new expected one (note if moving there is no hovered element key)\n                // This also assumes the nodeToMoveElementKey is the selected element key\n                const elementToMoveSegments = nodeToMoveElement.uniquePath.split('-');\n                const newSelectedUniquePath = elementToMoveSegments\n                    .slice(0, elementToMoveSegments.length - 1)\n                    .join('-') + `-${newIndex}`;\n                const newSelectedElementKey = new tempoElement_1.TempoElement(nodeToMoveElement.codebaseId, nodeToMoveElement.storyboardId, newSelectedUniquePath).getKey();\n                // Update the nav tree which also sets the element key on all the elements, need to do this before\n                // updating the selected element key\n                buildAndSendNavTree(parentPort, storyboardId);\n                // Codebase ID doesn't change\n                parentPort.postMessage({\n                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,\n                    elementKey: newSelectedElementKey,\n                    outerHTML: (_e = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${newSelectedElementKey}`).get(0)) === null || _e === void 0 ? void 0 : _e.outerHTML,\n                });\n                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, newSelectedElementKey);\n                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n            }\n        }\n    };\n    // @ts-ignore\n    window.tempAddDiv = (parentPort, storyboardId, parentCodebaseId, indexInParent, width, height) => {\n        const element = (0, jquery_1.default)(`.${identifierUtils_1.TEMPO_INSTANT_DIV_DRAW_CLASS}`);\n        if (element.length) {\n            element.css('width', width);\n            element.css('height', height);\n        }\n        else {\n            let parent = (0, jquery_1.default)(`.${parentCodebaseId}`);\n            if (!parent.length) {\n                parent = (0, jquery_1.default)('body');\n            }\n            parent.each((index, item) => {\n                const newElement = (0, jquery_1.default)(`<div class=\"${identifierUtils_1.TEMPO_INSTANT_DIV_DRAW_CLASS}\" ${identifierUtils_1.TEMPO_DELETE_AFTER_INSTANT_UPDATE}=\"true\" ${identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH}=\"true\" ${identifierUtils_1.TEMPO_INSTANT_UPDATE}=\"true\"></div>`);\n                const childAtIndex = (0, jquery_1.default)(item).children().eq(indexInParent);\n                if (childAtIndex === null || childAtIndex === void 0 ? void 0 : childAtIndex.length) {\n                    childAtIndex.before(newElement);\n                }\n                else {\n                    (0, jquery_1.default)(item).append(newElement);\n                }\n            });\n            // Update the nav tree\n            buildAndSendNavTree(parentPort, storyboardId);\n        }\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.tempMoveToNewParent = (parentPort, storyboardId, indicatorWidth, indicatorHeight, newPositionX, newPositionY, parentElementKey, clear) => {\n        (0, jquery_1.default)(`.${identifierUtils_1.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE}`).remove();\n        if (clear) {\n            return;\n        }\n        const newElement = document.createElement('div');\n        newElement.classList.add(identifierUtils_1.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE);\n        newElement.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // Add so it doesn't trigger new nav tree building\n        newElement.style.width = indicatorWidth + 'px';\n        newElement.style.height = indicatorHeight + 'px';\n        newElement.style.left = newPositionX + 'px';\n        newElement.style.top = newPositionY + 'px';\n        newElement.style.position = 'fixed';\n        newElement.style.pointerEvents = 'none';\n        newElement.style.zIndex = '2000000004';\n        newElement.style.boxSizing = 'border-box';\n        newElement.style.cursor = 'default !important';\n        newElement.style.backgroundColor = outlineUtils_1.PRIMARY_OUTLINE_COLOUR;\n        const body = document.getElementsByTagName('body')[0];\n        body.appendChild(newElement);\n        const parentDomElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${parentElementKey}`).get(0);\n        if (parentDomElement) {\n            const boundingRect = parentDomElement.getBoundingClientRect();\n            const parentOutline = (0, outlineUtils_1.getOutlineElement)(parentPort, outlineUtils_1.OutlineType.PRIMARY, boundingRect.left, boundingRect.top, boundingRect.width, boundingRect.height);\n            parentOutline.classList.remove(identifierUtils_1.OUTLINE_CLASS);\n            parentOutline.classList.add(identifierUtils_1.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE);\n            parentOutline.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // Add so it doesn't trigger new nav tree building\n            body.appendChild(parentOutline);\n        }\n    };\n    // @ts-ignore\n    window.checkIfHydrationError = (parentPort, storyboardId) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n        let errorDescr, errorLabel, errorBody, hasError;\n        if (window.location.href.includes('framework=VITE')) {\n            // @ts-ignore\n            const errorPortal = (_a = document.getElementsByTagName('vite-error-overlay')[0]) === null || _a === void 0 ? void 0 : _a.shadowRoot;\n            errorDescr = 'A Vite Error Occurred';\n            errorLabel =\n                (_d = (_c = (_b = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.querySelectorAll) === null || _b === void 0 ? void 0 : _b.call(errorPortal, '.file-link')) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.innerHTML;\n            errorBody = (_g = (_f = (_e = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.querySelectorAll) === null || _e === void 0 ? void 0 : _e.call(errorPortal, '.message')) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.innerHTML;\n            hasError = Boolean(errorLabel || errorBody);\n        }\n        else {\n            // @ts-ignore\n            const errorPortal = (_h = document.getElementsByTagName('nextjs-portal')[0]) === null || _h === void 0 ? void 0 : _h.shadowRoot;\n            errorDescr = (_k = (_j = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.getElementById) === null || _j === void 0 ? void 0 : _j.call(errorPortal, 'nextjs__container_errors_desc')) === null || _k === void 0 ? void 0 : _k.innerHTML;\n            errorLabel = (_m = (_l = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.getElementById) === null || _l === void 0 ? void 0 : _l.call(errorPortal, 'nextjs__container_errors_label')) === null || _m === void 0 ? void 0 : _m.innerHTML;\n            errorBody = (_q = (_p = (_o = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.querySelectorAll) === null || _o === void 0 ? void 0 : _o.call(errorPortal, '.nextjs-container-errors-body')) === null || _p === void 0 ? void 0 : _p[0]) === null || _q === void 0 ? void 0 : _q.innerHTML;\n            hasError = Boolean(errorDescr);\n        }\n        // Check if the contents of the hydration container contain the text \"Hydration failed\"\n        if (hasError) {\n            if (errorDescr === null || errorDescr === void 0 ? void 0 : errorDescr.includes('Hydration failed')) {\n                parentPort.postMessage({\n                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.LATEST_HYDRATION_ERROR_STATUS,\n                    status: constantsAndTypes_1.STORYBOARD_HYDRATION_STATUS.ERROR,\n                    errorDescr,\n                    errorLabel,\n                    errorBody,\n                });\n            }\n            else {\n                parentPort.postMessage({\n                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.LATEST_HYDRATION_ERROR_STATUS,\n                    status: constantsAndTypes_1.STORYBOARD_HYDRATION_STATUS.OTHER_ERROR,\n                    errorDescr,\n                    errorLabel,\n                    errorBody,\n                });\n            }\n        }\n        else {\n            parentPort.postMessage({\n                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.LATEST_HYDRATION_ERROR_STATUS,\n                status: constantsAndTypes_1.STORYBOARD_HYDRATION_STATUS.NO_ERROR,\n            });\n        }\n    };\n    // @ts-ignore\n    window.triggerDragStart = (parentPort, storyboardId) => {\n        const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};\n        // Something has to be selected to trigger a drag start\n        if (!selectedElementKey) {\n            return;\n        }\n        const draggedNavNode = elementKeyToNavNode[selectedElementKey];\n        const parentDomElement = getParentDomElementForNavNode(draggedNavNode);\n        const selectedElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectedElementKey}`).get(0);\n        const mouseDragContext = {\n            // Start off screen, this will get updated by onMouseMove\n            pageX: -10000,\n            pageY: -10000,\n            // The difference between where the user clicked and the center of the element\n            offsetX: 0,\n            offsetY: 0,\n            dragging: true,\n            selectedParentDisplay: (0, cssFunctions_1.cssEval)(parentDomElement, 'display'),\n            selectedParentFlexDirection: (0, cssFunctions_1.cssEval)(parentDomElement, 'flex-direction'),\n        };\n        (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', mouseDragContext);\n        // Trigger the drag start event\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_START_EVENT,\n            event: mouseDragContext,\n            outerHTML: selectedElement === null || selectedElement === void 0 ? void 0 : selectedElement.outerHTML,\n        });\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.triggerDragCancel = (parentPort, storyboardId) => {\n        (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', null);\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_CANCEL_EVENT,\n            event: {},\n        });\n        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);\n    };\n    // @ts-ignore\n    window.setIsFlushing = (parentPort, storyboardId, isFlushing) => {\n        const wasFlushing = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.IS_FLUSHING);\n        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.IS_FLUSHING, isFlushing);\n        if (isFlushing && !wasFlushing) {\n            onFlushStart();\n        }\n    };\n};\nexports.initChannelMessagingFunctions = initChannelMessagingFunctions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2NoYW5uZWxNZXNzYWdpbmdGdW5jdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLDBCQUEwQixtQkFBTyxDQUFDLHVHQUFtQjtBQUNyRCw4QkFBOEIsbUJBQU8sQ0FBQywrR0FBdUI7QUFDN0QsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWdCO0FBQy9DO0FBQ0EsaUNBQWlDLG1CQUFPLENBQUMsMERBQVE7QUFDakQsaUNBQWlDLG1CQUFPLENBQUMscURBQVE7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWdCO0FBQy9DLHVCQUF1QixtQkFBTyxDQUFDLGlHQUFnQjtBQUMvQyw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBcUI7QUFDekQsOEJBQThCLG1CQUFPLENBQUMsK0dBQXVCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLDJGQUFhO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLGlHQUFnQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHFDQUFxQyxFQUFFLHVDQUF1QztBQUNySix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILG9CQUFvQixnQkFBZ0I7QUFDMUo7QUFDQSxzRUFBc0UscUNBQXFDLEVBQUUsbUJBQW1CO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFDQUFxQyxFQUFFLDhCQUE4QjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxxQ0FBcUMsRUFBRSxpQkFBaUI7QUFDaEgsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxxQ0FBcUMsRUFBRSxzQkFBc0I7QUFDaEkscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSxRQUFRLHVDQUF1QyxxQ0FBcUMsRUFBRSxXQUFXLCtEQUErRDtBQUM3UyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHFDQUFxQyxFQUFFLDRCQUE0QjtBQUNsSSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUNBQXFDLEVBQUUsNEJBQTRCO0FBQzFILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQ0FBcUMsRUFBRSwyQkFBMkI7QUFDN0gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzREFBc0Q7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsbUNBQW1DLDZDQUE2QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0EsbUNBQW1DLHNEQUFzRDtBQUN6RjtBQUNBLGtDQUFrQyx5REFBeUQ7QUFDM0YsbUNBQW1DLHVDQUF1QztBQUMxRSxtQ0FBbUMseURBQXlEO0FBQzVGLGtDQUFrQyxtREFBbUQ7QUFDckY7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUNBQXFDLEVBQUUsb0JBQW9CO0FBQ3RILGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCxRQUFRLHVDQUF1QyxxQ0FBcUMsRUFBRSxXQUFXLCtEQUErRDtBQUN4UixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UscUNBQXFDLEVBQUUsbUJBQW1CO0FBQ2hJO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxxQkFBcUI7QUFDbkY7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxxQ0FBcUMsRUFBRSxpQkFBaUI7QUFDbEksU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFDQUFxQyxFQUFFLHVCQUF1QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHFDQUFxQyxFQUFFLHNCQUFzQjtBQUM1SCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsK0NBQStDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLCtDQUErQyxJQUFJLG9EQUFvRCxVQUFVLDZDQUE2QyxVQUFVLHVDQUF1QztBQUN2UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxREFBcUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUNBQXFDLEVBQUUsaUJBQWlCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxQ0FBcUMsRUFBRSxtQkFBbUI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHRlbXBvLWRldnRvb2xzXFxkaXN0XFxjaGFubmVsTWVzc2FnaW5nXFxjaGFubmVsTWVzc2FnaW5nRnVuY3Rpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluaXRDaGFubmVsTWVzc2FnaW5nRnVuY3Rpb25zID0gdm9pZCAwO1xuY29uc3QgaWRlbnRpZmllclV0aWxzXzEgPSByZXF1aXJlKFwiLi9pZGVudGlmaWVyVXRpbHNcIik7XG5jb25zdCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi9zZXNzaW9uU3RvcmFnZVV0aWxzXCIpO1xuY29uc3QgbmF2VHJlZVV0aWxzXzEgPSByZXF1aXJlKFwiLi9uYXZUcmVlVXRpbHNcIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBqcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianF1ZXJ5XCIpKTtcbmNvbnN0IGxvZGFzaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3Qgb3V0bGluZVV0aWxzXzEgPSByZXF1aXJlKFwiLi9vdXRsaW5lVXRpbHNcIik7XG5jb25zdCBjc3NGdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2Nzc0Z1bmN0aW9uc1wiKTtcbmNvbnN0IGNvbnN0YW50c0FuZFR5cGVzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNBbmRUeXBlc1wiKTtcbmNvbnN0IGNoYW5nZUl0ZW1GdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2NoYW5nZUl0ZW1GdW5jdGlvbnNcIik7XG5jb25zdCByZXNxVXRpbHNfMSA9IHJlcXVpcmUoXCIuL3Jlc3FVdGlsc1wiKTtcbmNvbnN0IHRlbXBvRWxlbWVudF8xID0gcmVxdWlyZShcIi4vdGVtcG9FbGVtZW50XCIpO1xuY29uc3QgZWRpdFRleHRVdGlsc18xID0gcmVxdWlyZShcIi4vZWRpdFRleHRVdGlsc1wiKTtcbmNvbnN0IFBJWEVMU19UT19NT1ZFX0JFRk9SRV9EUkFHID0gMjA7XG5jb25zdCBJTU1FRElBVEVMWV9SRU1PVkVfUE9JTlRFUl9MT0NLID0gJ0lNTUVESUFURUxZX1JFTU9WRV9QT0lOVEVSX0xPQ0snO1xuY29uc3QgTEFTVF9OQVZfVFJFRV9SRUZSRVNIX1RJTUUgPSAnTEFTVF9OQVZfVFJFRV9SRUZSRVNIX1RJTUUnO1xuLy8gVE9ETzogQ2hhbmdlIGFsbCBvZiB0aGlzIHRvIGJlIGEgcmVhY3Qgd3JhcHBlciBsaWJyYXJ5XG5jb25zdCBpbml0Q2hhbm5lbE1lc3NhZ2luZ0Z1bmN0aW9ucyA9ICgpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgU3RyaW5nLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc2ggPSAwLCBpLCBjaHI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hyID0gdGhpcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjtcbiAgICAgICAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfTtcbiAgICAvLyBXZSB3YW50IHRvIG1ha2UgZXZlbnQgbGlzdGVuZXJzIG5vbi1wYXNzaXZlLCBhbmQgdG8gZG8gc28gaGF2ZSB0byBjaGVja1xuICAgIC8vIHRoYXQgYnJvd3NlcnMgc3VwcG9ydCBFdmVudExpc3RlbmVyT3B0aW9ucyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuICAgIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgY29uc3QgbWFrZVBhc3NpdmVFdmVudE9wdGlvbiA9ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAvLyAgIGF0dGVtcHRzIHRvIGFjY2VzcyB0aGUgcGFzc2l2ZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlbiBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMjE5NzU4L2RldGVjdC1jaGFuZ2VzLWluLXRoZS1kb21cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRvIGRpc2Nvbm5lY3QgdGhlIG9ic2VydmVyXG4gICAgICovXG4gICAgY29uc3Qgb2JzZXJ2ZURPTSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIW9iaiB8fCBvYmoubm9kZVR5cGUgIT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICAgICAgICAgIGlmIChNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGEgbmV3IG9ic2VydmVyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0aGUgb2JzZXJ2ZXIgb2JzZXJ2ZSBmb28gZm9yIGNoYW5nZXMgaW4gY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUob2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnJvd3NlciBzdXBwb3J0IGZhbGxiYWNrXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7IH07XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHNlbGVjdGluZyBpbiBub3JtYWwgbW9kZSAobm90IG1ldGEga2V5KSwgY2FuIHNlbGVjdCBvbmUgbGV2ZWwgZG93biwgYSBzaWJsaW5nXG4gICAgICogb3IgYSBwYXJlbnQgb2YgdGhlIHNlbGVjdGVkIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb25zdCBnZXRTZWxlY3RhYmxlTmF2Tm9kZSA9IChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudEtleSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5TRUxFQ1RFRF9FTEVNRU5UX0tFWSk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5mcm9tS2V5KHNlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuRUxFTUVOVF9LRVlfVE9fTkFWX05PREUpO1xuICAgICAgICAvLyBNb3ZlIHVwIHRoZSB0cmVlIHVudGlsIHlvdSBmaW5kIHRoZSBmaXJzdCB2YWxpZCBuYXYgbm9kZVxuICAgICAgICBsZXQgZmlyc3ROYXZOb2RlID0gbnVsbDtcbiAgICAgICAgbGV0IHNlYXJjaE5vZGUgPSBlLnRhcmdldDtcbiAgICAgICAgd2hpbGUgKHNlYXJjaE5vZGUgJiYgIWZpcnN0TmF2Tm9kZSkge1xuICAgICAgICAgICAgZmlyc3ROYXZOb2RlID1cbiAgICAgICAgICAgICAgICBlbGVtZW50S2V5VG9OYXZOb2RlWygwLCBpZGVudGlmaWVyVXRpbHNfMS5nZXRFbGVtZW50S2V5RnJvbU5vZGUpKHNlYXJjaE5vZGUpIHx8ICcnXTtcbiAgICAgICAgICAgIHNlYXJjaE5vZGUgPSBzZWFyY2hOb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXJzdE5hdk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNBbmRUeXBlc18xLlNFTEVDVF9PUl9IT1ZFUl9TVE9SWUJPQVJEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTmF2Tm9kZU1hdGNoID0gKG5hdlRyZWVOb2RlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCBpZiB0aGVyZSBpcyBubyBzZWxlY3RlZCBlbGVtZW50LCBzZWUgY29kZSBsb2dpYyBiZWxvdyB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTm8gc2VsZWN0ZWQgZWxlbWVudCB3aGVuIGlzTmF2Tm9kZU1hdGNoIGNhbGxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuYXZUcmVlTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNvZGViYXNlIElEIGl0IHNob3VsZCBub3QgYmUgc2VsZWN0YWJsZSBhcyB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiBkbyB3aXRoIGl0XG4gICAgICAgICAgICBpZiAoIW5hdlRyZWVOb2RlLnRlbXBvRWxlbWVudC5jb2RlYmFzZUlkLnN0YXJ0c1dpdGgoJ3RlbXBvLScpIHx8XG4gICAgICAgICAgICAgICAgbmF2VHJlZU5vZGUudGVtcG9FbGVtZW50LmNvZGViYXNlSWQgPT09IG5hdlRyZWVVdGlsc18xLlNLSVBfUk9PVF9DT0RFQkFTRV9JRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0IG1hdGNoZXMsIHdlIGFscmVhZHkgcGFzc2VkIGFsbCBwb3NzaWJsZSBjaGlsZHJlbiwgc28gcmUtc2VsZWN0IGl0XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50LmlzRXF1YWwobmF2VHJlZU5vZGUudGVtcG9FbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW55IHBhcmVudCBpcyBvayB0byBzZWxlY3RcbiAgICAgICAgICAgIGlmIChuYXZUcmVlTm9kZS50ZW1wb0VsZW1lbnQuaXNQYXJlbnRPZihzZWxlY3RlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBwYXJlbnRzXG4gICAgICAgICAgICAvLyBQaWNrIHRoZSBmaXJzdCBwYXJlbnQgd2l0aCBhIGNvZGViYXNlIElEXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbmF2VHJlZU5vZGUucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhcGFyZW50LnRlbXBvRWxlbWVudC5jb2RlYmFzZUlkLnN0YXJ0c1dpdGgoJ3RlbXBvLScpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9uZSBsZXZlbCBkb3duXG4gICAgICAgICAgICBpZiAoKF9hID0gcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnRlbXBvRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRXF1YWwoc2VsZWN0ZWRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2libGluZyBvZiBhbnkgcGFyZW50XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBlbGVtZW50S2V5VG9OYXZOb2RlW3NlbGVjdGVkRWxlbWVudC5nZXRLZXkoKV07XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmXG4gICAgICAgICAgICAgICAgKChfZCA9IChfYyA9IChfYiA9IG5hdlRyZWVOb2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaW5jbHVkZXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBzZWxlY3RlZE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgZm91bmROYXZOb2RlID0gbnVsbDtcbiAgICAgICAgbGV0IHNlYXJjaE5hdk5vZGUgPSBmaXJzdE5hdk5vZGU7XG4gICAgICAgIHdoaWxlIChzZWFyY2hOYXZOb2RlKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkRWxlbWVudC5pc0VtcHR5KCkgJiYgIXNlbGVjdGVkRWxlbWVudC5pc1N0b3J5Ym9hcmQoKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgZWxlbWVudCBrZXkgbG9vcCBmcm9tIHRoaXMgZWxlbWVudCB1cCB0aGUgc3RhY2sgdG8gZmluZCB0aGUgZWxlbWVudCB0aGF0IGlzIHRoZSBkaXJlY3QgY2hpbGRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZXhwZWN0ZWQgc2VsZWN0ZWQgZWxlbWVudCwgc28gdGhhdCB5b3UgY2FuIG9ubHkgaG92ZXIgb25lIGxldmVsIGRlZXBlciB0aGFuIHlvdSd2ZSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGlmIChpc05hdk5vZGVNYXRjaChzZWFyY2hOYXZOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZE5hdk5vZGUgPSBzZWFyY2hOYXZOb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IHRoZSBsb29wIGFzIHdlIGZvdW5kIHRoZSBub2RlIHRoYXQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzZWxlY3RlZCBlbGVtZW50IGtleSwgb3IgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc3Rvcnlib2FyZCBpdHNlbGYsIGxvb3AgdXAgdG8gdGhlIHRvcC1tb3N0IGVsZW1lbnQgd2l0aCBhIGNvZGViYXNlIElEXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaE5hdk5vZGUudGVtcG9FbGVtZW50LmNvZGViYXNlSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoTmF2Tm9kZS50ZW1wb0VsZW1lbnQuY29kZWJhc2VJZC5zdGFydHNXaXRoKCd0ZW1wby0nKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZE5hdk5vZGUgPSBzZWFyY2hOYXZOb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSBkbyBub3QgZXhpdCB0aGUgbG9vcCBoZXJlIGFzIHdlIHdhbnQgdG8ga2VlcCBzZWFyY2hpbmcgZm9yIHRoZSB0b3AtbW9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VhcmNoTmF2Tm9kZSA9IHNlYXJjaE5hdk5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZE5hdk5vZGUgfHwgbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlck92ZXIgPSAoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBzZWxlY3RCb3R0b21Nb3N0RWxlbWVudCkgPT4ge1xuICAgICAgICBjb25zdCBwYXNzZWRUaHJvdWdoID0gcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICBjb25zdCBlZGl0aW5nVGV4dEluZm8gPSAoMCwgZWRpdFRleHRVdGlsc18xLmdldEVkaXRpbmdJbmZvKSgpO1xuICAgICAgICAvLyBBbGxvdyBvbiBwb2ludGVyIG92ZXIgZXZlbnRzIGlmIGVkaXRpbmcgKHNvIHdlIGNhbiBjbGljayBvdXQpXG4gICAgICAgIGlmIChlLmFsdEtleSB8fCAocGFzc2VkVGhyb3VnaCAmJiAhZWRpdGluZ1RleHRJbmZvKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKSgnbW91c2VEcmFnQ29udGV4dCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEhvdmVyZWRLZXkgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuSE9WRVJFRF9FTEVNRU5UX0tFWSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuRUxFTUVOVF9LRVlfVE9fTkFWX05PREUpIHx8IHt9O1xuICAgICAgICBsZXQgaG92ZXJlZE5hdk5vZGU7XG4gICAgICAgIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IHNlbGVjdEJvdHRvbU1vc3RFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50S2V5ID0gKDAsIGlkZW50aWZpZXJVdGlsc18xLmdldEVsZW1lbnRLZXlGcm9tTm9kZSkoZS50YXJnZXQpO1xuICAgICAgICAgICAgaG92ZXJlZE5hdk5vZGUgPSBlbGVtZW50S2V5VG9OYXZOb2RlW2VsZW1lbnRLZXldO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIC0+IHRoaXMgaXMgdGhlIHRvcC1tb3N0IG5vZGUgc28gaXQgc2hvdWxkIHRyaWdnZXIgYSBob3ZlciBvbiB0aGUgc3Rvcnlib2FyZFxuICAgICAgICAgICAgaWYgKCFob3ZlcmVkTmF2Tm9kZSAmJiBlLnRhcmdldC5wYXJlbnROb2RlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgaG92ZXJlZE5hdk5vZGUgPSBjb25zdGFudHNBbmRUeXBlc18xLlNFTEVDVF9PUl9IT1ZFUl9TVE9SWUJPQVJEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG92ZXJlZE5hdk5vZGUgPSBnZXRTZWxlY3RhYmxlTmF2Tm9kZShlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRLZXkgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0VMRUNURURfRUxFTUVOVF9LRVkpO1xuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkoY3VycmVudFNlbGVjdGVkS2V5KTtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgaG9sZGluZyBzaGlmdCwgb25seSBhbGxvdyBzZWxlY3Rpbmcgc2libGluZ3NcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgaG92ZXJlZE5hdk5vZGUgJiYgY3VycmVudFNlbGVjdGVkS2V5KSB7XG4gICAgICAgICAgICAvLyBUcnlpbmcgdG8gc2VsZWN0IHRoZSBlbnRpcmUgc3Rvcnlib2FyZCwgYWxsb3cgb25seSBpZiB0aGUgb3RoZXIgc2VsZWN0ZWQgZWxlbWVudCBpcyBhbHNvIGEgc3Rvcnlib2FyZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBob3ZlcmVkTmF2Tm9kZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAhY3VycmVudFNlbGVjdGVkRWxlbWVudC5pc1N0b3J5Ym9hcmQoKSkge1xuICAgICAgICAgICAgICAgIGhvdmVyZWROYXZOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaG92ZXJlZE5hdk5vZGUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgIShob3ZlcmVkTmF2Tm9kZSA9PT0gbnVsbCB8fCBob3ZlcmVkTmF2Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG92ZXJlZE5hdk5vZGUudGVtcG9FbGVtZW50LmlzU2libGluZ09mKGN1cnJlbnRTZWxlY3RlZEVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgIGhvdmVyZWROYXZOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhvdmVyZWROYXZOb2RlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEhvdmVyZWRLZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuSE9WRVJFRF9FTEVNRU5UX0tFWSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5IT1ZFUkVEX0VMRU1FTlRfS0VZLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50S2V5OiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhvdmVyZWROYXZOb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGhvdmVyZWROYXZOb2RlID09PSBjb25zdGFudHNBbmRUeXBlc18xLlNFTEVDVF9PUl9IT1ZFUl9TVE9SWUJPQVJEKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Rvcnlib2FyZEtleSA9IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5mb3JTdG9yeWJvYXJkKHN0b3J5Ym9hcmRJZCkuZ2V0S2V5KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIb3ZlcmVkS2V5ICE9PSBzdG9yeWJvYXJkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5IT1ZFUkVEX0VMRU1FTlRfS0VZLCBzdG9yeWJvYXJkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuSE9WRVJFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRLZXk6IHN0b3J5Ym9hcmRLZXksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXBvRWxlbWVudEtleSA9IGhvdmVyZWROYXZOb2RlLnRlbXBvRWxlbWVudC5nZXRLZXkoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRIb3ZlcmVkS2V5ICE9PSB0ZW1wb0VsZW1lbnRLZXkpIHtcbiAgICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5IT1ZFUkVEX0VMRU1FTlRfS0VZLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRLZXk6IHRlbXBvRWxlbWVudEtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkhPVkVSRURfRUxFTUVOVF9LRVksIHRlbXBvRWxlbWVudEtleSk7XG4gICAgICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsZWFySG92ZXJlZEVsZW1lbnRzID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50SG92ZXJlZEtleSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5IT1ZFUkVEX0VMRU1FTlRfS0VZKTtcbiAgICAgICAgaWYgKCFjdXJyZW50SG92ZXJlZEtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkhPVkVSRURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgICBlbGVtZW50S2V5OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkhPVkVSRURfRUxFTUVOVF9LRVksIG51bGwpO1xuICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAvLyBJZiBubyBidXR0b25zIGFyZSBwcmVzc2VkIHRoZSBkcmFnIGVuZCBldmVudCBtYXkgbm90IGhhdmUgY29ycmVjdGx5IHRyaWdnZXJlZFxuICAgICAgICAvLyByZXNldCB0aGUgZHJhZyBzdGF0ZVxuICAgICAgICBsZXQgbW91c2VEcmFnRGF0YSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKCdtb3VzZURyYWdDb250ZXh0Jyk7XG4gICAgICAgIGlmICghZS5idXR0b25zICYmIG1vdXNlRHJhZ0RhdGEpIHtcbiAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKCdtb3VzZURyYWdDb250ZXh0JywgbnVsbCk7XG4gICAgICAgICAgICBpZiAobW91c2VEcmFnRGF0YSA9PT0gbnVsbCB8fCBtb3VzZURyYWdEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3VzZURyYWdEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5EUkFHX0NBTkNFTF9FVkVOVCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHt9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW91c2VEcmFnRGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1wb3J0YW50RmllbGRzID0ge1xuICAgICAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZS5wYWdlWSxcbiAgICAgICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ21vdXNlUG9zJywgaW1wb3J0YW50RmllbGRzKTtcbiAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTU9VU0VfTU9WRV9FVkVOVCxcbiAgICAgICAgICAgIGV2ZW50OiBpbXBvcnRhbnRGaWVsZHMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobW91c2VEcmFnRGF0YSAmJiAhbW91c2VEcmFnRGF0YS5kcmFnZ2luZykge1xuICAgICAgICAgICAgY29uc3Qgem9vbVBlcmMgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKSgnem9vbVBlcmMnKSB8fCAxO1xuICAgICAgICAgICAgY29uc3QgdG90YWxNb3ZlbWVudFBpeGVscyA9IE1hdGguYWJzKG1vdXNlRHJhZ0RhdGEucGFnZVggLSBlLnBhZ2VYKSArXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMobW91c2VEcmFnRGF0YS5wYWdlWSAtIGUucGFnZVkpO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIGRyYWcgZXZlbnQgaWYgdGhlIHVzZXIgaGFzIG1vdmVkIGVub3VnaFxuICAgICAgICAgICAgaWYgKHRvdGFsTW92ZW1lbnRQaXhlbHMgPj0gUElYRUxTX1RPX01PVkVfQkVGT1JFX0RSQUcgLyB6b29tUGVyYykge1xuICAgICAgICAgICAgICAgIC8vIFJlc2VsZWN0IHRoZSBwYXJlbnQgaWYgdGhlcmUgd2FzIG9uZSB0byBzZWxlY3RcbiAgICAgICAgICAgICAgICBpZiAobW91c2VEcmFnRGF0YS5wYXJlbnRTZWxlY3RlZEVsZW1lbnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudEtleVRvTmF2Tm9kZSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5FTEVNRU5UX0tFWV9UT19OQVZfTk9ERSkgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hdk5vZGVUb1NlbGVjdCA9IGVsZW1lbnRLZXlUb05hdk5vZGVbbW91c2VEcmFnRGF0YS5wYXJlbnRTZWxlY3RlZEVsZW1lbnRLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmF2Tm9kZVRvU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEtleTogbW91c2VEcmFnRGF0YS5wYXJlbnRTZWxlY3RlZEVsZW1lbnRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJIVE1MOiAoX2EgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke21vdXNlRHJhZ0RhdGEucGFyZW50U2VsZWN0ZWRFbGVtZW50S2V5fWApLmdldCgwKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZLCBtb3VzZURyYWdEYXRhLnBhcmVudFNlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWlDb250ZXh0U2VsZWN0aW9uID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ2FpQ29udGV4dCcpO1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGVuYWJsZSBkcmFnZ2luZyBpZiB0aGUgQUkgY29udGV4dCBpcyBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKCFhaUNvbnRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ21vdXNlRHJhZ0NvbnRleHQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1vdXNlRHJhZ0RhdGEpLCB7IGRyYWdnaW5nOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50S2V5ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtzZWxlY3RlZEVsZW1lbnRLZXl9YCkuZ2V0KDApO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkRSQUdfU1RBUlRfRVZFTlQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbW91c2VEcmFnRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVySFRNTDogc2VsZWN0ZWRFbGVtZW50ID09PSBudWxsIHx8IHNlbGVjdGVkRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRFbGVtZW50Lm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlPYmplY3QgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoJ2JvZHknKS5nZXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhBQ0s6IE1hcmNoIDgsIDIwMjRcbiAgICAgICAgICAgICAgICAgICAgLy8gV2l0aG91dCB0aGlzIHdvcmthcm91bmQgZXZlbnRzIHN0YXkgaW5zaWRlIHRoZSBpZnJhbWUgc28gaXQncyBub3QgcG9zc2libGUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhY2sgbW91c2UgbW92ZW1lbnRzIG91dHNpZGUgdGhlIGlmcmFtZSB3aGVuIGNsaWNraW5nICYgZHJhZ2dpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgcG9pbnRlciBsb2NrIGFuZCBpbW1lZGlhdGVseSByZW1vdmUgaXQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZXZlbnRzIHN0YXJ0IHRvIHByb3BhZ2F0ZSB1cHdhcmRzIGluIHRoZSBvdXRlciBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoSU1NRURJQVRFTFlfUkVNT1ZFX1BPSU5URVJfTE9DSywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIChib2R5T2JqZWN0ID09PSBudWxsIHx8IGJvZHlPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlPYmplY3QucmVxdWVzdFBvaW50ZXJMb2NrKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ21vdXNlRHJhZ0NvbnRleHQnKSkge1xuICAgICAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0UGFyZW50RG9tRWxlbWVudEZvck5hdk5vZGUgPSAobmF2Tm9kZSkgPT4ge1xuICAgICAgICBpZiAoIW5hdk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG5hdk5vZGUgPT09IG51bGwgfHwgbmF2Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2Tm9kZS5pc0NvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkRG9tRWxlbWVudCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7bmF2Tm9kZS50ZW1wb0VsZW1lbnQuZ2V0S2V5KCl9YCkuZ2V0KDApO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkRG9tRWxlbWVudCA9PT0gbnVsbCB8fCBjaGlsZERvbUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkRG9tRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxpc3Qgb2YgcmVhbCBET00gZWxlbWVudHMgdGhhdCBhcmUgYXQgdGhlIHRvcCBsZXZlbCBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAgICBjb25zdCBlbGVtZW50S2V5VG9Mb29rdXBMaXN0ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkVMRU1FTlRfS0VZX1RPX0xPT0tVUF9MSVNUKSB8fCB7fTtcbiAgICAgICAgY29uc3QgbG9va3VwTGlzdCA9IGVsZW1lbnRLZXlUb0xvb2t1cExpc3RbbmF2Tm9kZS50ZW1wb0VsZW1lbnQuZ2V0S2V5KCldIHx8IFtdO1xuICAgICAgICBsZXQgY2hpbGREb21FbGVtZW50O1xuICAgICAgICBsb29rdXBMaXN0LmZvckVhY2goKGxvb2t1cEVsZW1lbnRLZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZERvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZERvbUVsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke2xvb2t1cEVsZW1lbnRLZXl9YCkuZ2V0KDApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkRG9tRWxlbWVudCA9PT0gbnVsbCB8fCBjaGlsZERvbUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkRG9tRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyRG93biA9IChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpID0+IHtcbiAgICAgICAgLy8gVGhpcyB2YXJpYWJsZSBkZXRlcm1pbmVzIHdoaWNoIGJ1dHRvbiB3YXMgdXNlZFxuICAgICAgICAvLyAxIC0+IGxlZnQsIDIgLT4gbWlkZGxlLCAzIC0+IHJpZ2h0XG4gICAgICAgIGlmIChlLndoaWNoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgdGhlIGVkaXQgZHluYW1pYyB0ZXh0IGJ1dHRvbiB0byBiZSBjbGlja2VkXG4gICAgICAgIGlmICgoMCwgaWRlbnRpZmllclV0aWxzXzEuaGFzQ2xhc3MpKGUudGFyZ2V0LCBpZGVudGlmaWVyVXRpbHNfMS5FRElUX1RFWFRfQlVUVE9OKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhc3NlZFRocm91Z2ggPSBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIGlmIChwYXNzZWRUaHJvdWdoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50S2V5ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkoc2VsZWN0ZWRFbGVtZW50S2V5KTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWROYXZOb2RlID0gb25TZWxlY3RFbGVtZW50KGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIGNvbnN0IHVzZVNlbGVjdGVkSWZEcmFnZ2luZyA9ICFzZWxlY3RlZEVsZW1lbnQuaXNFbXB0eSgpICYmXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQuaXNQYXJlbnRPZihzZWxlY3RlZE5hdk5vZGUgPT09IG51bGwgfHwgc2VsZWN0ZWROYXZOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZE5hdk5vZGUudGVtcG9FbGVtZW50KTtcbiAgICAgICAgbGV0IG9mZnNldFgsIG9mZnNldFk7XG4gICAgICAgIGlmIChzZWxlY3RlZE5hdk5vZGUgPT09IG51bGwgfHwgc2VsZWN0ZWROYXZOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZE5hdk5vZGUucGFnZUJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICBvZmZzZXRYID1cbiAgICAgICAgICAgICAgICBzZWxlY3RlZE5hdk5vZGUucGFnZUJvdW5kaW5nQm94LnBhZ2VYICtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWROYXZOb2RlLnBhZ2VCb3VuZGluZ0JveC53aWR0aCAvIDIgLVxuICAgICAgICAgICAgICAgICAgICBlLnBhZ2VYO1xuICAgICAgICAgICAgb2Zmc2V0WSA9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWROYXZOb2RlLnBhZ2VCb3VuZGluZ0JveC5wYWdlWSArXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTmF2Tm9kZS5wYWdlQm91bmRpbmdCb3guaGVpZ2h0IC8gMiAtXG4gICAgICAgICAgICAgICAgICAgIGUucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1wb3J0YW50RmllbGRzID0ge1xuICAgICAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZS5wYWdlWSxcbiAgICAgICAgICAgIC8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gd2hlcmUgdGhlIHVzZXIgY2xpY2tlZCBhbmQgdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFksXG4gICAgICAgICAgICAvLyBVc2VkIHRvIHJlc2VsZWN0IHRoZSBwYXJlbnQgaWYgdGhlIHVzZXIgc3RhcnRzIHRvIG1vdmVcbiAgICAgICAgICAgIHBhcmVudFNlbGVjdGVkRWxlbWVudEtleTogdXNlU2VsZWN0ZWRJZkRyYWdnaW5nXG4gICAgICAgICAgICAgICAgPyBzZWxlY3RlZEVsZW1lbnRLZXlcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuRUxFTUVOVF9LRVlfVE9fTkFWX05PREUpIHx8IHt9O1xuICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBlbGVtZW50IChhY3R1YWwgRE9NIGVsZW1lbnQpIHRoYXQgdGhpcyBub2RlIGlzIGJlaW5nIGRyYWdnZWQgaW5zaWRlXG4gICAgICAgIC8vIFRvIGRvIHRoaXMgcGljayBvbmUgY2hpbGQgZWxlbWVudCB0aGF0IGlzIGJlaW5nIGRyYWdnZWQgKGNhbiBiZSBtdWx0aXBsZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBiZWluZyBkcmFnZ2VkIGlzIGEgY29tcG9uZW50KSxcbiAgICAgICAgLy8gYW5kIGdldCBpdHMgcGFyZW50IGluIHRoZSBET01cbiAgICAgICAgY29uc3QgbmF2Tm9kZVRvVXNlRm9yRHJhZ2dpbmcgPSB1c2VTZWxlY3RlZElmRHJhZ2dpbmdcbiAgICAgICAgICAgID8gZWxlbWVudEtleVRvTmF2Tm9kZVtzZWxlY3RlZEVsZW1lbnRLZXldXG4gICAgICAgICAgICA6IHNlbGVjdGVkTmF2Tm9kZTtcbiAgICAgICAgY29uc3QgcGFyZW50RG9tRWxlbWVudCA9IGdldFBhcmVudERvbUVsZW1lbnRGb3JOYXZOb2RlKG5hdk5vZGVUb1VzZUZvckRyYWdnaW5nKTtcbiAgICAgICAgaWYgKHBhcmVudERvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGltcG9ydGFudEZpZWxkc1snc2VsZWN0ZWRQYXJlbnREaXNwbGF5J10gPSAoMCwgY3NzRnVuY3Rpb25zXzEuY3NzRXZhbCkocGFyZW50RG9tRWxlbWVudCwgJ2Rpc3BsYXknKTtcbiAgICAgICAgICAgIGltcG9ydGFudEZpZWxkc1snc2VsZWN0ZWRQYXJlbnRGbGV4RGlyZWN0aW9uJ10gPSAoMCwgY3NzRnVuY3Rpb25zXzEuY3NzRXZhbCkocGFyZW50RG9tRWxlbWVudCwgJ2ZsZXgtZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWlDb250ZXh0U2VsZWN0aW9uID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ2FpQ29udGV4dCcpO1xuICAgICAgICAvLyBEb24ndCBlbmFibGUgZHJhZ2dpbmcgaWYgdGhlIEFJIGNvbnRleHQgaXMgZW5hYmxlZFxuICAgICAgICBpZiAoIWFpQ29udGV4dFNlbGVjdGlvbikge1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ21vdXNlRHJhZ0NvbnRleHQnLCBpbXBvcnRhbnRGaWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIGNvbnN0IG1vdXNlRHJhZ0RhdGEgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKSgnbW91c2VEcmFnQ29udGV4dCcpO1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKSgnbW91c2VEcmFnQ29udGV4dCcsIG51bGwpO1xuICAgICAgICBpZiAobW91c2VEcmFnRGF0YSA9PT0gbnVsbCB8fCBtb3VzZURyYWdEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3VzZURyYWdEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuRFJBR19FTkRfRVZFTlQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH07XG4gICAgY29uc3Qgb25TZWxlY3RFbGVtZW50ID0gKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgZHJpdmVNb2RlRW5hYmxlZCA9ICEhKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRTZXNzaW9uU3RvcmFnZUl0ZW0pKCdkcml2ZU1vZGVFbmFibGVkJywgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgaWYgKGRyaXZlTW9kZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuRUxFTUVOVF9LRVlfVE9fTkFWX05PREUpIHx8IHt9O1xuICAgICAgICBsZXQgc2VsZWN0ZWROYXZOb2RlO1xuICAgICAgICBpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudEtleSA9ICgwLCBpZGVudGlmaWVyVXRpbHNfMS5nZXRFbGVtZW50S2V5RnJvbU5vZGUpKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHNlbGVjdGVkTmF2Tm9kZSA9IGVsZW1lbnRLZXlUb05hdk5vZGVbZWxlbWVudEtleV07XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgLT4gdGhpcyBpcyB0aGUgdG9wLW1vc3Qgbm9kZSBzbyBpdCBzaG91bGQgdHJpZ2dlciBhIHNlbGVjdCBvbiB0aGUgc3Rvcnlib2FyZFxuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZE5hdk5vZGUgJiYgZS50YXJnZXQucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkTmF2Tm9kZSA9IGNvbnN0YW50c0FuZFR5cGVzXzEuU0VMRUNUX09SX0hPVkVSX1NUT1JZQk9BUkQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5hdk5vZGUgPSBnZXRTZWxlY3RhYmxlTmF2Tm9kZShlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSB2YWxpZCBuYXYgbm9kZSwgaXQncyBub3Qgc29tZXRoaW5nIHdlIHRyYWNrIC0gZGVzZWxlY3QgYWxsXG4gICAgICAgIGlmICghc2VsZWN0ZWROYXZOb2RlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdGVkRWxlbWVudEtleSkge1xuICAgICAgICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRLZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZLCBudWxsKTtcbiAgICAgICAgICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkoY3VycmVudFNlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNdWx0aVNlbGVjdGVkS2V5cyA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMpIHx8IFtdO1xuICAgICAgICBsZXQgbmV3U2VsZWN0ZWRFbGVtZW50ID0gdHlwZW9mIHNlbGVjdGVkTmF2Tm9kZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZvclN0b3J5Ym9hcmQoc3Rvcnlib2FyZElkKVxuICAgICAgICAgICAgOiBzZWxlY3RlZE5hdk5vZGUudGVtcG9FbGVtZW50O1xuICAgICAgICBsZXQgbmV3TXVsdGlTZWxlY3RLZXlzID0gW107XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIGhvbGRpbmcgc2hpZnQsIGNoZWNrIGlmIHdlIGNhbiBtdWx0aS1zZWxlY3QgKHNvbWV0aGluZyBoYXMgdG8gYmUgYWxyZWFkeSBzZWxlY3RlZClcbiAgICAgICAgLy8gTm90ZTogdGhpcyBsb2dpYyBnZW5lcmFsbHkgbWF0Y2hlcyB0aGUgbG9naWMgaW4gdGhlIGlmcmFtZSBzbGljZSBvbiB0ZW1wby13ZWJcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgY3VycmVudFNlbGVjdGVkRWxlbWVudEtleSkge1xuICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgYXJlIGRlc2VsZWN0aW5nXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VG9EZXNlbGVjdCA9IGN1cnJlbnRNdWx0aVNlbGVjdGVkS2V5c1xuICAgICAgICAgICAgICAgIC5tYXAoKGVsZW1lbnRLZXkpID0+IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5mcm9tS2V5KGVsZW1lbnRLZXkpKVxuICAgICAgICAgICAgICAgIC5maW5kKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtZW50LmlzUGFyZW50T2YobmV3U2VsZWN0ZWRFbGVtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlzRXF1YWwobmV3U2VsZWN0ZWRFbGVtZW50KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50VG9EZXNlbGVjdCkge1xuICAgICAgICAgICAgICAgIG5ld011bHRpU2VsZWN0S2V5cyA9IGN1cnJlbnRNdWx0aVNlbGVjdGVkS2V5cy5maWx0ZXIoKGVsZW1lbnRLZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRLZXkgIT09IGVsZW1lbnRUb0Rlc2VsZWN0LmdldEtleSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFBpY2sgYSBuZXcgZWxlbWVudCB0byBiZSB0aGUgbWFpbiBzZWxlY3RlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gTm90ZSwgaWYgdGhlIGxlbmd0aCBpcyAxLCB0aGVyZSBpcyBsb2dpYyBmdXJ0aGVyIGRvd24gdG8gaGFuZGxlIHRoYXQgY2FzZSBleHBsaWNpdGx5ICh0byBleGl0IG11bHRpc2VsZWN0IG1vZGUpXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRUb0Rlc2VsZWN0LmlzRXF1YWwoY3VycmVudFNlbGVjdGVkRWxlbWVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3TXVsdGlTZWxlY3RLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50S2V5OiBuZXdNdWx0aVNlbGVjdEtleXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckhUTUw6IChfYSA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7bmV3TXVsdGlTZWxlY3RLZXlzWzBdfWApLmdldCgwKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5TRUxFQ1RFRF9FTEVNRU5UX0tFWSwgbmV3TXVsdGlTZWxlY3RLZXlzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIGFkZCB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRTZWxlY3RlZEVsZW1lbnQuaXNTaWJsaW5nT2YobmV3U2VsZWN0ZWRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TXVsdGlTZWxlY3RlZEtleXMgPT09IG51bGwgfHwgY3VycmVudE11bHRpU2VsZWN0ZWRLZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50TXVsdGlTZWxlY3RlZEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld011bHRpU2VsZWN0S2V5cyA9IGN1cnJlbnRNdWx0aVNlbGVjdGVkS2V5cy5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld011bHRpU2VsZWN0S2V5cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYXNlIHRoZSB1c2VyIGlzIHRyeWluZyB0byBtdWx0aXNlbGVjdCBidXQgaXQncyBub3Qgc29tZXRoaW5nIHRoYXQncyBhbGxvd2VkLCBqdXN0IHJldHVybiBidXQgZG9uJ3QgbWFrZSBhbnkgY2hhbmdlc1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIG11bHRpc2VsZWN0IG1vZGUsIHNldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICBpZiAobmV3TXVsdGlTZWxlY3RLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMsXG4gICAgICAgICAgICAgICAgZWxlbWVudEtleXM6IG5ld011bHRpU2VsZWN0S2V5cyxcbiAgICAgICAgICAgICAgICBvdXRlckhUTUxzOiBuZXdNdWx0aVNlbGVjdEtleXMgPT09IG51bGwgfHwgbmV3TXVsdGlTZWxlY3RLZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdNdWx0aVNlbGVjdEtleXMubWFwKChlbGVtZW50S2V5KSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7ZWxlbWVudEtleX1gKS5nZXQoMCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vdXRlckhUTUw7IH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLCBuZXdNdWx0aVNlbGVjdEtleXMpO1xuICAgICAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgKDAsIGVkaXRUZXh0VXRpbHNfMS50ZWFyZG93bkVkaXRhYmxlVGV4dCkocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBDYW5ub3QgcGVyZm9ybSByZWd1bGFyIGFjdGlvbnMgb24gYW55IHBhcnRpY3VsYXIgbm9kZVxuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSAtIG11bHRpc2VsZWN0aW5nIGJ1dCBkZXNlbGVjdGluZyBkb3duIHRvIDEsIHN0b3AgdGhlIG11bHRpc2VsZWN0IG1vZGVcbiAgICAgICAgaWYgKG5ld011bHRpU2VsZWN0S2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdGVkRWxlbWVudCA9IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5mcm9tS2V5KG5ld011bHRpU2VsZWN0S2V5c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xlYXJNdWx0aVNlbGVjdFN0YXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gTm90IG11bHRpLXNlbGVjdGluZywgc28gY2xlYXIgdGhlIG11bHRpc2VsZWN0IHN0YXRlXG4gICAgICAgICAgICAvLyBXYW50IHRvIGRvIHRoaXMgYWZ0ZXIgc2V0dGluZyB0aGUgc2VsZWN0ZWQgZWxlbWVudCB0byBwcmV2ZW50IGZsYXNoaW5nXG4gICAgICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRLZXlzOiBbXSxcbiAgICAgICAgICAgICAgICBvdXRlckhUTUxzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLk1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZUywgbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNlbGVjdGluZyB0aGUgc3Rvcnlib2FyZCBmcm9tIHdpdGhpblxuICAgICAgICBpZiAobmV3U2VsZWN0ZWRFbGVtZW50LmlzU3Rvcnlib2FyZCgpKSB7XG4gICAgICAgICAgICBpZiAobmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpICE9PSBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEtleTogbmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpLFxuICAgICAgICAgICAgICAgICAgICBvdXRlckhUTUw6IChfYiA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7bmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpfWApLmdldCgwKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0VMRUNURURfRUxFTUVOVF9LRVksIG5ld1NlbGVjdGVkRWxlbWVudC5nZXRLZXkoKSk7XG4gICAgICAgICAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGVkaXRUZXh0VXRpbHNfMS50ZWFyZG93bkVkaXRhYmxlVGV4dCkocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgICAgIGNsZWFyTXVsdGlTZWxlY3RTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBlZGl0VGV4dFV0aWxzXzEuY3VycmVudGx5RWRpdGluZykoKSkge1xuICAgICAgICAgICAgY29uc3QgZWRpdGluZ0luZm8gPSAoMCwgZWRpdFRleHRVdGlsc18xLmdldEVkaXRpbmdJbmZvKSgpO1xuICAgICAgICAgICAgaWYgKChlZGl0aW5nSW5mbyA9PT0gbnVsbCB8fCBlZGl0aW5nSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdGluZ0luZm8ua2V5KSAhPT0gY3VycmVudFNlbGVjdGVkRWxlbWVudEtleSkge1xuICAgICAgICAgICAgICAgICgwLCBlZGl0VGV4dFV0aWxzXzEudGVhcmRvd25FZGl0YWJsZVRleHQpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhck11bHRpU2VsZWN0U3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKCgwLCBlZGl0VGV4dFV0aWxzXzEuY2FuRWRpdFRleHQpKG5ld1NlbGVjdGVkRWxlbWVudCkgJiZcbiAgICAgICAgICAgIG5ld1NlbGVjdGVkRWxlbWVudC5nZXRLZXkoKSA9PT0gY3VycmVudFNlbGVjdGVkRWxlbWVudEtleSkge1xuICAgICAgICAgICAgKDAsIGVkaXRUZXh0VXRpbHNfMS5zZXR1cEVkaXRhYmxlVGV4dCkobmV3U2VsZWN0ZWRFbGVtZW50LCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCkgPT09IGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRLZXkpIHtcbiAgICAgICAgICAgIGNsZWFyTXVsdGlTZWxlY3RTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkTmF2Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgIGVsZW1lbnRLZXk6IG5ld1NlbGVjdGVkRWxlbWVudC5nZXRLZXkoKSxcbiAgICAgICAgICAgIG91dGVySFRNTDogKF9jID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtuZXdTZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCl9YCkuZ2V0KDApKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub3V0ZXJIVE1MLFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZLCBuZXdTZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCkpO1xuICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIGNsZWFyTXVsdGlTZWxlY3RTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWROYXZOb2RlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBldmVudHMgd2VyZSBwYXNzZWQgdGhyb3VnaFxuICAgICAqL1xuICAgIGNvbnN0IHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQgPSAoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGRyaXZlTW9kZUVuYWJsZWQgPSAhISgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtKSgnZHJpdmVNb2RlRW5hYmxlZCcsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIGNvbnN0IGVkaXRpbmdUZXh0SW5mbyA9ICgwLCBlZGl0VGV4dFV0aWxzXzEuZ2V0RWRpdGluZ0luZm8pKCk7XG4gICAgICAgIGlmIChkcml2ZU1vZGVFbmFibGVkIHx8IGVkaXRpbmdUZXh0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChlKTtcbiAgICAgICAgKF9iID0gZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnN0b3BQcm9wYWdhdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2tFbGVtZW50Q29udGV4dE1lbnUgPSAoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcGFzc2VkVGhyb3VnaCA9IHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgaWYgKHBhc3NlZFRocm91Z2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIE1vdXNlIGRvd24gaXMgY2FsbGVkIHdoZW4gYSB1c2VyIGNsaWNrcyB0aGUgY29udGV4dCBtZW51LCBidXQgbm90IG1vdXNlIHVwLCBzbyBjbGVhciB0aGUgbW91c2UgZG93blxuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKSgnbW91c2VEcmFnQ29udGV4dCcsIG51bGwpO1xuICAgICAgICBjb25zdCBlbGVtZW50S2V5VG9OYXZOb2RlID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkVMRU1FTlRfS0VZX1RPX05BVl9OT0RFKSB8fCB7fTtcbiAgICAgICAgbGV0IHJlcXVlc3RlZE5hdk5vZGU7XG4gICAgICAgIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50S2V5ID0gKDAsIGlkZW50aWZpZXJVdGlsc18xLmdldEVsZW1lbnRLZXlGcm9tTm9kZSkoZS50YXJnZXQpO1xuICAgICAgICAgICAgcmVxdWVzdGVkTmF2Tm9kZSA9IGVsZW1lbnRLZXlUb05hdk5vZGVbZWxlbWVudEtleV07XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgLT4gdGhpcyBpcyB0aGUgdG9wLW1vc3Qgbm9kZSBzbyBpdCBzaG91bGQgdHJpZ2dlciBhIGNvbnRleHQgbWVudSBvbiB0aGUgc3Rvcnlib2FyZFxuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0ZWROYXZOb2RlICYmIGUudGFyZ2V0LnBhcmVudE5vZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWROYXZOb2RlID0gY29uc3RhbnRzQW5kVHlwZXNfMS5TRUxFQ1RfT1JfSE9WRVJfU1RPUllCT0FSRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RlZE5hdk5vZGUgPSBnZXRTZWxlY3RhYmxlTmF2Tm9kZShlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICAgICAgY29uc3QgY3VycmVudE11bHRpU2VsZWN0ZWRLZXlzID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLk1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZUyk7XG4gICAgICAgIGlmICghcmVxdWVzdGVkTmF2Tm9kZSB8fCB0eXBlb2YgcmVxdWVzdGVkTmF2Tm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0ZWROYXZOb2RlID09PSBjb25zdGFudHNBbmRUeXBlc18xLlNFTEVDVF9PUl9IT1ZFUl9TVE9SWUJPQVJEICYmXG4gICAgICAgICAgICAgICAgIShjdXJyZW50TXVsdGlTZWxlY3RlZEtleXMgPT09IG51bGwgfHwgY3VycmVudE11bHRpU2VsZWN0ZWRLZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50TXVsdGlTZWxlY3RlZEtleXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3J5Ym9hcmRLZXkgPSB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQuZm9yU3Rvcnlib2FyZChzdG9yeWJvYXJkSWQpLmdldEtleSgpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5ID09PSBzdG9yeWJvYXJkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEtleTogc3Rvcnlib2FyZEtleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0VMRUNURURfRUxFTUVOVF9LRVksIHN0b3J5Ym9hcmRLZXkpO1xuICAgICAgICAgICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGV4dFJlcXVlc3RlZEVsZW1lbnRLZXkgPSBudWxsO1xuICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnRLZXkgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0VMRUNURURfRUxFTUVOVF9LRVkpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQuZnJvbUtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICAgICAgICAvLyBEb24ndCBzZWxlY3QgYW55IGNoaWxkcmVuIGFzIHRoZSB1c2VyIG1pZ2h0IGJlIHJpZ2h0IGNsaWNraW5nIGEgbm9kZSB0aGV5IHNlbGVjdGVkXG4gICAgICAgIGlmICghcmVxdWVzdGVkTmF2Tm9kZS50ZW1wb0VsZW1lbnQuaXNFcXVhbChzZWxlY3RlZEVsZW1lbnQpICYmXG4gICAgICAgICAgICAhc2VsZWN0ZWRFbGVtZW50LmlzUGFyZW50T2YocmVxdWVzdGVkTmF2Tm9kZS50ZW1wb0VsZW1lbnQpICYmXG4gICAgICAgICAgICAhKGN1cnJlbnRNdWx0aVNlbGVjdGVkS2V5cyA9PT0gbnVsbCB8fCBjdXJyZW50TXVsdGlTZWxlY3RlZEtleXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRNdWx0aVNlbGVjdGVkS2V5cy5sZW5ndGgpIC8vIEFsc28gZG9uJ3Qgc2VsZWN0IGFueXRoaW5nIG5ldyBpZiBpbiBtdWx0aXNlbGVjdCBtb2RlXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29udGV4dFJlcXVlc3RlZEVsZW1lbnRLZXkgPSByZXF1ZXN0ZWROYXZOb2RlLnRlbXBvRWxlbWVudC5nZXRLZXkoKTtcbiAgICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgICAgICBlbGVtZW50S2V5OiBjb250ZXh0UmVxdWVzdGVkRWxlbWVudEtleSxcbiAgICAgICAgICAgICAgICBvdXRlckhUTUw6IChfYSA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7Y29udGV4dFJlcXVlc3RlZEVsZW1lbnRLZXl9YCkuZ2V0KDApKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3V0ZXJIVE1MLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0VMRUNURURfRUxFTUVOVF9LRVksIGNvbnRleHRSZXF1ZXN0ZWRFbGVtZW50S2V5KTtcbiAgICAgICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbXBvcnRhbnRGaWVsZHMgPSB7XG4gICAgICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgICAgIH07XG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkNPTlRFWFRfUkVRVUVTVEVELFxuICAgICAgICAgICAgZXZlbnQ6IGltcG9ydGFudEZpZWxkcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBidWlsZEFuZFNlbmROYXZUcmVlID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgdHJlZUVsZW1lbnRMb29rdXAsIHNjb3BlTG9va3VwLCBzdG9yeWJvYXJkQ29tcG9uZW50RWxlbWVudCkgPT4ge1xuICAgICAgICBsZXQgdHJlZUVsZW1lbnRzID0gdHJlZUVsZW1lbnRMb29rdXA7XG4gICAgICAgIGlmICghdHJlZUVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0cmVlRWxlbWVudHMgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuVFJFRV9FTEVNRU5UX0xPT0tVUCkgfHwge307XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjb3BlcyA9IHNjb3BlTG9va3VwO1xuICAgICAgICBpZiAoIXNjb3Blcykge1xuICAgICAgICAgICAgc2NvcGVzID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNDT1BFX0xPT0tVUCkgfHwge307XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0b3J5Ym9hcmRDb21wb25lbnQgPSBzdG9yeWJvYXJkQ29tcG9uZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHN0b3J5Ym9hcmRDb21wb25lbnRFbGVtZW50ID09PSAnRVhQTElDSVRfTk9ORScpIHtcbiAgICAgICAgICAgIHN0b3J5Ym9hcmRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzdG9yeWJvYXJkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBzdG9yeWJvYXJkQ29tcG9uZW50ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNUT1JZQk9BUkRfQ09NUE9ORU5UKSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290UmVhY3RFbGVtZW50ID0gKDAsIHJlc3FVdGlsc18xLmdldFJvb3RSZWFjdEVsZW1lbnQpKCk7XG4gICAgICAgIGNvbnN0IHJlYWN0VHJlZSA9ICgwLCByZXNxVXRpbHNfMS5idWlsZE5vZGVUcmVlKShyb290UmVhY3RFbGVtZW50LCBudWxsKTtcbiAgICAgICAgY29uc3QgbG9va3VwSWRUb1JlYWN0VHJlZU1hcCA9IHt9O1xuICAgICAgICAoMCwgcmVzcVV0aWxzXzEuYnVpbGRUcmVlTG9va3VwTWFwKShyZWFjdFRyZWUsIGxvb2t1cElkVG9SZWFjdFRyZWVNYXApO1xuICAgICAgICBjb25zdCBrbm93bkNvbXBvbmVudE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBrbm93bkNvbXBvbmVudEluc3RhbmNlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmICh0cmVlRWxlbWVudHMpIHtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModHJlZUVsZW1lbnRzKS5mb3JFYWNoKCh0cmVlRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlRWxlbWVudC50eXBlID09PSAnY29tcG9uZW50JyB8fFxuICAgICAgICAgICAgICAgICAgICB0cmVlRWxlbWVudC50eXBlID09PSAnc3Rvcnlib29rLWNvbXBvbmVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAga25vd25Db21wb25lbnROYW1lcy5hZGQodHJlZUVsZW1lbnQuY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmVlRWxlbWVudC50eXBlID09PSAnY29tcG9uZW50LWluc3RhbmNlJykge1xuICAgICAgICAgICAgICAgICAgICBrbm93bkNvbXBvbmVudEluc3RhbmNlTmFtZXMuYWRkKHRyZWVFbGVtZW50LmNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRLZXlUb0xvb2t1cExpc3QgPSB7fTtcbiAgICAgICAgY29uc3QgZWxlbWVudEtleVRvTmF2Tm9kZSA9IHt9O1xuICAgICAgICBjb25zdCBidWlsdE5hdlRyZWUgPSAoMCwgbmF2VHJlZVV0aWxzXzEuYnVpbGROYXZGb3JOb2RlKShzdG9yeWJvYXJkSWQsIHVuZGVmaW5lZCwgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKCdib2R5JykuZ2V0KDApLCAnJywgJ3Jvb3QnLCBzY29wZXMsIHRyZWVFbGVtZW50cywgbG9va3VwSWRUb1JlYWN0VHJlZU1hcCwga25vd25Db21wb25lbnROYW1lcywga25vd25Db21wb25lbnRJbnN0YW5jZU5hbWVzLCBlbGVtZW50S2V5VG9Mb29rdXBMaXN0LCBlbGVtZW50S2V5VG9OYXZOb2RlKTtcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkVMRU1FTlRfS0VZX1RPX0xPT0tVUF9MSVNULCBlbGVtZW50S2V5VG9Mb29rdXBMaXN0KTtcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkNVUlJFTlRfTkFWX1RSRUUsIGJ1aWx0TmF2VHJlZSk7XG4gICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5FTEVNRU5UX0tFWV9UT19OQVZfTk9ERSwgZWxlbWVudEtleVRvTmF2Tm9kZSk7XG4gICAgICAgICgwLCByZXNxVXRpbHNfMS5jbGVhckxvb2t1cHNGcm9tVHJlZSkocmVhY3RUcmVlKTtcbiAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTkFWX1RSRUUsXG4gICAgICAgICAgICBuYXZUcmVlOiBidWlsdE5hdlRyZWUsXG4gICAgICAgICAgICBvdXRlckh0bWw6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSdW4gY2FsbGJhY2tzXG4gICAgICAgICgwLCBuYXZUcmVlVXRpbHNfMS5ydW5OYXZUcmVlQnVpbHRDYWxsYmFja3MpKCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkZsdXNoU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgIC8vIEZpbmQgYWxsIGluc3RhbnQgdXBkYXRlIHN0eWxpbmcgY2xhc3NlcyB0byBkZWxldGVcbiAgICAgICAgY29uc3QgY2xhc3Nlc1RvRGVsZXRlID0gW107XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgKltjbGFzcyo9JHtpZGVudGlmaWVyVXRpbHNfMS5URU1QT19JTlNUQU5UX1VQREFURV9TVFlMSU5HX1BSRUZJWH1dYCkuZWFjaCgoaSwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IChlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZS5zdGFydHNXaXRoKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0lOU1RBTlRfVVBEQVRFX1NUWUxJTkdfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzVG9EZWxldGUucHVzaChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAqWyR7aWRlbnRpZmllclV0aWxzXzEuVEVNUE9fREVMRVRFX0FGVEVSX1JFRlJFU0h9PXRydWVdYCkuYXR0cihpZGVudGlmaWVyVXRpbHNfMS5URU1QT19RVUVVRV9ERUxFVEVfQUZURVJfSE9UX1JFTE9BRCwgJ3RydWUnKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGFkZCBjbGFzcyBpbnN0YW50IHVwZGF0ZSBxdWV1ZSBhcyB0aG9zZSBpdGVtcyB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIGhvdCByZWxvYWRcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoY2hhbmdlSXRlbUZ1bmN0aW9uc18xLkFERF9DTEFTU19JTlNUQU5UX1VQREFURV9RVUVVRSwgW10pO1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKSgnUE9TVF9IT1RfUkVMT0FEX0NMRUFSJywge1xuICAgICAgICAgICAgY2xhc3Nlc1RvRGVsZXRlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNsZWFySW5zdGFudFVwZGF0ZXNBbmRTZW5kTmF2VHJlZSA9IChwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpID0+IHtcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoTEFTVF9OQVZfVFJFRV9SRUZSRVNIX1RJTUUsIG5ldyBEYXRlKCkpO1xuICAgICAgICBjb25zdCB7IGNsYXNzZXNUb0RlbGV0ZSB9ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ1BPU1RfSE9UX1JFTE9BRF9DTEVBUicpIHx8IHt9O1xuICAgICAgICAvLyBEZWxldGUgYWxsIGluc3RhbnQgdXBkYXRlIGNoYW5nZWQgZWxlbWVudHNcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAqWyR7aWRlbnRpZmllclV0aWxzXzEuVEVNUE9fUVVFVUVfREVMRVRFX0FGVEVSX0hPVF9SRUxPQUR9PXRydWVdYCkucmVtb3ZlKCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBhZGRlZCBkaXNwbGF5IG5vbmVzXG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuVEVNUE9fRElTUExBWV9OT05FX1VOVElMX1JFRlJFU0hfQ0xBU1N9YCkucmVtb3ZlQ2xhc3MoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fRElTUExBWV9OT05FX1VOVElMX1JFRlJFU0hfQ0xBU1MpO1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYCpbJHtpZGVudGlmaWVyVXRpbHNfMS5URU1QT19JTlNUQU5UX1VQREFURX09dHJ1ZV1gKS5yZW1vdmVBdHRyKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX0lOU1RBTlRfVVBEQVRFKTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAqWyR7aWRlbnRpZmllclV0aWxzXzEuVEVNUE9fRE9fTk9UX1NIT1dfSU5fTkFWX1VOVElMX1JFRlJFU0h9PXRydWVdYCkucmVtb3ZlQXR0cihpZGVudGlmaWVyVXRpbHNfMS5URU1QT19ET19OT1RfU0hPV19JTl9OQVZfVU5USUxfUkVGUkVTSCk7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7Y2hhbmdlSXRlbUZ1bmN0aW9uc18xLlRFTVBPUkFSWV9TVFlMSU5HX0NMQVNTX05BTUV9YCkucmVtb3ZlQ2xhc3MoY2hhbmdlSXRlbUZ1bmN0aW9uc18xLlRFTVBPUkFSWV9TVFlMSU5HX0NMQVNTX05BTUUpO1xuICAgICAgICAvLyBBbnkgY2xhc3NlcyBtYXJrZWQgdG8gZGVsZXRlIGJlZm9yZSB0aGUgaG90IHJlbG9hZFxuICAgICAgICBjbGFzc2VzVG9EZWxldGUgPT09IG51bGwgfHwgY2xhc3Nlc1RvRGVsZXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGFzc2VzVG9EZWxldGUuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2Nsc31gKS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3QWRkQ2xhc3NRdWV1ZSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKGNoYW5nZUl0ZW1GdW5jdGlvbnNfMS5BRERfQ0xBU1NfSU5TVEFOVF9VUERBVEVfUVVFVUUpIHx8IFtdO1xuICAgICAgICAvLyBBbnkgYXR0cmlidXRlcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHN0eWxpbmcgcHJlZml4IGxlZnRvdmVyIG1lYW4gdGhhdCB0aGUgY2xhc3MgbmVlZHMgdG8gYmUgcmUtYXBwbGllZFxuICAgICAgICAvLyB0aGVzZSBhcmUgY2xhc3NlcyB0aGF0IHdlcmUgYWRkZWQgaW4gaW5zdGFudCB1cGRhdGVzIHdoaWxlIHRoZSBob3QgcmVsb2FkIHdhcyBpbiBwcm9ncmVzc1xuICAgICAgICBuZXdBZGRDbGFzc1F1ZXVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29kZWJhc2VJZCwgY2xhc3NOYW1lIH0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKGNvZGViYXNlSWQgJiYgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtjb2RlYmFzZUlkfWApLmF0dHIoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtjb2RlYmFzZUlkfWApLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWJ1aWxkIHRoZSBuYXYgdHJlZSBvbiBET00gY2hhbmdlZCBhZnRlciBzb21lIHRpbWUgaGFzIHBhc3NlZFxuICAgICAgICAvLyB0aGlzIGdpdmVzIHRoZSByZWFjdCBmaWJlciB0aW1lIHRvIGJlIGZ1bGx5IHJlY29uY2lsZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1aWxkQW5kU2VuZE5hdlRyZWUocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFUlJPUjogQ291bGQgbm90IHJlLWNyZWF0ZSBuYXYgdHJlZSBvbiBET00gY2hhbmdlLCAnICsgZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uRE9NQ2hhbmdlZCA9IChtdXRhdGlvbnMsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgXG4gICAgLy8gSWYgc2V0IHRvIHRydWUgdGhpcyBpcyBjYWxsZWQgZnJvbSB0aGUgc2hhZG93IHJvb3QgZm9yIHRoZSBuZXh0anMgYnVpbGQgd2F0Y2hlciAodGhlIHNwaW5uaW5nIHRyaWFuZ2xlKVxuICAgIGZyb21OZXh0SnNMb2FkZXIpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBVZHBhdGUgdGhlIGhyZWYgaW4gdGhlIHBhcmVudCBjb250YWluZXJcbiAgICAgICAgaWYgKCgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKCdocmVmJykgIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTEFURVNUX0hSRUYsXG4gICAgICAgICAgICAgICAgaHJlZjogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKCdocmVmJywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCByZWZyZXNoIHRoZSBuYXYgdHJlZVxuICAgICAgICBsZXQgcmVmcmVzaE5hdlRyZWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZyb21OZXh0SnNMb2FkZXIpIHtcbiAgICAgICAgICAgIC8vIEZyb20gdGhlIG5leHRqcyBsb2FkZXIsIHJlZnJlc2ggd2hlbiB0aGUgbG9hZGVyIGdldHMgaGlkZGVuIChtZWFucyByZWZyZXNoIGlzIGRvbmUpXG4gICAgICAgICAgICBjb25zdCBtdXRhdGlvblRhcmdldCA9IChfYSA9IG11dGF0aW9ucyA9PT0gbnVsbCB8fCBtdXRhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11dGF0aW9uc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvblRhcmdldCAmJiBtdXRhdGlvblRhcmdldC5pZCA9PT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50bHlIb3RSZWxvYWRpbmcgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuSE9UX1JFTE9BRElORyk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5IT1RfUkVMT0FESU5HLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5IT1RfUkVMT0FESU5HLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hOYXZUcmVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjbGFzcyBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQgb24gYW4gZWxlbWVudCB3ZSBoYXZlIHRvIHJlcGFyc2UgdGhlIG5hdiB0cmVlIHRvIGFkZCB0aGUgZWxlbWVudCBrZXlcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnYXR0cmlidXRlcycgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5hdHRyaWJ1dGVOYW1lID09PSAnY2xhc3MnICYmXG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICEoMCwgb3V0bGluZVV0aWxzXzEuaXNOb2RlT3V0bGluZSkoZS50YXJnZXQpICYmXG4gICAgICAgICAgICAgICAgICAgICEoMCwgaWRlbnRpZmllclV0aWxzXzEuaXNNb3ZpbmdFbGVtZW50KShlLnRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIG5vdCBhIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAvLyBCdWcgZm91bmQgb24gT2N0IDgsIDIwMjQsIGZvciBzb21lIHJlYXNvbiB0aGUgc2NyaXB0IGtlcHQgdHJpZ2dlcmluZyBhIHJlbG9hZFxuICAgICAgICAgICAgICAgICAgICAhZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdzY3JpcHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50S2V5ID0gKDAsIGlkZW50aWZpZXJVdGlsc18xLmdldEVsZW1lbnRLZXlGcm9tTm9kZSkoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVMb29rdXAgPSAoMCwgaWRlbnRpZmllclV0aWxzXzEuZ2V0VW5pcXVlTG9va3VwRnJvbU5vZGUpKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gZWxlbWVudCB3aGljaCBkb2Vzbid0IGhhdmUgYW4gZWxlbWVudCBrZXkgaGFzIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50S2V5ICYmICF1bmlxdWVMb29rdXAgJiYgISgwLCBpZGVudGlmaWVyVXRpbHNfMS5pc0VsZW1lbnRJblN2ZykoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoTmF2VHJlZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBbZS5hZGRlZE5vZGVzLCBlLnJlbW92ZWROb2Rlc10uZm9yRWFjaCgobm9kZUxpc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGVMaXN0LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIG91dGxpbmVVdGlsc18xLmlzTm9kZU91dGxpbmUpKG5vZGUpICYmICEoMCwgaWRlbnRpZmllclV0aWxzXzEuaXNNb3ZpbmdFbGVtZW50KShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hOYXZUcmVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZnJlc2hOYXZUcmVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlc2UgY2FzZXMgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgbmF2IHRyZWUgcmVmcmVzaCByaWdodCBhd2F5XG4gICAgICAgIC8vIHNpbmNlIHRoZSBob3QgcmVsb2FkIG1heSBub3QgaGF2ZSBoYXBwZW5lZCB5ZXQuIFNvIHdlIHNldCBhIHRpbWVvdXQgYW5kIG9ubHlcbiAgICAgICAgLy8gdHJpZ2dlciBhIG5hdiB0cmVlIHJlZnJlc2ggaWYgYW5vdGhlciBvbmUgaGFzbid0IGhhcHBlbmVkIGluIGJldHdlZW5cbiAgICAgICAgaWYgKGZyb21OZXh0SnNMb2FkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSZWZyZXNoVGltZSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKExBU1RfTkFWX1RSRUVfUkVGUkVTSF9USU1FKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCByZS1jbGVhciBhbmQgc2VuZCBpZiBhbm90aGVyIHJlZnJlc2ggaGFzIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgIGlmICghbGFzdFJlZnJlc2hUaW1lIHx8IGxhc3RSZWZyZXNoVGltZSA8IHRyaWdnZXJUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW5zdGFudFVwZGF0ZXNBbmRTZW5kTmF2VHJlZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFySW5zdGFudFVwZGF0ZXNBbmRTZW5kTmF2VHJlZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH07XG4gICAgY29uc3Qgb25XaGVlbCA9IChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpID0+IHtcbiAgICAgICAgY29uc3QgcGFzc2VkVGhyb3VnaCA9IHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgY29uc3QgaXNTY3JvbGxTaG9ydGN1dCA9IGUuYWx0S2V5O1xuICAgICAgICBjb25zdCBpc1pvb21TaG9ydGN1dCA9IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHdhbnRzIHRvIHNjcm9sbCAoZWl0aGVyIGJ5IGJlaW5nIGluIGRyaXZlIG1vZGUsIG9yIGJ5IGhvbGRpbmcgYWx0KVxuICAgICAgICAvLyBhbmQgdGhleSBhcmVuJ3QgdHJ5aW5nIHRvIHpvb20sIGZhbGxiYWNrIHRvIGRlZmF1bHQgYmVoYXZpb3VyLlxuICAgICAgICBpZiAoIWlzWm9vbVNob3J0Y3V0ICYmIChwYXNzZWRUaHJvdWdoIHx8IGlzU2Nyb2xsU2hvcnRjdXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBpbXBvcnRhbnRGaWVsZHMgPSB7XG4gICAgICAgICAgICBkZWx0YVg6IGUuZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZOiBlLmRlbHRhWSxcbiAgICAgICAgICAgIHdoZWVsRGVsdGE6IGUud2hlZWxEZWx0YSxcbiAgICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICAgIHk6IGUueSxcbiAgICAgICAgICAgIGFsdEtleTogZS5hbHRLZXksXG4gICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAgICAgICAgfTtcbiAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuV0hFRUxfRVZFTlQsXG4gICAgICAgICAgICBldmVudDogaW1wb3J0YW50RmllbGRzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRNZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGxldCB0YWdOYW1lLCBpc0NvbnRlbnRFZGl0YWJsZSwgZWxlbWVudFR5cGU7XG4gICAgICAgIGlmIChhY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICB0YWdOYW1lID0gYWN0aXZlRWxlbWVudC50YWdOYW1lO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlzQ29udGVudEVkaXRhYmxlID0gYWN0aXZlRWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRUeXBlID0gYWN0aXZlRWxlbWVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgICAgaXNDb250ZW50RWRpdGFibGU6IGlzQ29udGVudEVkaXRhYmxlLFxuICAgICAgICAgICAgZWxlbWVudFR5cGU6IGVsZW1lbnRUeXBlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGUsIHBhcmVudFBvcnQpID0+IHtcbiAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuS0VZX0RPV05fRVZFTlQsXG4gICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIGtleTogZS5rZXksXG4gICAgICAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50OiBPYmplY3QuYXNzaWduKHt9LCBhY3RpdmVFbGVtZW50TWV0YWRhdGEoKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uS2V5VXAgPSAoZSwgcGFyZW50UG9ydCkgPT4ge1xuICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5LRVlfVVBfRVZFTlQsXG4gICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIGtleTogZS5rZXksXG4gICAgICAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50OiBPYmplY3QuYXNzaWduKHt9LCBhY3RpdmVFbGVtZW50TWV0YWRhdGEoKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRocm90dGxlZFVwZGF0ZU91dGxpbmVzID0gbG9kYXNoXzEuZGVmYXVsdC50aHJvdHRsZSgocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSA9PiAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCksIDE1KTtcbiAgICBjb25zdCBvblNjcm9sbCA9IChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkVXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9O1xuICAgIC8vIE5lZWQgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zIG9uIHRoZSB3aW5kb3cgZm9yIGNoYW5uZWwgbWVzc2FnaW5nIHRvIHVzZSB0aGVtXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5pbml0UHJvamVjdCA9IChwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQsIHRyZWVFbGVtZW50TG9va3VwLCBzY29wZUxvb2t1cCwgc3Rvcnlib2FyZENvbXBvbmVudEVsZW1lbnQsIG9wdGlvbnMgPSB7fSwgc3Rvcnlib2FyZFR5cGUsIHNhdmVkQ29tcG9uZW50RmlsZW5hbWUsIG9yaWdpbmFsU3Rvcnlib2FyZFVybCkgPT4ge1xuICAgICAgICBjb25zdCBwYXNzaXZlID0gbWFrZVBhc3NpdmVFdmVudE9wdGlvbigpO1xuICAgICAgICBwYXNzaXZlWydjYXB0dXJlJ10gPSB0cnVlO1xuICAgICAgICBjb25zdCBib2R5JCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KSgnYm9keScpO1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuVFJFRV9FTEVNRU5UX0xPT0tVUCwgdHJlZUVsZW1lbnRMb29rdXApO1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0NPUEVfTE9PS1VQLCBzY29wZUxvb2t1cCk7XG4gICAgICAgIGlmIChzdG9yeWJvYXJkQ29tcG9uZW50RWxlbWVudCkge1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNUT1JZQk9BUkRfQ09NUE9ORU5ULCBzdG9yeWJvYXJkQ29tcG9uZW50RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNUT1JZQk9BUkRfVFlQRSwgc3Rvcnlib2FyZFR5cGUpO1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0FWRURfU1RPUllCT0FSRF9DT01QT05FTlRfRklMRU5BTUUsIHNhdmVkQ29tcG9uZW50RmlsZW5hbWUpO1xuICAgICAgICAvLyBUaGUgVVJMIHRoYXQgd2FzIG9yaWdpbmFsbHkgbG9hZGVkIGZvciB0aGlzIHN0b3J5Ym9hcmQsIGl0IG1heSBiZSBkaWZmZXJlbnQgZnJvbSBocmVmXG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIG5hdmlnYXRlZCBhd2F5IHRvIGEgbmV3IHJvdXRlXG4gICAgICAgIGlmIChvcmlnaW5hbFN0b3J5Ym9hcmRVcmwpIHtcbiAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5PUklHSU5BTF9TVE9SWUJPQVJEX1VSTCwgb3JpZ2luYWxTdG9yeWJvYXJkVXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBpZnJhbWUgb3V0bGluZXNcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5yZW1vdmVNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5yZW1vdmVNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkhPVkVSRURfRUxFTUVOVF9LRVkpO1xuICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBjb25zdCBib2R5T2JqZWN0ID0gYm9keSQuZ2V0KDApO1xuICAgICAgICBib2R5T2JqZWN0ID09PSBudWxsIHx8IGJvZHlPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9LCBwYXNzaXZlKTtcbiAgICAgICAgYm9keU9iamVjdCA9PT0gbnVsbCB8fCBib2R5T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgKGUpID0+IHtcbiAgICAgICAgICAgIG9uUG9pbnRlck92ZXIoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgfSwgcGFzc2l2ZSk7XG4gICAgICAgIGJvZHlPYmplY3QgPT09IG51bGwgfHwgYm9keU9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm9keU9iamVjdC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICBvblBvaW50ZXJEb3duKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH0sIHBhc3NpdmUpO1xuICAgICAgICBib2R5T2JqZWN0ID09PSBudWxsIHx8IGJvZHlPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgKGUpID0+IHtcbiAgICAgICAgICAgIG9uUG9pbnRlclVwKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH0sIHBhc3NpdmUpO1xuICAgICAgICBib2R5T2JqZWN0ID09PSBudWxsIHx8IGJvZHlPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCAoZSkgPT4ge1xuICAgICAgICAgICAgb25Qb2ludGVyTW92ZShlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9LCBwYXNzaXZlKTtcbiAgICAgICAgYm9keU9iamVjdCA9PT0gbnVsbCB8fCBib2R5T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIChlKSA9PiB7XG4gICAgICAgICAgICBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH0sIHBhc3NpdmUpO1xuICAgICAgICBib2R5T2JqZWN0ID09PSBudWxsIHx8IGJvZHlPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCAoZSkgPT4ge1xuICAgICAgICAgICAgb25DbGlja0VsZW1lbnRDb250ZXh0TWVudShlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9LCBwYXNzaXZlKTtcbiAgICAgICAgYm9keU9iamVjdCA9PT0gbnVsbCB8fCBib2R5T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgfSwgcGFzc2l2ZSk7XG4gICAgICAgIGJvZHlPYmplY3QgPT09IG51bGwgfHwgYm9keU9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm9keU9iamVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZSkgPT4ge1xuICAgICAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9LCBwYXNzaXZlKTtcbiAgICAgICAgYm9keU9iamVjdCA9PT0gbnVsbCB8fCBib2R5T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgKGUpID0+IHtcbiAgICAgICAgICAgIHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgfSwgcGFzc2l2ZSk7XG4gICAgICAgIGJvZHlPYmplY3QgPT09IG51bGwgfHwgYm9keU9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm9keU9iamVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xuICAgICAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9LCBwYXNzaXZlKTtcbiAgICAgICAgYm9keU9iamVjdCA9PT0gbnVsbCB8fCBib2R5T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH0sIHBhc3NpdmUpO1xuICAgICAgICBib2R5T2JqZWN0ID09PSBudWxsIHx8IGJvZHlPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIChlKSA9PiB7XG4gICAgICAgICAgICBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH0sIHBhc3NpdmUpO1xuICAgICAgICBib2R5T2JqZWN0ID09PSBudWxsIHx8IGJvZHlPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZSkgPT4ge1xuICAgICAgICAgICAgb25XaGVlbChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9LCBwYXNzaXZlKTtcbiAgICAgICAgYm9keU9iamVjdCA9PT0gbnVsbCB8fCBib2R5T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgb25LZXlEb3duKGUsIHBhcmVudFBvcnQpO1xuICAgICAgICB9LCBwYXNzaXZlKTtcbiAgICAgICAgYm9keU9iamVjdCA9PT0gbnVsbCB8fCBib2R5T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgICAgICAgIG9uS2V5VXAoZSwgcGFyZW50UG9ydCk7XG4gICAgICAgIH0sIHBhc3NpdmUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKGUpID0+IHtcbiAgICAgICAgICAgIG9uU2Nyb2xsKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH0sIHBhc3NpdmUpO1xuICAgICAgICAvLyBIYWNrOiB0aGlzIGlzIHVzZWQgdG9cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxvY2tjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoSU1NRURJQVRFTFlfUkVNT1ZFX1BPSU5URVJfTE9DSykpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2soKTtcbiAgICAgICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShJTU1FRElBVEVMWV9SRU1PVkVfUE9JTlRFUl9MT0NLLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgb2JzZXJ2ZURPTShib2R5T2JqZWN0LCAoZSkgPT4ge1xuICAgICAgICAgICAgb25ET01DaGFuZ2VkKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIE5leHRKUywgYWxzbyBsaXN0ZW4gdG8gdGhlIHNoYWRvdyByb290IG9mIHRoZSBfX25leHQtYnVpbGQtd2F0Y2hlclxuICAgICAgICAvLyBUaGlzIHRyaWdnZXJlcyB0aGUgb25ET01DaGFuZ2VkIHdoZW4gdGhlIGhvdCByZWxvYWQgc3ltYm9sIHNob3dzIHVwXG4gICAgICAgIGNvbnN0IG5leHRCdWlsZFdhdGNoZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0LWJ1aWxkLXdhdGNoZXInKTtcbiAgICAgICAgaWYgKG5leHRCdWlsZFdhdGNoZXIgJiYgbmV4dEJ1aWxkV2F0Y2hlci5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKG5leHRCdWlsZFdhdGNoZXIuc2hhZG93Um9vdC5jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlRE9NKGNoaWxkLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkRPTUNoYW5nZWQoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRyaXZlTW9kZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGVuYWJsZURyaXZlTW9kZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGlzYWJsZURyaXZlTW9kZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFpQ29udGV4dFNlbGVjdGlvbikge1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ2FpQ29udGV4dCcsIHRydWUpO1xuICAgICAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ2FpQ29udGV4dCcsIGZhbHNlKTtcbiAgICAgICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgTmF2IFRyZWUgYW5kIHNlbmQgaXQgYmFja1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnVpbGRBbmRTZW5kTmF2VHJlZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQsIHRyZWVFbGVtZW50TG9va3VwLCBzY29wZUxvb2t1cCwgc3Rvcnlib2FyZENvbXBvbmVudEVsZW1lbnQgfHwgJ0VYUExJQ0lUX05PTkUnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBidWlsZGluZyBuYXYgdHJlZTogJyArIGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlbmFibGVEcml2ZU1vZGUgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCEoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldFNlc3Npb25TdG9yYWdlSXRlbSkoJ2RyaXZlTW9kZUVuYWJsZWQnLCBzdG9yeWJvYXJkSWQpKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldFNlc3Npb25TdG9yYWdlSXRlbSkoJ2RyaXZlTW9kZUVuYWJsZWQnLCAnZW5hYmxlZCcsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgICAgICBjbGVhckhvdmVyZWRFbGVtZW50cyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLmNsZWFyQWxsT3V0bGluZXMpKCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKCdib2R5JykuY3NzKCdjdXJzb3InLCAnJyk7XG4gICAgfTtcbiAgICBjb25zdCBkaXNhYmxlRHJpdmVNb2RlID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICgoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldFNlc3Npb25TdG9yYWdlSXRlbSkoJ2RyaXZlTW9kZUVuYWJsZWQnLCBzdG9yeWJvYXJkSWQpKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnJlbW92ZVNlc3Npb25TdG9yYWdlSXRlbSkoJ2RyaXZlTW9kZUVuYWJsZWQnLCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgY2xlYXJIb3ZlcmVkRWxlbWVudHMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoJ2JvZHknKS5hdHRyKCdzdHlsZScsIGZ1bmN0aW9uIChpLCBzKSB7XG4gICAgICAgICAgICByZXR1cm4gKHMgfHwgJycpICsgJ2N1cnNvcjogZGVmYXVsdCAhaW1wb3J0YW50Oyc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5lbmFibGVEcml2ZU1vZGUgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSA9PiB7XG4gICAgICAgIGVuYWJsZURyaXZlTW9kZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5kaXNhYmxlRHJpdmVNb2RlID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICBkaXNhYmxlRHJpdmVNb2RlKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LnNldE5ld0xvb2t1cHMgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCB0cmVlRWxlbWVudExvb2t1cCwgc2NvcGVMb29rdXApID0+IHtcbiAgICAgICAgY29uc3QgcHJldlRyZWVFbGVtbnRMb29rdXAgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuVFJFRV9FTEVNRU5UX0xPT0tVUCkgfHwge307XG4gICAgICAgIGNvbnN0IHByZXZTY29wZUxvb2t1cCA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5TQ09QRV9MT09LVVApIHx8IHt9O1xuICAgICAgICBjb25zdCBuZXdUcmVlRWxlbWVudHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcmV2VHJlZUVsZW1udExvb2t1cCk7XG4gICAgICAgIC8vIERlbGV0ZSBhbnkgdHJlZSBlbGVtZW50cyB0aGF0IHdlcmUgc2V0IHRvIG51bFxuICAgICAgICBPYmplY3Qua2V5cyh0cmVlRWxlbWVudExvb2t1cCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHJlZUVsZW1lbnRMb29rdXBba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1RyZWVFbGVtZW50c1trZXldID0gdHJlZUVsZW1lbnRMb29rdXBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1RyZWVFbGVtZW50c1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld1RyZWVFbGVtZW50c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3U2NvcGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJldlNjb3BlTG9va3VwKTtcbiAgICAgICAgLy8gRGVsZXRlIGFueSBzY29wZXMgdGhhdCB3ZXJlIHNldCB0byBudWxcbiAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVMb29rdXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjb3BlTG9va3VwW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTY29wZXNba2V5XSA9IHNjb3BlTG9va3VwW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdTY29wZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdTY29wZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5UUkVFX0VMRU1FTlRfTE9PS1VQLCBuZXdUcmVlRWxlbWVudHMpO1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0NPUEVfTE9PS1VQLCBuZXdTY29wZXMpO1xuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5zZXRIb3ZlcmVkRWxlbWVudCA9IChwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQsIGVsZW1lbnRLZXkpID0+IHtcbiAgICAgICAgY29uc3QgZHJpdmVNb2RlRW5hYmxlZCA9ICEhKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRTZXNzaW9uU3RvcmFnZUl0ZW0pKCdkcml2ZU1vZGVFbmFibGVkJywgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgaWYgKGRyaXZlTW9kZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2SG92ZXJlZEVsZW1lbnRLZXkgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuSE9WRVJFRF9FTEVNRU5UX0tFWSk7XG4gICAgICAgIGlmIChwcmV2SG92ZXJlZEVsZW1lbnRLZXkgPT09IGVsZW1lbnRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudEtleSkge1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkhPVkVSRURfRUxFTUVOVF9LRVksIGVsZW1lbnRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5yZW1vdmVNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkhPVkVSRURfRUxFTUVOVF9LRVkpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cuc2V0U2VsZWN0ZWRFbGVtZW50ID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgZWxlbWVudEtleSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0ZWRFbGVtZW50S2V5ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICAgICAgaWYgKHByZXZTZWxlY3RlZEVsZW1lbnRLZXkgPT09IGVsZW1lbnRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudEtleSkge1xuICAgICAgICAgICAgY29uc3QgdGVtcG9FbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkoZWxlbWVudEtleSk7XG4gICAgICAgICAgICBsZXQgZWxlbWVudEtleVRvRXh0cmFjdCA9IGVsZW1lbnRLZXk7XG4gICAgICAgICAgICBpZiAodGVtcG9FbGVtZW50LmlzU3Rvcnlib2FyZChzdG9yeWJvYXJkSWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBiYWNrIHRoZSBvdXRlckhUTUwgb2YgdGhlIHRvcCBsZXZlbCBub2RlXG4gICAgICAgICAgICAgICAgY29uc3QgdG9wTGV2ZWxOb2RlID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkNVUlJFTlRfTkFWX1RSRUUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvcExldmVsRWxlbWVudEtleSA9IChfYSA9IHRvcExldmVsTm9kZSA9PT0gbnVsbCB8fCB0b3BMZXZlbE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvcExldmVsTm9kZS50ZW1wb0VsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRLZXkoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9wTGV2ZWxFbGVtZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRLZXlUb0V4dHJhY3QgPSB0b3BMZXZlbEVsZW1lbnRLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VuZCBiYWNrIHRoZSBtZXNzYWdlIGp1c3QgdG8gc2V0IHRoZSBvdXRlckhUTUwgb25seVxuICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLlNFTEVDVEVEX0VMRU1FTlRfS0VZLFxuICAgICAgICAgICAgICAgIGRvTm90U2V0RWxlbWVudEtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvdXRlckhUTUw6IChfYiA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7ZWxlbWVudEtleVRvRXh0cmFjdH1gKS5nZXQoMCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vdXRlckhUTUwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5TRUxFQ1RFRF9FTEVNRU5UX0tFWSwgZWxlbWVudEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgICAgICAgZG9Ob3RTZXRFbGVtZW50S2V5OiB0cnVlLFxuICAgICAgICAgICAgICAgIG91dGVySFRNTDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5yZW1vdmVNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LnNldE11bHRpc2VsZWN0ZWRFbGVtZW50S2V5cyA9IChwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQsIGVsZW1lbnRLZXlzKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZNdWx0aVNlbGVjdGVkRWxlbWVudEtleXMgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTKTtcbiAgICAgICAgY29uc3QgcHJldlNldCA9IG5ldyBTZXQocHJldk11bHRpU2VsZWN0ZWRFbGVtZW50S2V5cyB8fCBbXSk7XG4gICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBTZXQoZWxlbWVudEtleXMgfHwgW10pO1xuICAgICAgICBjb25zdCBzZXRzRXF1YWwgPSBwcmV2U2V0LnNpemUgPT09IG5ld1NldC5zaXplICYmXG4gICAgICAgICAgICBbLi4ucHJldlNldF0uZXZlcnkoKHZhbHVlKSA9PiBuZXdTZXQuaGFzKHZhbHVlKSk7XG4gICAgICAgIGlmIChzZXRzRXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudEtleXMpIHtcbiAgICAgICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMsIGVsZW1lbnRLZXlzKTtcbiAgICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMsXG4gICAgICAgICAgICAgICAgZG9Ob3RTZXRFbGVtZW50S2V5czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvdXRlckhUTUxzOiBlbGVtZW50S2V5cyA9PT0gbnVsbCB8fCBlbGVtZW50S2V5cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudEtleXMubWFwKChlbGVtZW50S2V5KSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7ZWxlbWVudEtleX1gKS5nZXQoMCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vdXRlckhUTUw7IH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnJlbW92ZU1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTKTtcbiAgICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMsXG4gICAgICAgICAgICAgICAgZG9Ob3RTZXRFbGVtZW50S2V5czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvdXRlckhUTUxzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cucHJvY2Vzc1J1bGVzRm9yU2VsZWN0ZWRFbGVtZW50ID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgY3NzRWxlbWVudExvb2t1cCwgc2VsZWN0ZWRFbGVtZW50S2V5KSA9PiB7XG4gICAgICAgICgwLCBjc3NGdW5jdGlvbnNfMS5wcm9jZXNzUnVsZXNGb3JTZWxlY3RlZEVsZW1lbnQpKHBhcmVudFBvcnQsIGNzc0VsZW1lbnRMb29rdXAsIHNlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LnNldE1vZGlmaWVyc0ZvclNlbGVjdGVkRWxlbWVudCA9IChwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQsIG1vZGlmaWVycywgc2VsZWN0ZWRFbGVtZW50S2V5KSA9PiB7XG4gICAgICAgICgwLCBjc3NGdW5jdGlvbnNfMS5zZXRNb2RpZmllcnNGb3JTZWxlY3RlZEVsZW1lbnQpKHBhcmVudFBvcnQsIG1vZGlmaWVycywgc2VsZWN0ZWRFbGVtZW50S2V5KTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cuZ2V0Q3NzRXZhbHMgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBzZWxlY3RlZEVsZW1lbnRLZXkpID0+IHtcbiAgICAgICAgKDAsIGNzc0Z1bmN0aW9uc18xLmdldENzc0V2YWxzKShwYXJlbnRQb3J0LCBzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5ydWxlTWF0Y2hlc0VsZW1lbnQgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBtZXNzYWdlSWQsIHJ1bGUsIHNlbGVjdGVkRWxlbWVudEtleSkgPT4ge1xuICAgICAgICAoMCwgY3NzRnVuY3Rpb25zXzEucnVsZU1hdGNoZXNFbGVtZW50KShwYXJlbnRQb3J0LCBtZXNzYWdlSWQsIHJ1bGUsIHNlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LmdldEVsZW1lbnRDbGFzc0xpc3QgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBzZWxlY3RlZEVsZW1lbnRLZXkpID0+IHtcbiAgICAgICAgKDAsIGNzc0Z1bmN0aW9uc18xLmdldEVsZW1lbnRDbGFzc0xpc3QpKHBhcmVudFBvcnQsIHNlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LmFwcGx5Q2hhbmdlSXRlbVRvRG9jdW1lbnQgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBjaGFuZ2VJdGVtKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyBzZW5kTmV3TmF2VHJlZSB9ID0gKDAsIGNoYW5nZUl0ZW1GdW5jdGlvbnNfMS5hcHBseUNoYW5nZUl0ZW1Ub0RvY3VtZW50KShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQsIGNoYW5nZUl0ZW0pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIG5hdiB0cmVlICYgb3V0bGluZXNcbiAgICAgICAgaWYgKHNlbmROZXdOYXZUcmVlKSB7XG4gICAgICAgICAgICBidWlsZEFuZFNlbmROYXZUcmVlKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH0pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cudXBkYXRlQ29kZWJhc2VJZHMgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBwcmV2SWRUb05ld0lkTWFwLCBuZXdUcmVlRWxlbWVudExvb2t1cCwgbmV3U2NvcGVMb29rdXApID0+IHtcbiAgICAgICAgY29uc3Qgc2VuZE5ld05hdlRyZWUgPSAoMCwgY2hhbmdlSXRlbUZ1bmN0aW9uc18xLnVwZGF0ZUNvZGViYXNlSWRzKShwYXJlbnRQb3J0LCBwcmV2SWRUb05ld0lkTWFwLCB0cnVlKTtcbiAgICAgICAgaWYgKHNlbmROZXdOYXZUcmVlKSB7XG4gICAgICAgICAgICBidWlsZEFuZFNlbmROYXZUcmVlKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgbmV3VHJlZUVsZW1lbnRMb29rdXAsIG5ld1Njb3BlTG9va3VwKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBldmVudE5hbWUsIGV2ZW50RGV0YWlscykgPT4ge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGV0YWlscykpO1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cudXBkYXRlT3V0bGluZXMgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSA9PiB7XG4gICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cuZ29CYWNrID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVmZXJyZXIgIT09ICcnKSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cuZ29Gb3J3YXJkID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LnJlZnJlc2ggPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cuc3ludGhldGljTW91c2VPdmVyID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgY29vcmRzLCBkb250SG92ZXJJbnNpZGVTZWxlY3RlZCwgc2VsZWN0Qm90dG9tTW9zdEVsZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjb29yZHMueCwgY29vcmRzLnkpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRydWUgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgaG92ZXIgZXZlbnQgaW5zaWRlIGEgc2VsZWN0ZWQgZWxlbWVudCwgaW5zdGVhZCBqdXN0IHNldCBob3ZlcmluZyBvbiB0aGUgc2VsZWN0ZWQgZWxlbWVudFxuICAgICAgICBpZiAoZG9udEhvdmVySW5zaWRlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudEtleSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5TRUxFQ1RFRF9FTEVNRU5UX0tFWSk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQuZnJvbUtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEVsZW1lbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWREb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7c2VsZWN0ZWRFbGVtZW50S2V5fWApO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZERvbUVsZW1lbnQgPT09IG51bGwgfHwgc2VsZWN0ZWREb21FbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERvbUVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBvblBvaW50ZXJPdmVyKHsgdGFyZ2V0OiBzZWxlY3RlZERvbUVsZW1lbnQgfSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvblBvaW50ZXJPdmVyKHsgdGFyZ2V0IH0sIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgc2VsZWN0Qm90dG9tTW9zdEVsZW1lbnQpO1xuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5zeW50aGV0aWNNb3VzZU1vdmUgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBzeW50aGV0aWNFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudFdpdGhDbGllbnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN5bnRoZXRpY0V2ZW50KSwgeyBwYWdlWDogc3ludGhldGljRXZlbnQuY2xpZW50WCArXG4gICAgICAgICAgICAgICAgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCksIHBhZ2VZOiBzeW50aGV0aWNFdmVudC5jbGllbnRZICtcbiAgICAgICAgICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgfSk7XG4gICAgICAgIG9uUG9pbnRlck1vdmUoZXZlbnRXaXRoQ2xpZW50LCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5zeW50aGV0aWNNb3VzZVVwID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgc3ludGhldGljRXZlbnQpID0+IHtcbiAgICAgICAgb25Qb2ludGVyVXAoc3ludGhldGljRXZlbnQsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LmNsZWFySG92ZXJlZE91dGxpbmVzID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICBpZiAoKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkhPVkVSRURfRUxFTUVOVF9LRVkpKSB7XG4gICAgICAgICAgICBjbGVhckhvdmVyZWRFbGVtZW50cyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LnNldFpvb21QZXJjID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgem9vbVBlcmMpID0+IHtcbiAgICAgICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ3pvb21QZXJjJywgem9vbVBlcmMudG9TdHJpbmcoKSk7XG4gICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cuc2V0QWlDb250ZXh0ID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgYWlDb250ZXh0KSA9PiB7XG4gICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKCdhaUNvbnRleHQnLCAhIWFpQ29udGV4dCk7XG4gICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cudGVtcE1vdmVFbGVtZW50ID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgbm9kZVRvTW92ZUVsZW1lbnRLZXksIG5ld0luZGV4KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuRUxFTUVOVF9LRVlfVE9fTkFWX05PREUpIHx8IHt9O1xuICAgICAgICBjb25zdCBuYXZOb2RlVG9Nb3ZlID0gZWxlbWVudEtleVRvTmF2Tm9kZVtub2RlVG9Nb3ZlRWxlbWVudEtleV07XG4gICAgICAgIGlmICghbmF2Tm9kZVRvTW92ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVUb01vdmVFbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkobm9kZVRvTW92ZUVsZW1lbnRLZXkpO1xuICAgICAgICBjb25zdCBkb21FbGVtZW50c1RvTW92ZSA9IFtdO1xuICAgICAgICAvLyBJbiBjb21wb25lbnRzLCB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGJlIG1vdmVkLCB0aGUgZWxlZW1udEtleVRvTG9va3VwTGlzdFxuICAgICAgICAvLyBhcmUgYWxsIHRoZSByZWFsIERPTSBlbGVtZW50cyBpbiBhIGNvbXBvbmVudFxuICAgICAgICAvLyBGb3Igbm9uLWNvbXBvbmVudHMsIHRoZSBlbGVlbW50S2V5VG9Mb29rdXBMaXN0IHBvaW50cyB0byBhIGxpc3Qgb2YgaXRzZWxmXG4gICAgICAgIGNvbnN0IGVsZW1lbnRLZXlUb0xvb2t1cExpc3QgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuRUxFTUVOVF9LRVlfVE9fTE9PS1VQX0xJU1QpIHx8IHt9O1xuICAgICAgICBjb25zdCBsb29rdXBMaXN0ID0gZWxlbWVudEtleVRvTG9va3VwTGlzdFtuYXZOb2RlVG9Nb3ZlLnRlbXBvRWxlbWVudC5nZXRLZXkoKV0gfHwgW107XG4gICAgICAgIGxvb2t1cExpc3QuZm9yRWFjaCgobG9va3VwRWxlbWVudEtleSkgPT4ge1xuICAgICAgICAgICAgZG9tRWxlbWVudHNUb01vdmUucHVzaCgoMCwganF1ZXJ5XzEuZGVmYXVsdCkoJ2JvZHknKS5maW5kKGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtsb29rdXBFbGVtZW50S2V5fWApLmdldCgwKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJlbnREb21FbGVtZW50ID0gKF9hID0gZG9tRWxlbWVudHNUb01vdmVbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBwYXJlbnROYXZOb2RlID0gbmF2Tm9kZVRvTW92ZS5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnREb21FbGVtZW50ICYmIHBhcmVudE5hdk5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IChfYiA9IHBhcmVudE5hdk5vZGUgPT09IG51bGwgfHwgcGFyZW50TmF2Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50TmF2Tm9kZS5jaGlsZHJlbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluZGV4T2YobmF2Tm9kZVRvTW92ZSk7XG4gICAgICAgICAgICBjb25zdCBudW1DaGlsZHJlbiA9IChfYyA9IHBhcmVudE5hdk5vZGUgPT09IG51bGwgfHwgcGFyZW50TmF2Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50TmF2Tm9kZS5jaGlsZHJlbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IG5ld0luZGV4KSB7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShwYXJlbnREb21FbGVtZW50LmNoaWxkcmVuKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoY2hpbGQpLmF0dHIoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKHBhcmVudERvbUVsZW1lbnQpLmF0dHIoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09PSBudW1DaGlsZHJlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudHNUb01vdmUuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGluZGV4IGlzIGJlZm9yZSB0aGUgbmV3IGluZGV4IHRoZW4gd2UgbmVlZCB0byBhZGp1c3QgYnkgMSB0byBhY2NvdW50IGZvciB0aGUgc2hpZnQgaW4gaW5kaWNlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVOb2RlID0gY3VycmVudEluZGV4ID4gbmV3SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyZW50TmF2Tm9kZSA9PT0gbnVsbCB8fCBwYXJlbnROYXZOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnROYXZOb2RlLmNoaWxkcmVuW25ld0luZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnROYXZOb2RlID09PSBudWxsIHx8IHBhcmVudE5hdk5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudE5hdk5vZGUuY2hpbGRyZW5bbmV3SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9va3VwTGlzdEZvckJlZm9yZSA9IGVsZW1lbnRLZXlUb0xvb2t1cExpc3RbKF9kID0gYmVmb3JlTm9kZSA9PT0gbnVsbCB8fCBiZWZvcmVOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiZWZvcmVOb2RlLnRlbXBvRWxlbWVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdldEtleSgpXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rdXBMaXN0Rm9yQmVmb3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nhbm5vdCBmaW5kIGVsZW1lbnQgdG8gaW5zZXJ0IGJlZm9yZSBpbiBsb29rdXAgbGlzdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZURvbUVsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoJ2JvZHknKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke2xvb2t1cExpc3RGb3JCZWZvcmVbMF19YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVmb3JlRG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nhbm5vdCBmaW5kIGVsZW1lbnQgdG8gaW5zZXJ0IGJlZm9yZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnRzVG9Nb3ZlLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYmVmb3JlRG9tRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGVkIGVsZW1lbnQga2V5IHRvIHRoZSBuZXcgZXhwZWN0ZWQgb25lIChub3RlIGlmIG1vdmluZyB0aGVyZSBpcyBubyBob3ZlcmVkIGVsZW1lbnQga2V5KVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBhc3N1bWVzIHRoZSBub2RlVG9Nb3ZlRWxlbWVudEtleSBpcyB0aGUgc2VsZWN0ZWQgZWxlbWVudCBrZXlcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50VG9Nb3ZlU2VnbWVudHMgPSBub2RlVG9Nb3ZlRWxlbWVudC51bmlxdWVQYXRoLnNwbGl0KCctJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0ZWRVbmlxdWVQYXRoID0gZWxlbWVudFRvTW92ZVNlZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBlbGVtZW50VG9Nb3ZlU2VnbWVudHMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJy0nKSArIGAtJHtuZXdJbmRleH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGVkRWxlbWVudEtleSA9IG5ldyB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQobm9kZVRvTW92ZUVsZW1lbnQuY29kZWJhc2VJZCwgbm9kZVRvTW92ZUVsZW1lbnQuc3Rvcnlib2FyZElkLCBuZXdTZWxlY3RlZFVuaXF1ZVBhdGgpLmdldEtleSgpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbmF2IHRyZWUgd2hpY2ggYWxzbyBzZXRzIHRoZSBlbGVtZW50IGtleSBvbiBhbGwgdGhlIGVsZW1lbnRzLCBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRpbmcgdGhlIHNlbGVjdGVkIGVsZW1lbnQga2V5XG4gICAgICAgICAgICAgICAgYnVpbGRBbmRTZW5kTmF2VHJlZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgICAgIC8vIENvZGViYXNlIElEIGRvZXNuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEtleTogbmV3U2VsZWN0ZWRFbGVtZW50S2V5LFxuICAgICAgICAgICAgICAgICAgICBvdXRlckhUTUw6IChfZSA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7bmV3U2VsZWN0ZWRFbGVtZW50S2V5fWApLmdldCgwKSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0VMRUNURURfRUxFTUVOVF9LRVksIG5ld1NlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgICAgICAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LnRlbXBBZGREaXYgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBwYXJlbnRDb2RlYmFzZUlkLCBpbmRleEluUGFyZW50LCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLlRFTVBPX0lOU1RBTlRfRElWX0RSQVdfQ0xBU1N9YCk7XG4gICAgICAgIGlmIChlbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudC5jc3MoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICAgICAgZWxlbWVudC5jc3MoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtwYXJlbnRDb2RlYmFzZUlkfWApO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKCdib2R5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuZWFjaCgoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGA8ZGl2IGNsYXNzPVwiJHtpZGVudGlmaWVyVXRpbHNfMS5URU1QT19JTlNUQU5UX0RJVl9EUkFXX0NMQVNTfVwiICR7aWRlbnRpZmllclV0aWxzXzEuVEVNUE9fREVMRVRFX0FGVEVSX0lOU1RBTlRfVVBEQVRFfT1cInRydWVcIiAke2lkZW50aWZpZXJVdGlsc18xLlRFTVBPX0RFTEVURV9BRlRFUl9SRUZSRVNIfT1cInRydWVcIiAke2lkZW50aWZpZXJVdGlsc18xLlRFTVBPX0lOU1RBTlRfVVBEQVRFfT1cInRydWVcIj48L2Rpdj5gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEF0SW5kZXggPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoaXRlbSkuY2hpbGRyZW4oKS5lcShpbmRleEluUGFyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRBdEluZGV4ID09PSBudWxsIHx8IGNoaWxkQXRJbmRleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGRBdEluZGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEF0SW5kZXguYmVmb3JlKG5ld0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGl0ZW0pLmFwcGVuZChuZXdFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbmF2IHRyZWVcbiAgICAgICAgICAgIGJ1aWxkQW5kU2VuZE5hdlRyZWUocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgb3V0bGluZVV0aWxzXzEudXBkYXRlT3V0bGluZXMpKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LnRlbXBNb3ZlVG9OZXdQYXJlbnQgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkLCBpbmRpY2F0b3JXaWR0aCwgaW5kaWNhdG9ySGVpZ2h0LCBuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSwgcGFyZW50RWxlbWVudEtleSwgY2xlYXIpID0+IHtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtpZGVudGlmaWVyVXRpbHNfMS5URU1QT19NT1ZFX0JFVFdFRU5fUEFSRU5UU19PVVRMSU5FfWApLnJlbW92ZSgpO1xuICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChpZGVudGlmaWVyVXRpbHNfMS5URU1QT19NT1ZFX0JFVFdFRU5fUEFSRU5UU19PVVRMSU5FKTtcbiAgICAgICAgbmV3RWxlbWVudC5zZXRBdHRyaWJ1dGUoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7IC8vIEFkZCBzbyBpdCBkb2Vzbid0IHRyaWdnZXIgbmV3IG5hdiB0cmVlIGJ1aWxkaW5nXG4gICAgICAgIG5ld0VsZW1lbnQuc3R5bGUud2lkdGggPSBpbmRpY2F0b3JXaWR0aCArICdweCc7XG4gICAgICAgIG5ld0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaW5kaWNhdG9ySGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgbmV3RWxlbWVudC5zdHlsZS5sZWZ0ID0gbmV3UG9zaXRpb25YICsgJ3B4JztcbiAgICAgICAgbmV3RWxlbWVudC5zdHlsZS50b3AgPSBuZXdQb3NpdGlvblkgKyAncHgnO1xuICAgICAgICBuZXdFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgbmV3RWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICBuZXdFbGVtZW50LnN0eWxlLnpJbmRleCA9ICcyMDAwMDAwMDA0JztcbiAgICAgICAgbmV3RWxlbWVudC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgICAgIG5ld0VsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQgIWltcG9ydGFudCc7XG4gICAgICAgIG5ld0VsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3V0bGluZVV0aWxzXzEuUFJJTUFSWV9PVVRMSU5FX0NPTE9VUjtcbiAgICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQobmV3RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHBhcmVudERvbUVsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke3BhcmVudEVsZW1lbnRLZXl9YCkuZ2V0KDApO1xuICAgICAgICBpZiAocGFyZW50RG9tRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgYm91bmRpbmdSZWN0ID0gcGFyZW50RG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE91dGxpbmUgPSAoMCwgb3V0bGluZVV0aWxzXzEuZ2V0T3V0bGluZUVsZW1lbnQpKHBhcmVudFBvcnQsIG91dGxpbmVVdGlsc18xLk91dGxpbmVUeXBlLlBSSU1BUlksIGJvdW5kaW5nUmVjdC5sZWZ0LCBib3VuZGluZ1JlY3QudG9wLCBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgcGFyZW50T3V0bGluZS5jbGFzc0xpc3QucmVtb3ZlKGlkZW50aWZpZXJVdGlsc18xLk9VVExJTkVfQ0xBU1MpO1xuICAgICAgICAgICAgcGFyZW50T3V0bGluZS5jbGFzc0xpc3QuYWRkKGlkZW50aWZpZXJVdGlsc18xLlRFTVBPX01PVkVfQkVUV0VFTl9QQVJFTlRTX09VVExJTkUpO1xuICAgICAgICAgICAgcGFyZW50T3V0bGluZS5zZXRBdHRyaWJ1dGUoaWRlbnRpZmllclV0aWxzXzEuVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7IC8vIEFkZCBzbyBpdCBkb2Vzbid0IHRyaWdnZXIgbmV3IG5hdiB0cmVlIGJ1aWxkaW5nXG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKHBhcmVudE91dGxpbmUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd2luZG93LmNoZWNrSWZIeWRyYXRpb25FcnJvciA9IChwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3E7XG4gICAgICAgIGxldCBlcnJvckRlc2NyLCBlcnJvckxhYmVsLCBlcnJvckJvZHksIGhhc0Vycm9yO1xuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYuaW5jbHVkZXMoJ2ZyYW1ld29yaz1WSVRFJykpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUG9ydGFsID0gKF9hID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpdGUtZXJyb3Itb3ZlcmxheScpWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hhZG93Um9vdDtcbiAgICAgICAgICAgIGVycm9yRGVzY3IgPSAnQSBWaXRlIEVycm9yIE9jY3VycmVkJztcbiAgICAgICAgICAgIGVycm9yTGFiZWwgPVxuICAgICAgICAgICAgICAgIChfZCA9IChfYyA9IChfYiA9IGVycm9yUG9ydGFsID09PSBudWxsIHx8IGVycm9yUG9ydGFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvclBvcnRhbC5xdWVyeVNlbGVjdG9yQWxsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChlcnJvclBvcnRhbCwgJy5maWxlLWxpbmsnKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jWzBdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaW5uZXJIVE1MO1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gKF9nID0gKF9mID0gKF9lID0gZXJyb3JQb3J0YWwgPT09IG51bGwgfHwgZXJyb3JQb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yUG9ydGFsLnF1ZXJ5U2VsZWN0b3JBbGwpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKGVycm9yUG9ydGFsLCAnLm1lc3NhZ2UnKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mWzBdKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuaW5uZXJIVE1MO1xuICAgICAgICAgICAgaGFzRXJyb3IgPSBCb29sZWFuKGVycm9yTGFiZWwgfHwgZXJyb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUG9ydGFsID0gKF9oID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25leHRqcy1wb3J0YWwnKVswXSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnNoYWRvd1Jvb3Q7XG4gICAgICAgICAgICBlcnJvckRlc2NyID0gKF9rID0gKF9qID0gZXJyb3JQb3J0YWwgPT09IG51bGwgfHwgZXJyb3JQb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yUG9ydGFsLmdldEVsZW1lbnRCeUlkKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouY2FsbChlcnJvclBvcnRhbCwgJ25leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjJykpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5pbm5lckhUTUw7XG4gICAgICAgICAgICBlcnJvckxhYmVsID0gKF9tID0gKF9sID0gZXJyb3JQb3J0YWwgPT09IG51bGwgfHwgZXJyb3JQb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yUG9ydGFsLmdldEVsZW1lbnRCeUlkKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuY2FsbChlcnJvclBvcnRhbCwgJ25leHRqc19fY29udGFpbmVyX2Vycm9yc19sYWJlbCcpKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20uaW5uZXJIVE1MO1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gKF9xID0gKF9wID0gKF9vID0gZXJyb3JQb3J0YWwgPT09IG51bGwgfHwgZXJyb3JQb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yUG9ydGFsLnF1ZXJ5U2VsZWN0b3JBbGwpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5jYWxsKGVycm9yUG9ydGFsLCAnLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHknKSkgPT09IG51bGwgfHwgX3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wWzBdKSA9PT0gbnVsbCB8fCBfcSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3EuaW5uZXJIVE1MO1xuICAgICAgICAgICAgaGFzRXJyb3IgPSBCb29sZWFuKGVycm9yRGVzY3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50cyBvZiB0aGUgaHlkcmF0aW9uIGNvbnRhaW5lciBjb250YWluIHRoZSB0ZXh0IFwiSHlkcmF0aW9uIGZhaWxlZFwiXG4gICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yRGVzY3IgPT09IG51bGwgfHwgZXJyb3JEZXNjciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3JEZXNjci5pbmNsdWRlcygnSHlkcmF0aW9uIGZhaWxlZCcpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5MQVRFU1RfSFlEUkFUSU9OX0VSUk9SX1NUQVRVUyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNBbmRUeXBlc18xLlNUT1JZQk9BUkRfSFlEUkFUSU9OX1NUQVRVUy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEZXNjcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JCb2R5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5MQVRFU1RfSFlEUkFUSU9OX0VSUk9SX1NUQVRVUyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNBbmRUeXBlc18xLlNUT1JZQk9BUkRfSFlEUkFUSU9OX1NUQVRVUy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEZXNjcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JCb2R5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkxBVEVTVF9IWURSQVRJT05fRVJST1JfU1RBVFVTLFxuICAgICAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzQW5kVHlwZXNfMS5TVE9SWUJPQVJEX0hZRFJBVElPTl9TVEFUVVMuTk9fRVJST1IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy50cmlnZ2VyRHJhZ1N0YXJ0ID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnRLZXkgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuU0VMRUNURURfRUxFTUVOVF9LRVkpO1xuICAgICAgICBjb25zdCBlbGVtZW50S2V5VG9OYXZOb2RlID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkVMRU1FTlRfS0VZX1RPX05BVl9OT0RFKSB8fCB7fTtcbiAgICAgICAgLy8gU29tZXRoaW5nIGhhcyB0byBiZSBzZWxlY3RlZCB0byB0cmlnZ2VyIGEgZHJhZyBzdGFydFxuICAgICAgICBpZiAoIXNlbGVjdGVkRWxlbWVudEtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyYWdnZWROYXZOb2RlID0gZWxlbWVudEtleVRvTmF2Tm9kZVtzZWxlY3RlZEVsZW1lbnRLZXldO1xuICAgICAgICBjb25zdCBwYXJlbnREb21FbGVtZW50ID0gZ2V0UGFyZW50RG9tRWxlbWVudEZvck5hdk5vZGUoZHJhZ2dlZE5hdk5vZGUpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke3NlbGVjdGVkRWxlbWVudEtleX1gKS5nZXQoMCk7XG4gICAgICAgIGNvbnN0IG1vdXNlRHJhZ0NvbnRleHQgPSB7XG4gICAgICAgICAgICAvLyBTdGFydCBvZmYgc2NyZWVuLCB0aGlzIHdpbGwgZ2V0IHVwZGF0ZWQgYnkgb25Nb3VzZU1vdmVcbiAgICAgICAgICAgIHBhZ2VYOiAtMTAwMDAsXG4gICAgICAgICAgICBwYWdlWTogLTEwMDAwLFxuICAgICAgICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB3aGVyZSB0aGUgdXNlciBjbGlja2VkIGFuZCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0ZWRQYXJlbnREaXNwbGF5OiAoMCwgY3NzRnVuY3Rpb25zXzEuY3NzRXZhbCkocGFyZW50RG9tRWxlbWVudCwgJ2Rpc3BsYXknKSxcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyZW50RmxleERpcmVjdGlvbjogKDAsIGNzc0Z1bmN0aW9uc18xLmNzc0V2YWwpKHBhcmVudERvbUVsZW1lbnQsICdmbGV4LWRpcmVjdGlvbicpLFxuICAgICAgICB9O1xuICAgICAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnNldE1lbW9yeVN0b3JhZ2VJdGVtKSgnbW91c2VEcmFnQ29udGV4dCcsIG1vdXNlRHJhZ0NvbnRleHQpO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkRSQUdfU1RBUlRfRVZFTlQsXG4gICAgICAgICAgICBldmVudDogbW91c2VEcmFnQ29udGV4dCxcbiAgICAgICAgICAgIG91dGVySFRNTDogc2VsZWN0ZWRFbGVtZW50ID09PSBudWxsIHx8IHNlbGVjdGVkRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRFbGVtZW50Lm91dGVySFRNTCxcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBvdXRsaW5lVXRpbHNfMS51cGRhdGVPdXRsaW5lcykocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cudHJpZ2dlckRyYWdDYW5jZWwgPSAocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSA9PiB7XG4gICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKCdtb3VzZURyYWdDb250ZXh0JywgbnVsbCk7XG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkRSQUdfQ0FOQ0VMX0VWRU5ULFxuICAgICAgICAgICAgZXZlbnQ6IHt9LFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIG91dGxpbmVVdGlsc18xLnVwZGF0ZU91dGxpbmVzKShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5zZXRJc0ZsdXNoaW5nID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCwgaXNGbHVzaGluZykgPT4ge1xuICAgICAgICBjb25zdCB3YXNGbHVzaGluZyA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5JU19GTFVTSElORyk7XG4gICAgICAgICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuc2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5JU19GTFVTSElORywgaXNGbHVzaGluZyk7XG4gICAgICAgIGlmIChpc0ZsdXNoaW5nICYmICF3YXNGbHVzaGluZykge1xuICAgICAgICAgICAgb25GbHVzaFN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydHMuaW5pdENoYW5uZWxNZXNzYWdpbmdGdW5jdGlvbnMgPSBpbml0Q2hhbm5lbE1lc3NhZ2luZ0Z1bmN0aW9ucztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/channelMessagingFunctions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/constantsAndTypes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/constantsAndTypes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.STORYBOARD_HYDRATION_STATUS = exports.SELECT_OR_HOVER_STORYBOARD = exports.DELETE_STYLE_CONSTANT = exports.FIXED_IFRAME_MESSAGE_IDS = exports.INHERITABLE_CSS_PROPS = exports.CSS_VALUES_TO_COLLECT_FOR_PARENT = exports.CSS_VALUES_TO_COLLECT = void 0;\nexports.CSS_VALUES_TO_COLLECT = new Set([\n    'display',\n    'flex-direction',\n    'flex-grow',\n    'flex-shrink',\n    'font-family',\n    'align-items',\n    'justify-content',\n    'column-gap',\n    'row-gap',\n    'flex-wrap',\n    'align-content',\n    'overflow',\n    'text-align',\n    'width',\n    'max-width',\n    'min-width',\n    'height',\n    'max-height',\n    'min-height',\n    'font-size',\n    'line-height',\n    'padding',\n    'padding-top',\n    'padding-left',\n    'padding-right',\n    'padding-bottom',\n    'margin',\n    'margin-top',\n    'margin-left',\n    'margin-right',\n    'margin-bottom',\n    'border-radius',\n    'font-family',\n    'font-weight',\n    'object-fit',\n    'background-clip',\n    'border-left-style',\n    'border-top-style',\n    'border-right-style',\n    'border-bottom-style',\n    'border-left-width',\n    'border-top-width',\n    'border-right-width',\n    'border-bottom-width',\n    'border-left-color',\n    'border-top-color',\n    'border-right-color',\n    'border-bottom-color',\n    'background-color',\n    'color',\n    'transform',\n    'border-top-left-radius',\n    'border-top-right-radius',\n    'border-bottom-right-radius',\n    'border-bottom-left-radius',\n    'letter-spacing',\n    'opacity',\n    'font-style',\n    'text-decoration-line',\n    'top',\n    'left',\n    'right',\n    'bottom',\n    'position',\n    'background-image',\n]);\nexports.CSS_VALUES_TO_COLLECT_FOR_PARENT = new Set([\n    'display',\n    'flex-direction',\n]);\n// Taken from https://web.dev/learn/css/inheritance/\nexports.INHERITABLE_CSS_PROPS = {\n    azimuth: true,\n    'border-collapse': true,\n    'border-spacing': true,\n    'caption-side': true,\n    color: true,\n    cursor: true,\n    direction: true,\n    'empty-cells': true,\n    'font-family': true,\n    'font-size': true,\n    'font-style': true,\n    'font-variant': true,\n    'font-weight': true,\n    font: true,\n    'letter-spacing': true,\n    'line-height': true,\n    'list-style-image': true,\n    'list-style-position': true,\n    'list-style-type': true,\n    'list-style': true,\n    orphans: true,\n    quotes: true,\n    'text-align': true,\n    'text-indent': true,\n    'text-transform': true,\n    visibility: true,\n    'white-space': true,\n    widows: true,\n    'word-spacing': true,\n};\n// Matches the interface on the frontend\nvar FIXED_IFRAME_MESSAGE_IDS;\n(function (FIXED_IFRAME_MESSAGE_IDS) {\n    FIXED_IFRAME_MESSAGE_IDS[\"HOVERED_ELEMENT_KEY\"] = \"HOVERED_ELEMENT_KEY\";\n    FIXED_IFRAME_MESSAGE_IDS[\"SELECTED_ELEMENT_KEY\"] = \"SELECTED_ELEMENT_KEY\";\n    FIXED_IFRAME_MESSAGE_IDS[\"MULTI_SELECTED_ELEMENT_KEYS\"] = \"MULTI_SELECTED_ELEMENT_KEYS\";\n    FIXED_IFRAME_MESSAGE_IDS[\"CONTEXT_REQUESTED\"] = \"CONTEXT_REQUESTED\";\n    FIXED_IFRAME_MESSAGE_IDS[\"WHEEL_EVENT\"] = \"WHEEL_EVENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"NAV_TREE\"] = \"NAV_TREE\";\n    FIXED_IFRAME_MESSAGE_IDS[\"PROCESSED_CSS_RULES_FOR_ELEMENT\"] = \"PROCESSED_CSS_RULES_FOR_ELEMENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"CSS_EVALS_FOR_ELEMENT\"] = \"CSS_EVALS_FOR_ELEMENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"ELEMENT_CLASS_LIST\"] = \"ELEMENT_CLASS_LIST\";\n    FIXED_IFRAME_MESSAGE_IDS[\"KEY_DOWN_EVENT\"] = \"KEY_DOWN_EVENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"KEY_UP_EVENT\"] = \"KEY_UP_EVENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"MOUSE_MOVE_EVENT\"] = \"MOUSE_MOVE_EVENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"DRAG_START_EVENT\"] = \"DRAG_START_EVENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"DRAG_END_EVENT\"] = \"DRAG_END_EVENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"DRAG_CANCEL_EVENT\"] = \"DRAG_CANCEL_EVENT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"LATEST_HREF\"] = \"LATEST_HREF\";\n    FIXED_IFRAME_MESSAGE_IDS[\"LATEST_HYDRATION_ERROR_STATUS\"] = \"LATEST_HYDRATION_ERROR_STATUS\";\n    FIXED_IFRAME_MESSAGE_IDS[\"START_EDITING_TEXT\"] = \"START_EDITING_TEXT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"EDITED_TEXT\"] = \"EDITED_TEXT\";\n    FIXED_IFRAME_MESSAGE_IDS[\"INSTANT_UPDATE_DONE\"] = \"INSTANT_UPDATE_DONE\";\n    FIXED_IFRAME_MESSAGE_IDS[\"EDIT_DYNAMIC_TEXT\"] = \"EDIT_DYNAMIC_TEXT\";\n})(FIXED_IFRAME_MESSAGE_IDS || (exports.FIXED_IFRAME_MESSAGE_IDS = FIXED_IFRAME_MESSAGE_IDS = {}));\nexports.DELETE_STYLE_CONSTANT = null;\nexports.SELECT_OR_HOVER_STORYBOARD = 'SELECT_OR_HOVER_STORYBOARD';\nvar STORYBOARD_HYDRATION_STATUS;\n(function (STORYBOARD_HYDRATION_STATUS) {\n    STORYBOARD_HYDRATION_STATUS[\"OTHER_ERROR\"] = \"other_error\";\n    STORYBOARD_HYDRATION_STATUS[\"ERROR\"] = \"error\";\n    STORYBOARD_HYDRATION_STATUS[\"NO_ERROR\"] = \"no_error\";\n})(STORYBOARD_HYDRATION_STATUS || (exports.STORYBOARD_HYDRATION_STATUS = STORYBOARD_HYDRATION_STATUS = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2NvbnN0YW50c0FuZFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQyxHQUFHLGtDQUFrQyxHQUFHLDZCQUE2QixHQUFHLGdDQUFnQyxHQUFHLDZCQUE2QixHQUFHLHdDQUF3QyxHQUFHLDZCQUE2QjtBQUN0UCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCLGdDQUFnQyxnQ0FBZ0M7QUFDaEcsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsbUNBQW1DLG1DQUFtQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHRlbXBvLWRldnRvb2xzXFxkaXN0XFxjaGFubmVsTWVzc2FnaW5nXFxjb25zdGFudHNBbmRUeXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1RPUllCT0FSRF9IWURSQVRJT05fU1RBVFVTID0gZXhwb3J0cy5TRUxFQ1RfT1JfSE9WRVJfU1RPUllCT0FSRCA9IGV4cG9ydHMuREVMRVRFX1NUWUxFX0NPTlNUQU5UID0gZXhwb3J0cy5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMgPSBleHBvcnRzLklOSEVSSVRBQkxFX0NTU19QUk9QUyA9IGV4cG9ydHMuQ1NTX1ZBTFVFU19UT19DT0xMRUNUX0ZPUl9QQVJFTlQgPSBleHBvcnRzLkNTU19WQUxVRVNfVE9fQ09MTEVDVCA9IHZvaWQgMDtcbmV4cG9ydHMuQ1NTX1ZBTFVFU19UT19DT0xMRUNUID0gbmV3IFNldChbXG4gICAgJ2Rpc3BsYXknLFxuICAgICdmbGV4LWRpcmVjdGlvbicsXG4gICAgJ2ZsZXgtZ3JvdycsXG4gICAgJ2ZsZXgtc2hyaW5rJyxcbiAgICAnZm9udC1mYW1pbHknLFxuICAgICdhbGlnbi1pdGVtcycsXG4gICAgJ2p1c3RpZnktY29udGVudCcsXG4gICAgJ2NvbHVtbi1nYXAnLFxuICAgICdyb3ctZ2FwJyxcbiAgICAnZmxleC13cmFwJyxcbiAgICAnYWxpZ24tY29udGVudCcsXG4gICAgJ292ZXJmbG93JyxcbiAgICAndGV4dC1hbGlnbicsXG4gICAgJ3dpZHRoJyxcbiAgICAnbWF4LXdpZHRoJyxcbiAgICAnbWluLXdpZHRoJyxcbiAgICAnaGVpZ2h0JyxcbiAgICAnbWF4LWhlaWdodCcsXG4gICAgJ21pbi1oZWlnaHQnLFxuICAgICdmb250LXNpemUnLFxuICAgICdsaW5lLWhlaWdodCcsXG4gICAgJ3BhZGRpbmcnLFxuICAgICdwYWRkaW5nLXRvcCcsXG4gICAgJ3BhZGRpbmctbGVmdCcsXG4gICAgJ3BhZGRpbmctcmlnaHQnLFxuICAgICdwYWRkaW5nLWJvdHRvbScsXG4gICAgJ21hcmdpbicsXG4gICAgJ21hcmdpbi10b3AnLFxuICAgICdtYXJnaW4tbGVmdCcsXG4gICAgJ21hcmdpbi1yaWdodCcsXG4gICAgJ21hcmdpbi1ib3R0b20nLFxuICAgICdib3JkZXItcmFkaXVzJyxcbiAgICAnZm9udC1mYW1pbHknLFxuICAgICdmb250LXdlaWdodCcsXG4gICAgJ29iamVjdC1maXQnLFxuICAgICdiYWNrZ3JvdW5kLWNsaXAnLFxuICAgICdib3JkZXItbGVmdC1zdHlsZScsXG4gICAgJ2JvcmRlci10b3Atc3R5bGUnLFxuICAgICdib3JkZXItcmlnaHQtc3R5bGUnLFxuICAgICdib3JkZXItYm90dG9tLXN0eWxlJyxcbiAgICAnYm9yZGVyLWxlZnQtd2lkdGgnLFxuICAgICdib3JkZXItdG9wLXdpZHRoJyxcbiAgICAnYm9yZGVyLXJpZ2h0LXdpZHRoJyxcbiAgICAnYm9yZGVyLWJvdHRvbS13aWR0aCcsXG4gICAgJ2JvcmRlci1sZWZ0LWNvbG9yJyxcbiAgICAnYm9yZGVyLXRvcC1jb2xvcicsXG4gICAgJ2JvcmRlci1yaWdodC1jb2xvcicsXG4gICAgJ2JvcmRlci1ib3R0b20tY29sb3InLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAnY29sb3InLFxuICAgICd0cmFuc2Zvcm0nLFxuICAgICdib3JkZXItdG9wLWxlZnQtcmFkaXVzJyxcbiAgICAnYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMnLFxuICAgICdib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cycsXG4gICAgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnLFxuICAgICdsZXR0ZXItc3BhY2luZycsXG4gICAgJ29wYWNpdHknLFxuICAgICdmb250LXN0eWxlJyxcbiAgICAndGV4dC1kZWNvcmF0aW9uLWxpbmUnLFxuICAgICd0b3AnLFxuICAgICdsZWZ0JyxcbiAgICAncmlnaHQnLFxuICAgICdib3R0b20nLFxuICAgICdwb3NpdGlvbicsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UnLFxuXSk7XG5leHBvcnRzLkNTU19WQUxVRVNfVE9fQ09MTEVDVF9GT1JfUEFSRU5UID0gbmV3IFNldChbXG4gICAgJ2Rpc3BsYXknLFxuICAgICdmbGV4LWRpcmVjdGlvbicsXG5dKTtcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly93ZWIuZGV2L2xlYXJuL2Nzcy9pbmhlcml0YW5jZS9cbmV4cG9ydHMuSU5IRVJJVEFCTEVfQ1NTX1BST1BTID0ge1xuICAgIGF6aW11dGg6IHRydWUsXG4gICAgJ2JvcmRlci1jb2xsYXBzZSc6IHRydWUsXG4gICAgJ2JvcmRlci1zcGFjaW5nJzogdHJ1ZSxcbiAgICAnY2FwdGlvbi1zaWRlJzogdHJ1ZSxcbiAgICBjb2xvcjogdHJ1ZSxcbiAgICBjdXJzb3I6IHRydWUsXG4gICAgZGlyZWN0aW9uOiB0cnVlLFxuICAgICdlbXB0eS1jZWxscyc6IHRydWUsXG4gICAgJ2ZvbnQtZmFtaWx5JzogdHJ1ZSxcbiAgICAnZm9udC1zaXplJzogdHJ1ZSxcbiAgICAnZm9udC1zdHlsZSc6IHRydWUsXG4gICAgJ2ZvbnQtdmFyaWFudCc6IHRydWUsXG4gICAgJ2ZvbnQtd2VpZ2h0JzogdHJ1ZSxcbiAgICBmb250OiB0cnVlLFxuICAgICdsZXR0ZXItc3BhY2luZyc6IHRydWUsXG4gICAgJ2xpbmUtaGVpZ2h0JzogdHJ1ZSxcbiAgICAnbGlzdC1zdHlsZS1pbWFnZSc6IHRydWUsXG4gICAgJ2xpc3Qtc3R5bGUtcG9zaXRpb24nOiB0cnVlLFxuICAgICdsaXN0LXN0eWxlLXR5cGUnOiB0cnVlLFxuICAgICdsaXN0LXN0eWxlJzogdHJ1ZSxcbiAgICBvcnBoYW5zOiB0cnVlLFxuICAgIHF1b3RlczogdHJ1ZSxcbiAgICAndGV4dC1hbGlnbic6IHRydWUsXG4gICAgJ3RleHQtaW5kZW50JzogdHJ1ZSxcbiAgICAndGV4dC10cmFuc2Zvcm0nOiB0cnVlLFxuICAgIHZpc2liaWxpdHk6IHRydWUsXG4gICAgJ3doaXRlLXNwYWNlJzogdHJ1ZSxcbiAgICB3aWRvd3M6IHRydWUsXG4gICAgJ3dvcmQtc3BhY2luZyc6IHRydWUsXG59O1xuLy8gTWF0Y2hlcyB0aGUgaW50ZXJmYWNlIG9uIHRoZSBmcm9udGVuZFxudmFyIEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUztcbihmdW5jdGlvbiAoRklYRURfSUZSQU1FX01FU1NBR0VfSURTKSB7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiSE9WRVJFRF9FTEVNRU5UX0tFWVwiXSA9IFwiSE9WRVJFRF9FTEVNRU5UX0tFWVwiO1xuICAgIEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEU1tcIlNFTEVDVEVEX0VMRU1FTlRfS0VZXCJdID0gXCJTRUxFQ1RFRF9FTEVNRU5UX0tFWVwiO1xuICAgIEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEU1tcIk1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZU1wiXSA9IFwiTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiQ09OVEVYVF9SRVFVRVNURURcIl0gPSBcIkNPTlRFWFRfUkVRVUVTVEVEXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiV0hFRUxfRVZFTlRcIl0gPSBcIldIRUVMX0VWRU5UXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiTkFWX1RSRUVcIl0gPSBcIk5BVl9UUkVFXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiUFJPQ0VTU0VEX0NTU19SVUxFU19GT1JfRUxFTUVOVFwiXSA9IFwiUFJPQ0VTU0VEX0NTU19SVUxFU19GT1JfRUxFTUVOVFwiO1xuICAgIEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEU1tcIkNTU19FVkFMU19GT1JfRUxFTUVOVFwiXSA9IFwiQ1NTX0VWQUxTX0ZPUl9FTEVNRU5UXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiRUxFTUVOVF9DTEFTU19MSVNUXCJdID0gXCJFTEVNRU5UX0NMQVNTX0xJU1RcIjtcbiAgICBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFNbXCJLRVlfRE9XTl9FVkVOVFwiXSA9IFwiS0VZX0RPV05fRVZFTlRcIjtcbiAgICBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFNbXCJLRVlfVVBfRVZFTlRcIl0gPSBcIktFWV9VUF9FVkVOVFwiO1xuICAgIEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEU1tcIk1PVVNFX01PVkVfRVZFTlRcIl0gPSBcIk1PVVNFX01PVkVfRVZFTlRcIjtcbiAgICBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFNbXCJEUkFHX1NUQVJUX0VWRU5UXCJdID0gXCJEUkFHX1NUQVJUX0VWRU5UXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiRFJBR19FTkRfRVZFTlRcIl0gPSBcIkRSQUdfRU5EX0VWRU5UXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiRFJBR19DQU5DRUxfRVZFTlRcIl0gPSBcIkRSQUdfQ0FOQ0VMX0VWRU5UXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiTEFURVNUX0hSRUZcIl0gPSBcIkxBVEVTVF9IUkVGXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiTEFURVNUX0hZRFJBVElPTl9FUlJPUl9TVEFUVVNcIl0gPSBcIkxBVEVTVF9IWURSQVRJT05fRVJST1JfU1RBVFVTXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiU1RBUlRfRURJVElOR19URVhUXCJdID0gXCJTVEFSVF9FRElUSU5HX1RFWFRcIjtcbiAgICBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFNbXCJFRElURURfVEVYVFwiXSA9IFwiRURJVEVEX1RFWFRcIjtcbiAgICBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFNbXCJJTlNUQU5UX1VQREFURV9ET05FXCJdID0gXCJJTlNUQU5UX1VQREFURV9ET05FXCI7XG4gICAgRklYRURfSUZSQU1FX01FU1NBR0VfSURTW1wiRURJVF9EWU5BTUlDX1RFWFRcIl0gPSBcIkVESVRfRFlOQU1JQ19URVhUXCI7XG59KShGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMgfHwgKGV4cG9ydHMuRklYRURfSUZSQU1FX01FU1NBR0VfSURTID0gRklYRURfSUZSQU1FX01FU1NBR0VfSURTID0ge30pKTtcbmV4cG9ydHMuREVMRVRFX1NUWUxFX0NPTlNUQU5UID0gbnVsbDtcbmV4cG9ydHMuU0VMRUNUX09SX0hPVkVSX1NUT1JZQk9BUkQgPSAnU0VMRUNUX09SX0hPVkVSX1NUT1JZQk9BUkQnO1xudmFyIFNUT1JZQk9BUkRfSFlEUkFUSU9OX1NUQVRVUztcbihmdW5jdGlvbiAoU1RPUllCT0FSRF9IWURSQVRJT05fU1RBVFVTKSB7XG4gICAgU1RPUllCT0FSRF9IWURSQVRJT05fU1RBVFVTW1wiT1RIRVJfRVJST1JcIl0gPSBcIm90aGVyX2Vycm9yXCI7XG4gICAgU1RPUllCT0FSRF9IWURSQVRJT05fU1RBVFVTW1wiRVJST1JcIl0gPSBcImVycm9yXCI7XG4gICAgU1RPUllCT0FSRF9IWURSQVRJT05fU1RBVFVTW1wiTk9fRVJST1JcIl0gPSBcIm5vX2Vycm9yXCI7XG59KShTVE9SWUJPQVJEX0hZRFJBVElPTl9TVEFUVVMgfHwgKGV4cG9ydHMuU1RPUllCT0FSRF9IWURSQVRJT05fU1RBVFVTID0gU1RPUllCT0FSRF9IWURSQVRJT05fU1RBVFVTID0ge30pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/constantsAndTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssFunctions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/cssFunctions.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ruleMatchesElement = exports.getElementClassList = exports.getCssEvals = exports.cssEval = exports.processRulesForSelectedElement = exports.setModifiersForSelectedElement = exports.parse = void 0;\n// @ts-ignore\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\"));\nconst identifierUtils_1 = __webpack_require__(/*! ./identifierUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js\");\nconst cssRuleUtils_1 = __webpack_require__(/*! ./cssRuleUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssRuleUtils.js\");\nconst constantsAndTypes_1 = __webpack_require__(/*! ./constantsAndTypes */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/constantsAndTypes.js\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\");\nconst specificity_1 = __webpack_require__(/*! specificity */ \"(ssr)/./node_modules/specificity/dist/specificity.mjs\");\nconst tempoElement_1 = __webpack_require__(/*! ./tempoElement */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js\");\nconst css_selector_parser_1 = __webpack_require__(/*! css-selector-parser */ \"(ssr)/./node_modules/css-selector-parser/dist/cjs/index.js\");\nconst sessionStorageUtils_1 = __webpack_require__(/*! ./sessionStorageUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js\");\nconst navTreeUtils_1 = __webpack_require__(/*! ./navTreeUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/navTreeUtils.js\");\nexports.parse = (0, css_selector_parser_1.createParser)({\n    syntax: {\n        baseSyntax: 'latest',\n        pseudoClasses: {\n            unknown: 'accept',\n            definitions: {\n                Selector: ['has'],\n            },\n        },\n        pseudoElements: {\n            unknown: 'accept',\n        },\n        combinators: ['>', '+', '~'],\n        attributes: {\n            operators: ['^=', '$=', '*=', '~='],\n        },\n        classNames: true,\n        namespace: {\n            wildcard: true,\n        },\n        tag: {\n            wildcard: true,\n        },\n    },\n    substitutes: true,\n});\nconst addCSSRule = (styleSheet, selector, rules, index) => {\n    try {\n        if (styleSheet.insertRule) {\n            styleSheet.insertRule(`${selector} { ${rules} }`, index);\n        }\n        else {\n            styleSheet.addRule(selector, rules, index);\n        }\n    }\n    catch (e) {\n        console.log('Error adding rule: ', e);\n    }\n};\n/**\n * This method filters and process media query rules for responsive modifiers to extract Tailwind responsive classes.\n * A Tailwind responsive modifiers takes the form:\n *\n *   {sm,md,lg...}:className\n *\n * which is represented as:\n *\n * @media (min-width: 640px) {\n *    .sm\\:className {\n *     ...\n *   }\n * }\n *\n * This is why we need to filter for media query rules with min-width and then extract the class name.\n * @param rule\n * @returns\n */\nconst processMediaQueryRulesForResponsiveModifiers = (rule) => {\n    let rules = [];\n    if (rule instanceof CSSMediaRule) {\n        // Loop through each CSSRule within the CSSMediaRule\n        for (let innerRule of rule.cssRules) {\n            // Check for min-width in media queries and that it is a style rule\n            if (rule.media.mediaText.includes('min-width') &&\n                innerRule instanceof CSSStyleRule) {\n                const parsedIsSelector = (0, exports.parse)(innerRule.selectorText);\n                if (parsedIsSelector.type !== 'Selector') {\n                    continue;\n                }\n                const lastRule = parsedIsSelector.rules[0];\n                const classNames = lastRule.items.filter((item) => item.type === 'ClassName').map((item) => item.name);\n                if (classNames.length !== 1) {\n                    continue;\n                }\n                // Extract Tailwind responsive modifiers\n                rules.push({\n                    class: classNames[0],\n                    pseudos: extractTailwindPrefixes(classNames[0]),\n                    cssText: innerRule.style.cssText,\n                    style: innerRule.style,\n                });\n            }\n        }\n    }\n    return rules;\n};\n/**\n * Since Tailwind CSS responsive modifiers are not CSS pseudo classes, we need to extract them from the class name.\n * We use a regex to match the responsive prefixes and return them as a set.\n * @param selectorText\n * @returns Set[prefixes]\n */\nconst extractTailwindPrefixes = (selectorText) => {\n    // This regex matches classes with responsive prefixes that might be preceded by a period or another colon\n    const prefixRegex = /(?:\\b|(?<=[:.]))(sm|md|lg|xl|2xl)\\\\?:[\\w-]+/g;\n    const matches = selectorText.match(prefixRegex) || [];\n    const prefixes = matches.map((match) => {\n        // Find the index of the colon or escaped colon\n        const index = match.indexOf(match.includes('\\\\:') ? '\\\\:' : ':');\n        return match.substring(0, index);\n    });\n    return [...new Set(prefixes)]; // Remove duplicates\n};\n/**\n * Tailwind CSS dark mode classes (< 3.4.1) are specified using the `:is` pseudo selector and take the form\n *   :is(.dark .dark:bg-red-200)\n * This is to support the behaviour that dark mode classes are applied to the element when the dark class is present in the parent.\n *\n * TODO: We should support the new Tailwind CSS dark mode classes in 3.4.1 and above which are specified using the `@media (prefers-color-scheme: dark)` media query.\n * @param isSelectorString\n * @returns\n */\nconst processIsSelectorForDarkMode = (isSelector) => {\n    if (isSelector.type !== 'Selector') {\n        return;\n    }\n    const firstRule = isSelector.rules[0];\n    const classNames = firstRule.items.filter((item) => item.type === 'ClassName').map((item) => item.name);\n    if (classNames.length === 0 || classNames[0] !== 'dark') {\n        return;\n    }\n    const nestedRule = firstRule.nestedRule;\n    if (!nestedRule) {\n        return;\n    }\n    let darkModeClasses = [];\n    const nestedClassNames = nestedRule.items.filter((item) => item.type === 'ClassName').map((item) => item.name);\n    if (nestedClassNames.length > 1) {\n        console.log('Skipping is selector with multiple classes', firstRule);\n        return;\n    }\n    darkModeClasses.push({\n        class: nestedClassNames[0],\n        pseudos: [\n            'dark',\n            ...nestedRule.items.filter((item) => item.type === 'PseudoClass').map((p) => p.name),\n        ],\n    });\n    return darkModeClasses;\n};\nconst setModifiersForSelectedElement = (parentPort, modifiers, selectedElementKey) => {\n    // Remove all existing force classes from entire document\n    const allElements = document.querySelectorAll('[class*=\"tempo-force-\"]');\n    allElements.forEach((element) => {\n        const classes = Array.from(element.classList);\n        classes.forEach((cls) => {\n            if (cls.startsWith('tempo-force-')) {\n                element.classList.remove(cls);\n            }\n        });\n    });\n    const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n    if (selectedElement.isEmpty()) {\n        return;\n    }\n    const selectedDomElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectedElement.getKey()}`).get(0);\n    if (!selectedDomElement) {\n        return;\n    }\n    modifiers.forEach((modifier) => {\n        selectedDomElement.classList.add('tempo-force-' + modifier);\n    });\n};\nexports.setModifiersForSelectedElement = setModifiersForSelectedElement;\nconst processRulesForSelectedElement = (parentPort, cssElementLookup, selectedElementKey) => {\n    var _a, _b, _c, _d, _e;\n    // TODO: this whole function is slow, fix\n    if (!cssElementLookup) {\n        return;\n    }\n    const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n    if (selectedElement.isEmpty()) {\n        return;\n    }\n    const selectedDomElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectedElement.getKey()}`).get(0);\n    const multiSelectedElementKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS) || [];\n    /**\n     * If there's no selected DOM element yet, it implies the nav tree isn't built yet.\n     * We register a callback to defer the processing of the rules until the nav tree is built.\n     */\n    if (!selectedDomElement) {\n        (0, navTreeUtils_1.addNavTreeBuiltCallback)({\n            callbackFn: () => {\n                (0, exports.processRulesForSelectedElement)(parentPort, cssElementLookup, selectedElementKey);\n            },\n            state: {\n                selectedElementKey: selectedElementKey,\n                multiSelectedElementKeys: multiSelectedElementKeys,\n            },\n        });\n        return;\n    }\n    const newProcessedCssRules = [];\n    const extractedKnownClasses = new Set();\n    const knownSelectors = new Set();\n    // First get the inline style of the element\n    const inlineStyleRule = {\n        filename: '',\n        selector: 'element.style',\n        source: {},\n        styles: {},\n        applied: true,\n        codebaseId: 'element.style',\n        removable: false,\n        allowChanges: true,\n    };\n    for (let i = 0; i < ((_a = selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.style) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {\n        const cssName = selectedDomElement.style[i];\n        // @ts-ignore\n        inlineStyleRule.styles[cssName] = selectedDomElement.style[cssName];\n    }\n    newProcessedCssRules.push(inlineStyleRule);\n    // Only check the inline-styles of the parent once\n    let checkedInlineStylesOfParent = false;\n    const directMatchCssRules = [];\n    const otherCssRules = [];\n    Object.keys(cssElementLookup).forEach((codebaseId) => {\n        var _a;\n        const cssRule = cssElementLookup[codebaseId];\n        knownSelectors.add(cssRule.selector);\n        if (!(0, cssRuleUtils_1.isCssSelectorValid)(cssRule.selector)) {\n            return;\n        }\n        (0, cssRuleUtils_1.getAllClassesFromSelector)(cssRule.selector).forEach((cls) => {\n            extractedKnownClasses.add(cls);\n        });\n        // First check if a rule directly matches\n        if ((0, cssRuleUtils_1.isCssSelectorValid)(cssRule.selector) &&\n            (selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches(cssRule.selector))) {\n            directMatchCssRules.push(Object.assign(Object.assign({}, cssRule), { applied: true, allowChanges: true, removable: (0, cssRuleUtils_1.canRemoveCssClassFromElement)(cssRule.selector, selectedDomElement) }));\n            return;\n        }\n        // In order to make the parentElement.style selector unique\n        let parentElementIndex = 0;\n        // Then check the parents if it's a rule with properties that are inherited\n        let parentDomElement = selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.parentElement;\n        const inheritedStyles = {};\n        while (parentDomElement) {\n            // Inline styles are prioritized over rule based styles\n            if (!checkedInlineStylesOfParent) {\n                const inlineStyleOfParent = {};\n                for (let i = 0; i < ((_a = parentDomElement === null || parentDomElement === void 0 ? void 0 : parentDomElement.style) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {\n                    const cssName = parentDomElement.style[i];\n                    if (constantsAndTypes_1.INHERITABLE_CSS_PROPS[cssName]) {\n                        inlineStyleOfParent[cssName] = parentDomElement.style[cssName];\n                    }\n                }\n                if (Object.keys(inlineStyleOfParent).length !== 0) {\n                    otherCssRules.push({\n                        filename: '',\n                        // TODO: make this unique\n                        selector: `parentElement${parentElementIndex}.style`,\n                        inherited: true,\n                        source: {},\n                        styles: inlineStyleOfParent,\n                        applied: true,\n                        codebaseId: `parentElement${parentElementIndex}.style`,\n                        removable: false,\n                        allowChanges: false,\n                    });\n                }\n            }\n            // Css defined styles\n            if ((0, cssRuleUtils_1.isCssSelectorValid)(cssRule.selector) &&\n                !(parentDomElement === null || parentDomElement === void 0 ? void 0 : parentDomElement.matches(cssRule.selector))) {\n                parentDomElement = parentDomElement.parentElement;\n                continue;\n            }\n            Object.keys((cssRule === null || cssRule === void 0 ? void 0 : cssRule.styles) || {}).forEach((cssName) => {\n                // Prioritize inherited styles that are further down the tree\n                if (constantsAndTypes_1.INHERITABLE_CSS_PROPS[cssName] &&\n                    inheritedStyles[cssName] !== null) {\n                    inheritedStyles[cssName] = cssRule.styles[cssName];\n                }\n            });\n            parentDomElement = parentDomElement.parentElement;\n            parentElementIndex += 1;\n        }\n        // Check once across all css rules\n        checkedInlineStylesOfParent = true;\n        // Just because a css rule is inherited doesn't mean it can't be eligible to apply,\n        // so do not return after appending this rule\n        if (Object.keys(inheritedStyles).length !== 0) {\n            otherCssRules.push(Object.assign(Object.assign({}, cssRule), { inherited: true, styles: inheritedStyles, applied: true, removable: false, allowChanges: false }));\n        }\n        // Finally check if it's a rule that can be applied if clases are changed\n        otherCssRules.push(Object.assign(Object.assign({}, cssRule), { applied: false, allowChanges: false, eligibleToApply: (0, cssRuleUtils_1.canApplyCssRuleToElement)(cssRule.selector, selectedDomElement) }));\n    });\n    const mainStyleSheet = document.styleSheets[0];\n    // Add any rules not previously added that are available in the stylesheets as read-only\n    for (let i = 0; i < document.styleSheets.length; i += 1) {\n        const sheet = document.styleSheets[i];\n        let rules = null;\n        try {\n            rules = sheet.cssRules;\n        }\n        catch (e) {\n            console.log(e);\n            try {\n                rules = sheet.rules;\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n        if (!rules) {\n            continue;\n        }\n        for (let j = 0; j < rules.length; j += 1) {\n            const rule = rules[j];\n            /**\n             * Handle Tailwind CSS responsive modifiers\n             */\n            const responsiveModifiers = processMediaQueryRulesForResponsiveModifiers(rule);\n            if (responsiveModifiers.length > 0) {\n                for (let k = 0; k < responsiveModifiers.length; k++) {\n                    const modifier = responsiveModifiers[k];\n                    if (!(selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches('.' + CSS.escape(modifier.class)))) {\n                        continue;\n                    }\n                    const styling = {};\n                    for (let l = 0; l < ((_b = modifier === null || modifier === void 0 ? void 0 : modifier.style) === null || _b === void 0 ? void 0 : _b.length) || 0; l += 1) {\n                        const cssName = modifier === null || modifier === void 0 ? void 0 : modifier.style[l];\n                        // @ts-ignore;\n                        styling[cssName] = modifier === null || modifier === void 0 ? void 0 : modifier.style[cssName];\n                    }\n                    const ruleToPush = {\n                        filename: undefined,\n                        selector: CSS.escape('.' + modifier.class),\n                        classParsed: modifier.class,\n                        source: {},\n                        styles: styling,\n                        applied: true,\n                        modifiers: Object.assign({}, modifier.pseudos.reduce((acc, pseudo) => {\n                            acc[pseudo] = true;\n                            return acc;\n                        }, {})),\n                        // Generate a random codebase ID to use for selection\n                        // Note: this ID is shown as a backup in the overridden tooltip\n                        codebaseId: `${modifier.class} ${(0, uuid_1.v4)().toString()}`,\n                        removable: false,\n                        allowChanges: false,\n                        cssText: modifier.cssText,\n                    };\n                    directMatchCssRules.push(ruleToPush);\n                }\n            }\n            if (!rule.selectorText) {\n                continue;\n            }\n            if (knownSelectors.has(rule.selectorText)) {\n                continue;\n            }\n            const parsedCssRule = (0, exports.parse)(rule.selectorText);\n            if (parsedCssRule.type !== 'Selector') {\n                continue;\n            }\n            const firstRule = parsedCssRule.rules[0];\n            if (!firstRule) {\n                continue;\n            }\n            /**\n             * This is a special case for the `:is` pseudo selector, which is how Tailwind specifies dark mode classes.\n             */\n            const classNames = firstRule.items.filter((item) => item.type === 'ClassName').map((item) => item.name);\n            const pseudos = firstRule.items.filter((item) => item.type === 'PseudoClass');\n            // TODO: Add support for https://github.com/tailwindlabs/tailwindcss/pull/13379 (~3.4.4)\n            if (classNames.length === 0 &&\n                pseudos.length === 1 &&\n                pseudos[0].name === 'is') {\n                const pseudo = pseudos[0];\n                if (pseudo && ((_c = pseudo.argument) === null || _c === void 0 ? void 0 : _c.type) === 'Selector') {\n                    const darkModeClasses = processIsSelectorForDarkMode(pseudo.argument);\n                    if (darkModeClasses) {\n                        for (const darkModeClass of darkModeClasses) {\n                            if (!(selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches('.' + CSS.escape(darkModeClass.class)))) {\n                                continue;\n                            }\n                            const styling = {};\n                            for (let k = 0; k < ((_d = rule === null || rule === void 0 ? void 0 : rule.style) === null || _d === void 0 ? void 0 : _d.length) || 0; k += 1) {\n                                const cssName = rule.style[k];\n                                styling[cssName] = rule.style[cssName];\n                            }\n                            const ruleToPush = {\n                                filename: undefined,\n                                selector: CSS.escape('.' + darkModeClass.class),\n                                classParsed: darkModeClass.class,\n                                source: {},\n                                styles: styling,\n                                applied: true,\n                                modifiers: Object.assign({}, darkModeClass.pseudos.reduce((acc, pseudo) => {\n                                    acc[pseudo] = true;\n                                    return acc;\n                                }, {})),\n                                // Generate a random codebase ID to use for selection\n                                // Note: this ID is shown as a backup in the overridden tooltip\n                                codebaseId: `${rule.selectorText} ${(0, uuid_1.v4)().toString()}`,\n                                removable: false,\n                                allowChanges: false,\n                                cssText: rule.style.cssText,\n                            };\n                            directMatchCssRules.push(ruleToPush);\n                        }\n                    }\n                }\n            }\n            if (classNames.length === 0 || classNames.length > 1) {\n                continue;\n            }\n            const cls = classNames[0];\n            const pseudoClasses = firstRule.items.filter((item) => item.type === 'PseudoClass').map((p) => p.name);\n            try {\n                if (selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches('.' + CSS.escape(cls))) {\n                    const styling = {};\n                    for (let k = 0; k < ((_e = rule === null || rule === void 0 ? void 0 : rule.style) === null || _e === void 0 ? void 0 : _e.length) || 0; k += 1) {\n                        const cssName = rule.style[k];\n                        styling[cssName] = rule.style[cssName];\n                    }\n                    directMatchCssRules.push({\n                        filename: undefined,\n                        selector: rule.selectorText,\n                        classParsed: cls,\n                        source: {},\n                        styles: styling,\n                        applied: true,\n                        modifiers: Object.assign({}, pseudoClasses.reduce((acc, pseudo) => {\n                            acc[pseudo.name] = true;\n                            return acc;\n                        }, {})),\n                        // Generate a random codebase ID to use for selection\n                        // Note: this ID is shown as a backup in the overridden tooltip\n                        codebaseId: `${rule.selectorText} ${(0, uuid_1.v4)().toString()}`,\n                        removable: false,\n                        allowChanges: false,\n                        cssText: rule.style.cssText,\n                    });\n                }\n                else {\n                    // console.log(\"NO MATCH\", cls)\n                }\n            }\n            catch (e) {\n                // console.error(e);\n            }\n        }\n    }\n    // For each direct match rule, check if it has modifiers and create a new rule for each modifier.\n    for (let i = 0; i < directMatchCssRules.length; i++) {\n        const currentRule = directMatchCssRules[i];\n        if (!currentRule.modifiers) {\n            continue;\n        }\n        const rulePseudos = Object.keys(currentRule.modifiers);\n        if (rulePseudos.length < 1) {\n            continue;\n        }\n        const cls = currentRule.classParsed;\n        if (!cls) {\n            continue;\n        }\n        const cssText = currentRule.cssText;\n        if (!cssText) {\n            continue;\n        }\n        // Create a new custom css rule for ones that have pseudo selectors.\n        // Use the parseClass as the selector and add `tempo-force-[pseudo]` for each pseudo selector\n        const pseudoSelector = rulePseudos\n            .map((pseudo) => '.tempo-force-' + pseudo)\n            .join('');\n        const newSelector = '.' + CSS.escape(cls) + pseudoSelector;\n        const newRules = cssText;\n        // // Inject new rule into the stylesheet\n        addCSSRule(mainStyleSheet, newSelector, newRules, mainStyleSheet.cssRules.length);\n    }\n    const newList = newProcessedCssRules\n        .concat(directMatchCssRules.sort((a, b) => {\n        try {\n            return -(0, specificity_1.compare)(a.selector, b.selector);\n        }\n        catch (_a) {\n            // Put the invalid elements at the end\n            let aValid = true;\n            try {\n                (0, specificity_1.compare)(a.selector, 'body');\n            }\n            catch (e) {\n                aValid = false;\n            }\n            let bValid = true;\n            try {\n                (0, specificity_1.compare)(b.selector, 'body');\n            }\n            catch (e) {\n                bValid = false;\n            }\n            if (aValid && !bValid) {\n                return -1;\n            }\n            if (!aValid && bValid) {\n                return 1;\n            }\n            return 0;\n        }\n    }))\n        .concat(otherCssRules);\n    parentPort.postMessage({\n        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.PROCESSED_CSS_RULES_FOR_ELEMENT,\n        processedCssRules: newList,\n    });\n};\nexports.processRulesForSelectedElement = processRulesForSelectedElement;\nconst cssEval = (element, property) => {\n    return window.getComputedStyle(element, null).getPropertyValue(property);\n};\nexports.cssEval = cssEval;\nconst getCssEvals = (parentPort, selectedElementKey) => {\n    let cssEvals = {};\n    const selectdElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n    if (selectdElement.isEmpty()) {\n        return;\n    }\n    const selectedDomElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectdElement.getKey()}`).get(0);\n    if (!selectedDomElement) {\n        return;\n    }\n    constantsAndTypes_1.CSS_VALUES_TO_COLLECT.forEach((cssName) => {\n        cssEvals[cssName] = (0, exports.cssEval)(selectedDomElement, cssName);\n    });\n    const parentCssEvals = {};\n    const parentElement = selectedDomElement.parentElement;\n    if (parentElement) {\n        constantsAndTypes_1.CSS_VALUES_TO_COLLECT_FOR_PARENT.forEach((cssName) => {\n            parentCssEvals[cssName] = (0, exports.cssEval)(selectedDomElement.parentElement, cssName);\n        });\n        // Use jQuery to check if 'dark' class is in any ancestor of the parent element\n        let darkEnabledInParent = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectdElement.getKey()}`).closest('.dark')\n            .length > 0;\n        parentCssEvals['darkEnabledInParent'] = darkEnabledInParent;\n    }\n    cssEvals['parent'] = parentCssEvals;\n    parentPort.postMessage({\n        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.CSS_EVALS_FOR_ELEMENT,\n        cssEvals,\n    });\n};\nexports.getCssEvals = getCssEvals;\nconst getElementClassList = (parentPort, selectedElementKey) => {\n    const selectdElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n    if (selectdElement.isEmpty()) {\n        return;\n    }\n    const selectedDomElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectdElement.getKey()}`).get(0);\n    if (!selectedDomElement) {\n        return;\n    }\n    parentPort.postMessage({\n        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.ELEMENT_CLASS_LIST,\n        classList: Array.from(selectedDomElement.classList),\n    });\n};\nexports.getElementClassList = getElementClassList;\nconst ruleMatchesElement = (parentPort, messageId, rule, selectedElementKey) => {\n    if (!rule) {\n        return;\n    }\n    const selectdElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n    if (selectdElement.isEmpty()) {\n        return;\n    }\n    const selectedDomElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectdElement.getKey()}`).get(0);\n    if (!selectedDomElement) {\n        return;\n    }\n    parentPort.postMessage({\n        id: messageId,\n        matches: selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches(rule),\n    });\n};\nexports.ruleMatchesElement = ruleMatchesElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2Nzc0Z1bmN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLDJCQUEyQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxzQ0FBc0MsR0FBRyxzQ0FBc0MsR0FBRyxhQUFhO0FBQ2xNO0FBQ0EsaUNBQWlDLG1CQUFPLENBQUMsMERBQVE7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLGlHQUFnQjtBQUMvQyw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBcUI7QUFDekQsZUFBZSxtQkFBTyxDQUFDLDhEQUFNO0FBQzdCLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFhO0FBQzNDLHVCQUF1QixtQkFBTyxDQUFDLGlHQUFnQjtBQUMvQyw4QkFBOEIsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDM0QsOEJBQThCLG1CQUFPLENBQUMsK0dBQXVCO0FBQzdELHVCQUF1QixtQkFBTyxDQUFDLGlHQUFnQjtBQUMvQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVksRUFBRSxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQ0FBcUMsRUFBRSx5QkFBeUI7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQ0FBcUMsRUFBRSx5QkFBeUI7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1LQUFtSztBQUN2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGNBQWMsc0lBQXNJO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkpBQTZKO0FBQzdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQkFBbUI7QUFDckU7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG9EQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjLGdHQUFnRztBQUMzSztBQUNBO0FBQ0EseURBQXlELGNBQWMsMElBQTBJO0FBQ2pOLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUlBQXFJO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0IsRUFBRSw0QkFBNEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlIQUF5SDtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0EsK0NBQStDLG1CQUFtQixFQUFFLDRCQUE0QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlIQUF5SDtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQixFQUFFLDRCQUE0QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQ0FBcUMsRUFBRSx3QkFBd0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNERBQTRELHFDQUFxQyxFQUFFLHdCQUF3QjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFDQUFxQyxFQUFFLHdCQUF3QjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQ0FBcUMsRUFBRSx3QkFBd0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHN5YWhpXFxPbmVEcml2ZVxc2LPYt9itINin2YTZhdmD2KrYqFxcR2Fzc2ltXFxoZWFkc2hvdG1ha2VyYWlwcm9cXG5vZGVfbW9kdWxlc1xcdGVtcG8tZGV2dG9vbHNcXGRpc3RcXGNoYW5uZWxNZXNzYWdpbmdcXGNzc0Z1bmN0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucnVsZU1hdGNoZXNFbGVtZW50ID0gZXhwb3J0cy5nZXRFbGVtZW50Q2xhc3NMaXN0ID0gZXhwb3J0cy5nZXRDc3NFdmFscyA9IGV4cG9ydHMuY3NzRXZhbCA9IGV4cG9ydHMucHJvY2Vzc1J1bGVzRm9yU2VsZWN0ZWRFbGVtZW50ID0gZXhwb3J0cy5zZXRNb2RpZmllcnNGb3JTZWxlY3RlZEVsZW1lbnQgPSBleHBvcnRzLnBhcnNlID0gdm9pZCAwO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QganF1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5jb25zdCBpZGVudGlmaWVyVXRpbHNfMSA9IHJlcXVpcmUoXCIuL2lkZW50aWZpZXJVdGlsc1wiKTtcbmNvbnN0IGNzc1J1bGVVdGlsc18xID0gcmVxdWlyZShcIi4vY3NzUnVsZVV0aWxzXCIpO1xuY29uc3QgY29uc3RhbnRzQW5kVHlwZXNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c0FuZFR5cGVzXCIpO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBzcGVjaWZpY2l0eV8xID0gcmVxdWlyZShcInNwZWNpZmljaXR5XCIpO1xuY29uc3QgdGVtcG9FbGVtZW50XzEgPSByZXF1aXJlKFwiLi90ZW1wb0VsZW1lbnRcIik7XG5jb25zdCBjc3Nfc2VsZWN0b3JfcGFyc2VyXzEgPSByZXF1aXJlKFwiY3NzLXNlbGVjdG9yLXBhcnNlclwiKTtcbmNvbnN0IHNlc3Npb25TdG9yYWdlVXRpbHNfMSA9IHJlcXVpcmUoXCIuL3Nlc3Npb25TdG9yYWdlVXRpbHNcIik7XG5jb25zdCBuYXZUcmVlVXRpbHNfMSA9IHJlcXVpcmUoXCIuL25hdlRyZWVVdGlsc1wiKTtcbmV4cG9ydHMucGFyc2UgPSAoMCwgY3NzX3NlbGVjdG9yX3BhcnNlcl8xLmNyZWF0ZVBhcnNlcikoe1xuICAgIHN5bnRheDoge1xuICAgICAgICBiYXNlU3ludGF4OiAnbGF0ZXN0JyxcbiAgICAgICAgcHNldWRvQ2xhc3Nlczoge1xuICAgICAgICAgICAgdW5rbm93bjogJ2FjY2VwdCcsXG4gICAgICAgICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAgICAgICAgIFNlbGVjdG9yOiBbJ2hhcyddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcHNldWRvRWxlbWVudHM6IHtcbiAgICAgICAgICAgIHVua25vd246ICdhY2NlcHQnLFxuICAgICAgICB9LFxuICAgICAgICBjb21iaW5hdG9yczogWyc+JywgJysnLCAnfiddLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBvcGVyYXRvcnM6IFsnXj0nLCAnJD0nLCAnKj0nLCAnfj0nXSxcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lczogdHJ1ZSxcbiAgICAgICAgbmFtZXNwYWNlOiB7XG4gICAgICAgICAgICB3aWxkY2FyZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgICB3aWxkY2FyZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHN1YnN0aXR1dGVzOiB0cnVlLFxufSk7XG5jb25zdCBhZGRDU1NSdWxlID0gKHN0eWxlU2hlZXQsIHNlbGVjdG9yLCBydWxlcywgaW5kZXgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoc3R5bGVTaGVldC5pbnNlcnRSdWxlKSB7XG4gICAgICAgICAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUoYCR7c2VsZWN0b3J9IHsgJHtydWxlc30gfWAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlU2hlZXQuYWRkUnVsZShzZWxlY3RvciwgcnVsZXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgYWRkaW5nIHJ1bGU6ICcsIGUpO1xuICAgIH1cbn07XG4vKipcbiAqIFRoaXMgbWV0aG9kIGZpbHRlcnMgYW5kIHByb2Nlc3MgbWVkaWEgcXVlcnkgcnVsZXMgZm9yIHJlc3BvbnNpdmUgbW9kaWZpZXJzIHRvIGV4dHJhY3QgVGFpbHdpbmQgcmVzcG9uc2l2ZSBjbGFzc2VzLlxuICogQSBUYWlsd2luZCByZXNwb25zaXZlIG1vZGlmaWVycyB0YWtlcyB0aGUgZm9ybTpcbiAqXG4gKiAgIHtzbSxtZCxsZy4uLn06Y2xhc3NOYW1lXG4gKlxuICogd2hpY2ggaXMgcmVwcmVzZW50ZWQgYXM6XG4gKlxuICogQG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XG4gKiAgICAuc21cXDpjbGFzc05hbWUge1xuICogICAgIC4uLlxuICogICB9XG4gKiB9XG4gKlxuICogVGhpcyBpcyB3aHkgd2UgbmVlZCB0byBmaWx0ZXIgZm9yIG1lZGlhIHF1ZXJ5IHJ1bGVzIHdpdGggbWluLXdpZHRoIGFuZCB0aGVuIGV4dHJhY3QgdGhlIGNsYXNzIG5hbWUuXG4gKiBAcGFyYW0gcnVsZVxuICogQHJldHVybnNcbiAqL1xuY29uc3QgcHJvY2Vzc01lZGlhUXVlcnlSdWxlc0ZvclJlc3BvbnNpdmVNb2RpZmllcnMgPSAocnVsZSkgPT4ge1xuICAgIGxldCBydWxlcyA9IFtdO1xuICAgIGlmIChydWxlIGluc3RhbmNlb2YgQ1NTTWVkaWFSdWxlKSB7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIENTU1J1bGUgd2l0aGluIHRoZSBDU1NNZWRpYVJ1bGVcbiAgICAgICAgZm9yIChsZXQgaW5uZXJSdWxlIG9mIHJ1bGUuY3NzUnVsZXMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBtaW4td2lkdGggaW4gbWVkaWEgcXVlcmllcyBhbmQgdGhhdCBpdCBpcyBhIHN0eWxlIHJ1bGVcbiAgICAgICAgICAgIGlmIChydWxlLm1lZGlhLm1lZGlhVGV4dC5pbmNsdWRlcygnbWluLXdpZHRoJykgJiZcbiAgICAgICAgICAgICAgICBpbm5lclJ1bGUgaW5zdGFuY2VvZiBDU1NTdHlsZVJ1bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRJc1NlbGVjdG9yID0gKDAsIGV4cG9ydHMucGFyc2UpKGlubmVyUnVsZS5zZWxlY3RvclRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJc1NlbGVjdG9yLnR5cGUgIT09ICdTZWxlY3RvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSdWxlID0gcGFyc2VkSXNTZWxlY3Rvci5ydWxlc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gbGFzdFJ1bGUuaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdDbGFzc05hbWUnKS5tYXAoKGl0ZW0pID0+IGl0ZW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFRhaWx3aW5kIHJlc3BvbnNpdmUgbW9kaWZpZXJzXG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBjbGFzc05hbWVzWzBdLFxuICAgICAgICAgICAgICAgICAgICBwc2V1ZG9zOiBleHRyYWN0VGFpbHdpbmRQcmVmaXhlcyhjbGFzc05hbWVzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogaW5uZXJSdWxlLnN0eWxlLmNzc1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBpbm5lclJ1bGUuc3R5bGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVzO1xufTtcbi8qKlxuICogU2luY2UgVGFpbHdpbmQgQ1NTIHJlc3BvbnNpdmUgbW9kaWZpZXJzIGFyZSBub3QgQ1NTIHBzZXVkbyBjbGFzc2VzLCB3ZSBuZWVkIHRvIGV4dHJhY3QgdGhlbSBmcm9tIHRoZSBjbGFzcyBuYW1lLlxuICogV2UgdXNlIGEgcmVnZXggdG8gbWF0Y2ggdGhlIHJlc3BvbnNpdmUgcHJlZml4ZXMgYW5kIHJldHVybiB0aGVtIGFzIGEgc2V0LlxuICogQHBhcmFtIHNlbGVjdG9yVGV4dFxuICogQHJldHVybnMgU2V0W3ByZWZpeGVzXVxuICovXG5jb25zdCBleHRyYWN0VGFpbHdpbmRQcmVmaXhlcyA9IChzZWxlY3RvclRleHQpID0+IHtcbiAgICAvLyBUaGlzIHJlZ2V4IG1hdGNoZXMgY2xhc3NlcyB3aXRoIHJlc3BvbnNpdmUgcHJlZml4ZXMgdGhhdCBtaWdodCBiZSBwcmVjZWRlZCBieSBhIHBlcmlvZCBvciBhbm90aGVyIGNvbG9uXG4gICAgY29uc3QgcHJlZml4UmVnZXggPSAvKD86XFxifCg/PD1bOi5dKSkoc218bWR8bGd8eGx8MnhsKVxcXFw/OltcXHctXSsvZztcbiAgICBjb25zdCBtYXRjaGVzID0gc2VsZWN0b3JUZXh0Lm1hdGNoKHByZWZpeFJlZ2V4KSB8fCBbXTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IG1hdGNoZXMubWFwKChtYXRjaCkgPT4ge1xuICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgY29sb24gb3IgZXNjYXBlZCBjb2xvblxuICAgICAgICBjb25zdCBpbmRleCA9IG1hdGNoLmluZGV4T2YobWF0Y2guaW5jbHVkZXMoJ1xcXFw6JykgPyAnXFxcXDonIDogJzonKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFsuLi5uZXcgU2V0KHByZWZpeGVzKV07IC8vIFJlbW92ZSBkdXBsaWNhdGVzXG59O1xuLyoqXG4gKiBUYWlsd2luZCBDU1MgZGFyayBtb2RlIGNsYXNzZXMgKDwgMy40LjEpIGFyZSBzcGVjaWZpZWQgdXNpbmcgdGhlIGA6aXNgIHBzZXVkbyBzZWxlY3RvciBhbmQgdGFrZSB0aGUgZm9ybVxuICogICA6aXMoLmRhcmsgLmRhcms6YmctcmVkLTIwMClcbiAqIFRoaXMgaXMgdG8gc3VwcG9ydCB0aGUgYmVoYXZpb3VyIHRoYXQgZGFyayBtb2RlIGNsYXNzZXMgYXJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgd2hlbiB0aGUgZGFyayBjbGFzcyBpcyBwcmVzZW50IGluIHRoZSBwYXJlbnQuXG4gKlxuICogVE9ETzogV2Ugc2hvdWxkIHN1cHBvcnQgdGhlIG5ldyBUYWlsd2luZCBDU1MgZGFyayBtb2RlIGNsYXNzZXMgaW4gMy40LjEgYW5kIGFib3ZlIHdoaWNoIGFyZSBzcGVjaWZpZWQgdXNpbmcgdGhlIGBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKWAgbWVkaWEgcXVlcnkuXG4gKiBAcGFyYW0gaXNTZWxlY3RvclN0cmluZ1xuICogQHJldHVybnNcbiAqL1xuY29uc3QgcHJvY2Vzc0lzU2VsZWN0b3JGb3JEYXJrTW9kZSA9IChpc1NlbGVjdG9yKSA9PiB7XG4gICAgaWYgKGlzU2VsZWN0b3IudHlwZSAhPT0gJ1NlbGVjdG9yJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UnVsZSA9IGlzU2VsZWN0b3IucnVsZXNbMF07XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGZpcnN0UnVsZS5pdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ0NsYXNzTmFtZScpLm1hcCgoaXRlbSkgPT4gaXRlbS5uYW1lKTtcbiAgICBpZiAoY2xhc3NOYW1lcy5sZW5ndGggPT09IDAgfHwgY2xhc3NOYW1lc1swXSAhPT0gJ2RhcmsnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmVzdGVkUnVsZSA9IGZpcnN0UnVsZS5uZXN0ZWRSdWxlO1xuICAgIGlmICghbmVzdGVkUnVsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkYXJrTW9kZUNsYXNzZXMgPSBbXTtcbiAgICBjb25zdCBuZXN0ZWRDbGFzc05hbWVzID0gbmVzdGVkUnVsZS5pdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ0NsYXNzTmFtZScpLm1hcCgoaXRlbSkgPT4gaXRlbS5uYW1lKTtcbiAgICBpZiAobmVzdGVkQ2xhc3NOYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTa2lwcGluZyBpcyBzZWxlY3RvciB3aXRoIG11bHRpcGxlIGNsYXNzZXMnLCBmaXJzdFJ1bGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhcmtNb2RlQ2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgY2xhc3M6IG5lc3RlZENsYXNzTmFtZXNbMF0sXG4gICAgICAgIHBzZXVkb3M6IFtcbiAgICAgICAgICAgICdkYXJrJyxcbiAgICAgICAgICAgIC4uLm5lc3RlZFJ1bGUuaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdQc2V1ZG9DbGFzcycpLm1hcCgocCkgPT4gcC5uYW1lKSxcbiAgICAgICAgXSxcbiAgICB9KTtcbiAgICByZXR1cm4gZGFya01vZGVDbGFzc2VzO1xufTtcbmNvbnN0IHNldE1vZGlmaWVyc0ZvclNlbGVjdGVkRWxlbWVudCA9IChwYXJlbnRQb3J0LCBtb2RpZmllcnMsIHNlbGVjdGVkRWxlbWVudEtleSkgPT4ge1xuICAgIC8vIFJlbW92ZSBhbGwgZXhpc3RpbmcgZm9yY2UgY2xhc3NlcyBmcm9tIGVudGlyZSBkb2N1bWVudFxuICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzKj1cInRlbXBvLWZvcmNlLVwiXScpO1xuICAgIGFsbEVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IEFycmF5LmZyb20oZWxlbWVudC5jbGFzc0xpc3QpO1xuICAgICAgICBjbGFzc2VzLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgICAgICAgaWYgKGNscy5zdGFydHNXaXRoKCd0ZW1wby1mb3JjZS0nKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQuZnJvbUtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICAgIGlmIChzZWxlY3RlZEVsZW1lbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWREb21FbGVtZW50ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtzZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCl9YCkuZ2V0KDApO1xuICAgIGlmICghc2VsZWN0ZWREb21FbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW9kaWZpZXJzLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICAgIHNlbGVjdGVkRG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0ZW1wby1mb3JjZS0nICsgbW9kaWZpZXIpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuc2V0TW9kaWZpZXJzRm9yU2VsZWN0ZWRFbGVtZW50ID0gc2V0TW9kaWZpZXJzRm9yU2VsZWN0ZWRFbGVtZW50O1xuY29uc3QgcHJvY2Vzc1J1bGVzRm9yU2VsZWN0ZWRFbGVtZW50ID0gKHBhcmVudFBvcnQsIGNzc0VsZW1lbnRMb29rdXAsIHNlbGVjdGVkRWxlbWVudEtleSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgLy8gVE9ETzogdGhpcyB3aG9sZSBmdW5jdGlvbiBpcyBzbG93LCBmaXhcbiAgICBpZiAoIWNzc0VsZW1lbnRMb29rdXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQuZnJvbUtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICAgIGlmIChzZWxlY3RlZEVsZW1lbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWREb21FbGVtZW50ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtzZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCl9YCkuZ2V0KDApO1xuICAgIGNvbnN0IG11bHRpU2VsZWN0ZWRFbGVtZW50S2V5cyA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMpIHx8IFtdO1xuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3Mgbm8gc2VsZWN0ZWQgRE9NIGVsZW1lbnQgeWV0LCBpdCBpbXBsaWVzIHRoZSBuYXYgdHJlZSBpc24ndCBidWlsdCB5ZXQuXG4gICAgICogV2UgcmVnaXN0ZXIgYSBjYWxsYmFjayB0byBkZWZlciB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgcnVsZXMgdW50aWwgdGhlIG5hdiB0cmVlIGlzIGJ1aWx0LlxuICAgICAqL1xuICAgIGlmICghc2VsZWN0ZWREb21FbGVtZW50KSB7XG4gICAgICAgICgwLCBuYXZUcmVlVXRpbHNfMS5hZGROYXZUcmVlQnVpbHRDYWxsYmFjaykoe1xuICAgICAgICAgICAgY2FsbGJhY2tGbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBleHBvcnRzLnByb2Nlc3NSdWxlc0ZvclNlbGVjdGVkRWxlbWVudCkocGFyZW50UG9ydCwgY3NzRWxlbWVudExvb2t1cCwgc2VsZWN0ZWRFbGVtZW50S2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudEtleTogc2VsZWN0ZWRFbGVtZW50S2V5LFxuICAgICAgICAgICAgICAgIG11bHRpU2VsZWN0ZWRFbGVtZW50S2V5czogbXVsdGlTZWxlY3RlZEVsZW1lbnRLZXlzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3UHJvY2Vzc2VkQ3NzUnVsZXMgPSBbXTtcbiAgICBjb25zdCBleHRyYWN0ZWRLbm93bkNsYXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qga25vd25TZWxlY3RvcnMgPSBuZXcgU2V0KCk7XG4gICAgLy8gRmlyc3QgZ2V0IHRoZSBpbmxpbmUgc3R5bGUgb2YgdGhlIGVsZW1lbnRcbiAgICBjb25zdCBpbmxpbmVTdHlsZVJ1bGUgPSB7XG4gICAgICAgIGZpbGVuYW1lOiAnJyxcbiAgICAgICAgc2VsZWN0b3I6ICdlbGVtZW50LnN0eWxlJyxcbiAgICAgICAgc291cmNlOiB7fSxcbiAgICAgICAgc3R5bGVzOiB7fSxcbiAgICAgICAgYXBwbGllZDogdHJ1ZSxcbiAgICAgICAgY29kZWJhc2VJZDogJ2VsZW1lbnQuc3R5bGUnLFxuICAgICAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgICAgICBhbGxvd0NoYW5nZXM6IHRydWUsXG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8ICgoX2EgPSBzZWxlY3RlZERvbUVsZW1lbnQgPT09IG51bGwgfHwgc2VsZWN0ZWREb21FbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERvbUVsZW1lbnQuc3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHx8IDA7IGkrKykge1xuICAgICAgICBjb25zdCBjc3NOYW1lID0gc2VsZWN0ZWREb21FbGVtZW50LnN0eWxlW2ldO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlubGluZVN0eWxlUnVsZS5zdHlsZXNbY3NzTmFtZV0gPSBzZWxlY3RlZERvbUVsZW1lbnQuc3R5bGVbY3NzTmFtZV07XG4gICAgfVxuICAgIG5ld1Byb2Nlc3NlZENzc1J1bGVzLnB1c2goaW5saW5lU3R5bGVSdWxlKTtcbiAgICAvLyBPbmx5IGNoZWNrIHRoZSBpbmxpbmUtc3R5bGVzIG9mIHRoZSBwYXJlbnQgb25jZVxuICAgIGxldCBjaGVja2VkSW5saW5lU3R5bGVzT2ZQYXJlbnQgPSBmYWxzZTtcbiAgICBjb25zdCBkaXJlY3RNYXRjaENzc1J1bGVzID0gW107XG4gICAgY29uc3Qgb3RoZXJDc3NSdWxlcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNzc0VsZW1lbnRMb29rdXApLmZvckVhY2goKGNvZGViYXNlSWQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjc3NSdWxlID0gY3NzRWxlbWVudExvb2t1cFtjb2RlYmFzZUlkXTtcbiAgICAgICAga25vd25TZWxlY3RvcnMuYWRkKGNzc1J1bGUuc2VsZWN0b3IpO1xuICAgICAgICBpZiAoISgwLCBjc3NSdWxlVXRpbHNfMS5pc0Nzc1NlbGVjdG9yVmFsaWQpKGNzc1J1bGUuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGNzc1J1bGVVdGlsc18xLmdldEFsbENsYXNzZXNGcm9tU2VsZWN0b3IpKGNzc1J1bGUuc2VsZWN0b3IpLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgICAgICAgZXh0cmFjdGVkS25vd25DbGFzc2VzLmFkZChjbHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgYSBydWxlIGRpcmVjdGx5IG1hdGNoZXNcbiAgICAgICAgaWYgKCgwLCBjc3NSdWxlVXRpbHNfMS5pc0Nzc1NlbGVjdG9yVmFsaWQpKGNzc1J1bGUuc2VsZWN0b3IpICYmXG4gICAgICAgICAgICAoc2VsZWN0ZWREb21FbGVtZW50ID09PSBudWxsIHx8IHNlbGVjdGVkRG9tRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWREb21FbGVtZW50Lm1hdGNoZXMoY3NzUnVsZS5zZWxlY3RvcikpKSB7XG4gICAgICAgICAgICBkaXJlY3RNYXRjaENzc1J1bGVzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjc3NSdWxlKSwgeyBhcHBsaWVkOiB0cnVlLCBhbGxvd0NoYW5nZXM6IHRydWUsIHJlbW92YWJsZTogKDAsIGNzc1J1bGVVdGlsc18xLmNhblJlbW92ZUNzc0NsYXNzRnJvbUVsZW1lbnQpKGNzc1J1bGUuc2VsZWN0b3IsIHNlbGVjdGVkRG9tRWxlbWVudCkgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIG1ha2UgdGhlIHBhcmVudEVsZW1lbnQuc3R5bGUgc2VsZWN0b3IgdW5pcXVlXG4gICAgICAgIGxldCBwYXJlbnRFbGVtZW50SW5kZXggPSAwO1xuICAgICAgICAvLyBUaGVuIGNoZWNrIHRoZSBwYXJlbnRzIGlmIGl0J3MgYSBydWxlIHdpdGggcHJvcGVydGllcyB0aGF0IGFyZSBpbmhlcml0ZWRcbiAgICAgICAgbGV0IHBhcmVudERvbUVsZW1lbnQgPSBzZWxlY3RlZERvbUVsZW1lbnQgPT09IG51bGwgfHwgc2VsZWN0ZWREb21FbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERvbUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29uc3QgaW5oZXJpdGVkU3R5bGVzID0ge307XG4gICAgICAgIHdoaWxlIChwYXJlbnREb21FbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBJbmxpbmUgc3R5bGVzIGFyZSBwcmlvcml0aXplZCBvdmVyIHJ1bGUgYmFzZWQgc3R5bGVzXG4gICAgICAgICAgICBpZiAoIWNoZWNrZWRJbmxpbmVTdHlsZXNPZlBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubGluZVN0eWxlT2ZQYXJlbnQgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICgoX2EgPSBwYXJlbnREb21FbGVtZW50ID09PSBudWxsIHx8IHBhcmVudERvbUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudERvbUVsZW1lbnQuc3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHx8IDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjc3NOYW1lID0gcGFyZW50RG9tRWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0YW50c0FuZFR5cGVzXzEuSU5IRVJJVEFCTEVfQ1NTX1BST1BTW2Nzc05hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZU9mUGFyZW50W2Nzc05hbWVdID0gcGFyZW50RG9tRWxlbWVudC5zdHlsZVtjc3NOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoaW5saW5lU3R5bGVPZlBhcmVudCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyQ3NzUnVsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgdW5pcXVlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogYHBhcmVudEVsZW1lbnQke3BhcmVudEVsZW1lbnRJbmRleH0uc3R5bGVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogaW5saW5lU3R5bGVPZlBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlYmFzZUlkOiBgcGFyZW50RWxlbWVudCR7cGFyZW50RWxlbWVudEluZGV4fS5zdHlsZWAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDaGFuZ2VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3NzIGRlZmluZWQgc3R5bGVzXG4gICAgICAgICAgICBpZiAoKDAsIGNzc1J1bGVVdGlsc18xLmlzQ3NzU2VsZWN0b3JWYWxpZCkoY3NzUnVsZS5zZWxlY3RvcikgJiZcbiAgICAgICAgICAgICAgICAhKHBhcmVudERvbUVsZW1lbnQgPT09IG51bGwgfHwgcGFyZW50RG9tRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50RG9tRWxlbWVudC5tYXRjaGVzKGNzc1J1bGUuc2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudERvbUVsZW1lbnQgPSBwYXJlbnREb21FbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3Qua2V5cygoY3NzUnVsZSA9PT0gbnVsbCB8fCBjc3NSdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjc3NSdWxlLnN0eWxlcykgfHwge30pLmZvckVhY2goKGNzc05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQcmlvcml0aXplIGluaGVyaXRlZCBzdHlsZXMgdGhhdCBhcmUgZnVydGhlciBkb3duIHRoZSB0cmVlXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0YW50c0FuZFR5cGVzXzEuSU5IRVJJVEFCTEVfQ1NTX1BST1BTW2Nzc05hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZFN0eWxlc1tjc3NOYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmhlcml0ZWRTdHlsZXNbY3NzTmFtZV0gPSBjc3NSdWxlLnN0eWxlc1tjc3NOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmVudERvbUVsZW1lbnQgPSBwYXJlbnREb21FbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBvbmNlIGFjcm9zcyBhbGwgY3NzIHJ1bGVzXG4gICAgICAgIGNoZWNrZWRJbmxpbmVTdHlsZXNPZlBhcmVudCA9IHRydWU7XG4gICAgICAgIC8vIEp1c3QgYmVjYXVzZSBhIGNzcyBydWxlIGlzIGluaGVyaXRlZCBkb2Vzbid0IG1lYW4gaXQgY2FuJ3QgYmUgZWxpZ2libGUgdG8gYXBwbHksXG4gICAgICAgIC8vIHNvIGRvIG5vdCByZXR1cm4gYWZ0ZXIgYXBwZW5kaW5nIHRoaXMgcnVsZVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaW5oZXJpdGVkU3R5bGVzKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG90aGVyQ3NzUnVsZXMucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNzc1J1bGUpLCB7IGluaGVyaXRlZDogdHJ1ZSwgc3R5bGVzOiBpbmhlcml0ZWRTdHlsZXMsIGFwcGxpZWQ6IHRydWUsIHJlbW92YWJsZTogZmFsc2UsIGFsbG93Q2hhbmdlczogZmFsc2UgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmFsbHkgY2hlY2sgaWYgaXQncyBhIHJ1bGUgdGhhdCBjYW4gYmUgYXBwbGllZCBpZiBjbGFzZXMgYXJlIGNoYW5nZWRcbiAgICAgICAgb3RoZXJDc3NSdWxlcy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3NzUnVsZSksIHsgYXBwbGllZDogZmFsc2UsIGFsbG93Q2hhbmdlczogZmFsc2UsIGVsaWdpYmxlVG9BcHBseTogKDAsIGNzc1J1bGVVdGlsc18xLmNhbkFwcGx5Q3NzUnVsZVRvRWxlbWVudCkoY3NzUnVsZS5zZWxlY3Rvciwgc2VsZWN0ZWREb21FbGVtZW50KSB9KSk7XG4gICAgfSk7XG4gICAgY29uc3QgbWFpblN0eWxlU2hlZXQgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1swXTtcbiAgICAvLyBBZGQgYW55IHJ1bGVzIG5vdCBwcmV2aW91c2x5IGFkZGVkIHRoYXQgYXJlIGF2YWlsYWJsZSBpbiB0aGUgc3R5bGVzaGVldHMgYXMgcmVhZC1vbmx5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBzaGVldCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgICBsZXQgcnVsZXMgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVsZXMgPSBzaGVldC5jc3NSdWxlcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bGVzID0gc2hlZXQucnVsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcnVsZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1tqXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGFuZGxlIFRhaWx3aW5kIENTUyByZXNwb25zaXZlIG1vZGlmaWVyc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCByZXNwb25zaXZlTW9kaWZpZXJzID0gcHJvY2Vzc01lZGlhUXVlcnlSdWxlc0ZvclJlc3BvbnNpdmVNb2RpZmllcnMocnVsZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2l2ZU1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByZXNwb25zaXZlTW9kaWZpZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyID0gcmVzcG9uc2l2ZU1vZGlmaWVyc1trXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2VsZWN0ZWREb21FbGVtZW50ID09PSBudWxsIHx8IHNlbGVjdGVkRG9tRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWREb21FbGVtZW50Lm1hdGNoZXMoJy4nICsgQ1NTLmVzY2FwZShtb2RpZmllci5jbGFzcykpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3R5bGluZyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8ICgoX2IgPSBtb2RpZmllciA9PT0gbnVsbCB8fCBtb2RpZmllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kaWZpZXIuc3R5bGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHx8IDA7IGwgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3NzTmFtZSA9IG1vZGlmaWVyID09PSBudWxsIHx8IG1vZGlmaWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RpZmllci5zdHlsZVtsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsaW5nW2Nzc05hbWVdID0gbW9kaWZpZXIgPT09IG51bGwgfHwgbW9kaWZpZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZGlmaWVyLnN0eWxlW2Nzc05hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVUb1B1c2ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IENTUy5lc2NhcGUoJy4nICsgbW9kaWZpZXIuY2xhc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NQYXJzZWQ6IG1vZGlmaWVyLmNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLnBzZXVkb3MucmVkdWNlKChhY2MsIHBzZXVkbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1twc2V1ZG9dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIGNvZGViYXNlIElEIHRvIHVzZSBmb3Igc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGlzIElEIGlzIHNob3duIGFzIGEgYmFja3VwIGluIHRoZSBvdmVycmlkZGVuIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGViYXNlSWQ6IGAke21vZGlmaWVyLmNsYXNzfSAkeygwLCB1dWlkXzEudjQpKCkudG9TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2hhbmdlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0OiBtb2RpZmllci5jc3NUZXh0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RNYXRjaENzc1J1bGVzLnB1c2gocnVsZVRvUHVzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFydWxlLnNlbGVjdG9yVGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duU2VsZWN0b3JzLmhhcyhydWxlLnNlbGVjdG9yVGV4dCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZENzc1J1bGUgPSAoMCwgZXhwb3J0cy5wYXJzZSkocnVsZS5zZWxlY3RvclRleHQpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZENzc1J1bGUudHlwZSAhPT0gJ1NlbGVjdG9yJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlyc3RSdWxlID0gcGFyc2VkQ3NzUnVsZS5ydWxlc1swXTtcbiAgICAgICAgICAgIGlmICghZmlyc3RSdWxlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHRoZSBgOmlzYCBwc2V1ZG8gc2VsZWN0b3IsIHdoaWNoIGlzIGhvdyBUYWlsd2luZCBzcGVjaWZpZXMgZGFyayBtb2RlIGNsYXNzZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBmaXJzdFJ1bGUuaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdDbGFzc05hbWUnKS5tYXAoKGl0ZW0pID0+IGl0ZW0ubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBwc2V1ZG9zID0gZmlyc3RSdWxlLml0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnUHNldWRvQ2xhc3MnKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL3B1bGwvMTMzNzkgKH4zLjQuNClcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIHBzZXVkb3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgcHNldWRvc1swXS5uYW1lID09PSAnaXMnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHNldWRvID0gcHNldWRvc1swXTtcbiAgICAgICAgICAgICAgICBpZiAocHNldWRvICYmICgoX2MgPSBwc2V1ZG8uYXJndW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlKSA9PT0gJ1NlbGVjdG9yJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXJrTW9kZUNsYXNzZXMgPSBwcm9jZXNzSXNTZWxlY3RvckZvckRhcmtNb2RlKHBzZXVkby5hcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXJrTW9kZUNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGFya01vZGVDbGFzcyBvZiBkYXJrTW9kZUNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzZWxlY3RlZERvbUVsZW1lbnQgPT09IG51bGwgfHwgc2VsZWN0ZWREb21FbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERvbUVsZW1lbnQubWF0Y2hlcygnLicgKyBDU1MuZXNjYXBlKGRhcmtNb2RlQ2xhc3MuY2xhc3MpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxpbmcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8ICgoX2QgPSBydWxlID09PSBudWxsIHx8IHJ1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJ1bGUuc3R5bGUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpIHx8IDA7IGsgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjc3NOYW1lID0gcnVsZS5zdHlsZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGluZ1tjc3NOYW1lXSA9IHJ1bGUuc3R5bGVbY3NzTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVUb1B1c2ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBDU1MuZXNjYXBlKCcuJyArIGRhcmtNb2RlQ2xhc3MuY2xhc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc1BhcnNlZDogZGFya01vZGVDbGFzcy5jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBzdHlsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IE9iamVjdC5hc3NpZ24oe30sIGRhcmtNb2RlQ2xhc3MucHNldWRvcy5yZWR1Y2UoKGFjYywgcHNldWRvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NbcHNldWRvXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7fSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBjb2RlYmFzZSBJRCB0byB1c2UgZm9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGlzIElEIGlzIHNob3duIGFzIGEgYmFja3VwIGluIHRoZSBvdmVycmlkZGVuIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWJhc2VJZDogYCR7cnVsZS5zZWxlY3RvclRleHR9ICR7KDAsIHV1aWRfMS52NCkoKS50b1N0cmluZygpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2hhbmdlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGUuc3R5bGUuY3NzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdE1hdGNoQ3NzUnVsZXMucHVzaChydWxlVG9QdXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGFzc05hbWVzLmxlbmd0aCA9PT0gMCB8fCBjbGFzc05hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNscyA9IGNsYXNzTmFtZXNbMF07XG4gICAgICAgICAgICBjb25zdCBwc2V1ZG9DbGFzc2VzID0gZmlyc3RSdWxlLml0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnUHNldWRvQ2xhc3MnKS5tYXAoKHApID0+IHAubmFtZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZERvbUVsZW1lbnQgPT09IG51bGwgfHwgc2VsZWN0ZWREb21FbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERvbUVsZW1lbnQubWF0Y2hlcygnLicgKyBDU1MuZXNjYXBlKGNscykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxpbmcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAoKF9lID0gcnVsZSA9PT0gbnVsbCB8fCBydWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBydWxlLnN0eWxlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubGVuZ3RoKSB8fCAwOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzc05hbWUgPSBydWxlLnN0eWxlW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGluZ1tjc3NOYW1lXSA9IHJ1bGUuc3R5bGVbY3NzTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0TWF0Y2hDc3NSdWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogcnVsZS5zZWxlY3RvclRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc1BhcnNlZDogY2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IE9iamVjdC5hc3NpZ24oe30sIHBzZXVkb0NsYXNzZXMucmVkdWNlKChhY2MsIHBzZXVkbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1twc2V1ZG8ubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7fSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gY29kZWJhc2UgSUQgdG8gdXNlIGZvciBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgSUQgaXMgc2hvd24gYXMgYSBiYWNrdXAgaW4gdGhlIG92ZXJyaWRkZW4gdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWJhc2VJZDogYCR7cnVsZS5zZWxlY3RvclRleHR9ICR7KDAsIHV1aWRfMS52NCkoKS50b1N0cmluZygpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDaGFuZ2VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGUuc3R5bGUuY3NzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk5PIE1BVENIXCIsIGNscylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggZGlyZWN0IG1hdGNoIHJ1bGUsIGNoZWNrIGlmIGl0IGhhcyBtb2RpZmllcnMgYW5kIGNyZWF0ZSBhIG5ldyBydWxlIGZvciBlYWNoIG1vZGlmaWVyLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0TWF0Y2hDc3NSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50UnVsZSA9IGRpcmVjdE1hdGNoQ3NzUnVsZXNbaV07XG4gICAgICAgIGlmICghY3VycmVudFJ1bGUubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydWxlUHNldWRvcyA9IE9iamVjdC5rZXlzKGN1cnJlbnRSdWxlLm1vZGlmaWVycyk7XG4gICAgICAgIGlmIChydWxlUHNldWRvcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbHMgPSBjdXJyZW50UnVsZS5jbGFzc1BhcnNlZDtcbiAgICAgICAgaWYgKCFjbHMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNzc1RleHQgPSBjdXJyZW50UnVsZS5jc3NUZXh0O1xuICAgICAgICBpZiAoIWNzc1RleHQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjdXN0b20gY3NzIHJ1bGUgZm9yIG9uZXMgdGhhdCBoYXZlIHBzZXVkbyBzZWxlY3RvcnMuXG4gICAgICAgIC8vIFVzZSB0aGUgcGFyc2VDbGFzcyBhcyB0aGUgc2VsZWN0b3IgYW5kIGFkZCBgdGVtcG8tZm9yY2UtW3BzZXVkb11gIGZvciBlYWNoIHBzZXVkbyBzZWxlY3RvclxuICAgICAgICBjb25zdCBwc2V1ZG9TZWxlY3RvciA9IHJ1bGVQc2V1ZG9zXG4gICAgICAgICAgICAubWFwKChwc2V1ZG8pID0+ICcudGVtcG8tZm9yY2UtJyArIHBzZXVkbylcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0b3IgPSAnLicgKyBDU1MuZXNjYXBlKGNscykgKyBwc2V1ZG9TZWxlY3RvcjtcbiAgICAgICAgY29uc3QgbmV3UnVsZXMgPSBjc3NUZXh0O1xuICAgICAgICAvLyAvLyBJbmplY3QgbmV3IHJ1bGUgaW50byB0aGUgc3R5bGVzaGVldFxuICAgICAgICBhZGRDU1NSdWxlKG1haW5TdHlsZVNoZWV0LCBuZXdTZWxlY3RvciwgbmV3UnVsZXMsIG1haW5TdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0xpc3QgPSBuZXdQcm9jZXNzZWRDc3NSdWxlc1xuICAgICAgICAuY29uY2F0KGRpcmVjdE1hdGNoQ3NzUnVsZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIC0oMCwgc3BlY2lmaWNpdHlfMS5jb21wYXJlKShhLnNlbGVjdG9yLCBiLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgaW52YWxpZCBlbGVtZW50cyBhdCB0aGUgZW5kXG4gICAgICAgICAgICBsZXQgYVZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgKDAsIHNwZWNpZmljaXR5XzEuY29tcGFyZSkoYS5zZWxlY3RvciwgJ2JvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYVZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYlZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgKDAsIHNwZWNpZmljaXR5XzEuY29tcGFyZSkoYi5zZWxlY3RvciwgJ2JvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYlZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVZhbGlkICYmICFiVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFWYWxpZCAmJiBiVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSkpXG4gICAgICAgIC5jb25jYXQob3RoZXJDc3NSdWxlcyk7XG4gICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5QUk9DRVNTRURfQ1NTX1JVTEVTX0ZPUl9FTEVNRU5ULFxuICAgICAgICBwcm9jZXNzZWRDc3NSdWxlczogbmV3TGlzdCxcbiAgICB9KTtcbn07XG5leHBvcnRzLnByb2Nlc3NSdWxlc0ZvclNlbGVjdGVkRWxlbWVudCA9IHByb2Nlc3NSdWxlc0ZvclNlbGVjdGVkRWxlbWVudDtcbmNvbnN0IGNzc0V2YWwgPSAoZWxlbWVudCwgcHJvcGVydHkpID0+IHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59O1xuZXhwb3J0cy5jc3NFdmFsID0gY3NzRXZhbDtcbmNvbnN0IGdldENzc0V2YWxzID0gKHBhcmVudFBvcnQsIHNlbGVjdGVkRWxlbWVudEtleSkgPT4ge1xuICAgIGxldCBjc3NFdmFscyA9IHt9O1xuICAgIGNvbnN0IHNlbGVjdGRFbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkoc2VsZWN0ZWRFbGVtZW50S2V5KTtcbiAgICBpZiAoc2VsZWN0ZEVsZW1lbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWREb21FbGVtZW50ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtzZWxlY3RkRWxlbWVudC5nZXRLZXkoKX1gKS5nZXQoMCk7XG4gICAgaWYgKCFzZWxlY3RlZERvbUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdGFudHNBbmRUeXBlc18xLkNTU19WQUxVRVNfVE9fQ09MTEVDVC5mb3JFYWNoKChjc3NOYW1lKSA9PiB7XG4gICAgICAgIGNzc0V2YWxzW2Nzc05hbWVdID0gKDAsIGV4cG9ydHMuY3NzRXZhbCkoc2VsZWN0ZWREb21FbGVtZW50LCBjc3NOYW1lKTtcbiAgICB9KTtcbiAgICBjb25zdCBwYXJlbnRDc3NFdmFscyA9IHt9O1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBzZWxlY3RlZERvbUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBpZiAocGFyZW50RWxlbWVudCkge1xuICAgICAgICBjb25zdGFudHNBbmRUeXBlc18xLkNTU19WQUxVRVNfVE9fQ09MTEVDVF9GT1JfUEFSRU5ULmZvckVhY2goKGNzc05hbWUpID0+IHtcbiAgICAgICAgICAgIHBhcmVudENzc0V2YWxzW2Nzc05hbWVdID0gKDAsIGV4cG9ydHMuY3NzRXZhbCkoc2VsZWN0ZWREb21FbGVtZW50LnBhcmVudEVsZW1lbnQsIGNzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVXNlIGpRdWVyeSB0byBjaGVjayBpZiAnZGFyaycgY2xhc3MgaXMgaW4gYW55IGFuY2VzdG9yIG9mIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICBsZXQgZGFya0VuYWJsZWRJblBhcmVudCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7c2VsZWN0ZEVsZW1lbnQuZ2V0S2V5KCl9YCkuY2xvc2VzdCgnLmRhcmsnKVxuICAgICAgICAgICAgLmxlbmd0aCA+IDA7XG4gICAgICAgIHBhcmVudENzc0V2YWxzWydkYXJrRW5hYmxlZEluUGFyZW50J10gPSBkYXJrRW5hYmxlZEluUGFyZW50O1xuICAgIH1cbiAgICBjc3NFdmFsc1sncGFyZW50J10gPSBwYXJlbnRDc3NFdmFscztcbiAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkNTU19FVkFMU19GT1JfRUxFTUVOVCxcbiAgICAgICAgY3NzRXZhbHMsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5nZXRDc3NFdmFscyA9IGdldENzc0V2YWxzO1xuY29uc3QgZ2V0RWxlbWVudENsYXNzTGlzdCA9IChwYXJlbnRQb3J0LCBzZWxlY3RlZEVsZW1lbnRLZXkpID0+IHtcbiAgICBjb25zdCBzZWxlY3RkRWxlbWVudCA9IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5mcm9tS2V5KHNlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgaWYgKHNlbGVjdGRFbGVtZW50LmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkRG9tRWxlbWVudCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7c2VsZWN0ZEVsZW1lbnQuZ2V0S2V5KCl9YCkuZ2V0KDApO1xuICAgIGlmICghc2VsZWN0ZWREb21FbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5FTEVNRU5UX0NMQVNTX0xJU1QsXG4gICAgICAgIGNsYXNzTGlzdDogQXJyYXkuZnJvbShzZWxlY3RlZERvbUVsZW1lbnQuY2xhc3NMaXN0KSxcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldEVsZW1lbnRDbGFzc0xpc3QgPSBnZXRFbGVtZW50Q2xhc3NMaXN0O1xuY29uc3QgcnVsZU1hdGNoZXNFbGVtZW50ID0gKHBhcmVudFBvcnQsIG1lc3NhZ2VJZCwgcnVsZSwgc2VsZWN0ZWRFbGVtZW50S2V5KSA9PiB7XG4gICAgaWYgKCFydWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZEVsZW1lbnQgPSB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQuZnJvbUtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICAgIGlmIChzZWxlY3RkRWxlbWVudC5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZERvbUVsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke3NlbGVjdGRFbGVtZW50LmdldEtleSgpfWApLmdldCgwKTtcbiAgICBpZiAoIXNlbGVjdGVkRG9tRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICBtYXRjaGVzOiBzZWxlY3RlZERvbUVsZW1lbnQgPT09IG51bGwgfHwgc2VsZWN0ZWREb21FbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERvbUVsZW1lbnQubWF0Y2hlcyhydWxlKSxcbiAgICB9KTtcbn07XG5leHBvcnRzLnJ1bGVNYXRjaGVzRWxlbWVudCA9IHJ1bGVNYXRjaGVzRWxlbWVudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssFunctions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssRuleUtils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/cssRuleUtils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.camelToSnakeCase = exports.isCssSelectorValid = exports.getAllClassesFromSelector = exports.canRemoveCssClassFromElement = exports.canApplyCssRuleToElement = void 0;\nconst cssFunctions_1 = __webpack_require__(/*! ./cssFunctions */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssFunctions.js\");\nconst canApplyCssRuleToElement = (cssRule, element) => {\n    var _a;\n    try {\n        if (!element) {\n            return false;\n        }\n        if (!(0, exports.isCssSelectorValid)(cssRule)) {\n            return false;\n        }\n        if (element.matches(cssRule)) {\n            return false;\n        }\n        const parsedCssRule = (0, cssFunctions_1.parse)(cssRule);\n        let lastRule = parsedCssRule;\n        while (lastRule.nestedRule) {\n            lastRule = lastRule.nestedRule;\n        }\n        const addedClasses = [];\n        const classes = new Set(element.classList);\n        (_a = lastRule.items) === null || _a === void 0 ? void 0 : _a.forEach((item) => {\n            if (item.type === 'ClassName') {\n                const cls = item.name;\n                if (!classes.has(cls)) {\n                    element.classList.add(cls);\n                    addedClasses.push(cls);\n                }\n            }\n        });\n        const canApply = element.matches(cssRule);\n        addedClasses.forEach((cls) => {\n            element.classList.remove(cls);\n        });\n        return canApply;\n    }\n    catch (e) {\n        console.error(e);\n        return false;\n    }\n};\nexports.canApplyCssRuleToElement = canApplyCssRuleToElement;\nconst canRemoveCssClassFromElement = (cssRule, element) => {\n    var _a;\n    try {\n        if (!(0, exports.isCssSelectorValid)(cssRule)) {\n            return false;\n        }\n        if (!element.matches(cssRule)) {\n            return false;\n        }\n        const parsedCssRule = (0, cssFunctions_1.parse)(cssRule);\n        let lastRule = parsedCssRule;\n        while (lastRule.nestedRule) {\n            lastRule = lastRule.nestedRule;\n        }\n        const removedClasses = [];\n        const classes = new Set(element.classList);\n        (_a = lastRule.items) === null || _a === void 0 ? void 0 : _a.forEach((item) => {\n            if (item.type === 'ClassName') {\n                const cls = item.name;\n                if (!classes.has(cls)) {\n                    return;\n                }\n                element.classList.remove(cls);\n                removedClasses.push(cls);\n            }\n        });\n        const canRemove = !element.matches(cssRule);\n        removedClasses.forEach((cls) => {\n            element.classList.add(cls);\n        });\n        return canRemove;\n    }\n    catch (e) {\n        console.error(e);\n        return false;\n    }\n};\nexports.canRemoveCssClassFromElement = canRemoveCssClassFromElement;\nconst getAllClassesFromSelector = (cssSelector) => {\n    try {\n        if (!(0, exports.isCssSelectorValid)(cssSelector)) {\n            return new Set();\n        }\n        const parsedCssRule = (0, cssFunctions_1.parse)(cssSelector);\n        let traverseRule = parsedCssRule;\n        const allClasses = new Set();\n        while (traverseRule) {\n            const items = traverseRule.items || [];\n            items.forEach((item) => {\n                if (item.type === 'ClassName') {\n                    allClasses.add(item.name);\n                }\n            });\n            traverseRule = traverseRule.nestedRule;\n        }\n        return allClasses;\n    }\n    catch (e) {\n        console.log('Failed to parse classes from selector ' + cssSelector + ', ' + e);\n        return new Set();\n    }\n};\nexports.getAllClassesFromSelector = getAllClassesFromSelector;\nconst queryCheck = (s) => document.createDocumentFragment().querySelector(s);\nconst isCssSelectorValid = (cssSelector) => {\n    try {\n        queryCheck(cssSelector);\n        const parsedCssRule = (0, cssFunctions_1.parse)(cssSelector);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.isCssSelectorValid = isCssSelectorValid;\nconst camelToSnakeCase = (str) => {\n    if (!str)\n        return str;\n    return (str.charAt(0).toLowerCase() +\n        str.substring(1).replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`));\n};\nexports.camelToSnakeCase = camelToSnakeCase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2Nzc1J1bGVVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyxpQ0FBaUMsR0FBRyxvQ0FBb0MsR0FBRyxnQ0FBZ0M7QUFDbkssdUJBQXVCLG1CQUFPLENBQUMsaUdBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHN5YWhpXFxPbmVEcml2ZVxc2LPYt9itINin2YTZhdmD2KrYqFxcR2Fzc2ltXFxoZWFkc2hvdG1ha2VyYWlwcm9cXG5vZGVfbW9kdWxlc1xcdGVtcG8tZGV2dG9vbHNcXGRpc3RcXGNoYW5uZWxNZXNzYWdpbmdcXGNzc1J1bGVVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FtZWxUb1NuYWtlQ2FzZSA9IGV4cG9ydHMuaXNDc3NTZWxlY3RvclZhbGlkID0gZXhwb3J0cy5nZXRBbGxDbGFzc2VzRnJvbVNlbGVjdG9yID0gZXhwb3J0cy5jYW5SZW1vdmVDc3NDbGFzc0Zyb21FbGVtZW50ID0gZXhwb3J0cy5jYW5BcHBseUNzc1J1bGVUb0VsZW1lbnQgPSB2b2lkIDA7XG5jb25zdCBjc3NGdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2Nzc0Z1bmN0aW9uc1wiKTtcbmNvbnN0IGNhbkFwcGx5Q3NzUnVsZVRvRWxlbWVudCA9IChjc3NSdWxlLCBlbGVtZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGV4cG9ydHMuaXNDc3NTZWxlY3RvclZhbGlkKShjc3NSdWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lm1hdGNoZXMoY3NzUnVsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRDc3NSdWxlID0gKDAsIGNzc0Z1bmN0aW9uc18xLnBhcnNlKShjc3NSdWxlKTtcbiAgICAgICAgbGV0IGxhc3RSdWxlID0gcGFyc2VkQ3NzUnVsZTtcbiAgICAgICAgd2hpbGUgKGxhc3RSdWxlLm5lc3RlZFJ1bGUpIHtcbiAgICAgICAgICAgIGxhc3RSdWxlID0gbGFzdFJ1bGUubmVzdGVkUnVsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRlZENsYXNzZXMgPSBbXTtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IG5ldyBTZXQoZWxlbWVudC5jbGFzc0xpc3QpO1xuICAgICAgICAoX2EgPSBsYXN0UnVsZS5pdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdDbGFzc05hbWUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xzID0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICghY2xhc3Nlcy5oYXMoY2xzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYW5BcHBseSA9IGVsZW1lbnQubWF0Y2hlcyhjc3NSdWxlKTtcbiAgICAgICAgYWRkZWRDbGFzc2VzLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FuQXBwbHk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy5jYW5BcHBseUNzc1J1bGVUb0VsZW1lbnQgPSBjYW5BcHBseUNzc1J1bGVUb0VsZW1lbnQ7XG5jb25zdCBjYW5SZW1vdmVDc3NDbGFzc0Zyb21FbGVtZW50ID0gKGNzc1J1bGUsIGVsZW1lbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoMCwgZXhwb3J0cy5pc0Nzc1NlbGVjdG9yVmFsaWQpKGNzc1J1bGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbGVtZW50Lm1hdGNoZXMoY3NzUnVsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRDc3NSdWxlID0gKDAsIGNzc0Z1bmN0aW9uc18xLnBhcnNlKShjc3NSdWxlKTtcbiAgICAgICAgbGV0IGxhc3RSdWxlID0gcGFyc2VkQ3NzUnVsZTtcbiAgICAgICAgd2hpbGUgKGxhc3RSdWxlLm5lc3RlZFJ1bGUpIHtcbiAgICAgICAgICAgIGxhc3RSdWxlID0gbGFzdFJ1bGUubmVzdGVkUnVsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdmVkQ2xhc3NlcyA9IFtdO1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gbmV3IFNldChlbGVtZW50LmNsYXNzTGlzdCk7XG4gICAgICAgIChfYSA9IGxhc3RSdWxlLml0ZW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0NsYXNzTmFtZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbHMgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjbGFzc2VzLmhhcyhjbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZENsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FuUmVtb3ZlID0gIWVsZW1lbnQubWF0Y2hlcyhjc3NSdWxlKTtcbiAgICAgICAgcmVtb3ZlZENsYXNzZXMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5SZW1vdmU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy5jYW5SZW1vdmVDc3NDbGFzc0Zyb21FbGVtZW50ID0gY2FuUmVtb3ZlQ3NzQ2xhc3NGcm9tRWxlbWVudDtcbmNvbnN0IGdldEFsbENsYXNzZXNGcm9tU2VsZWN0b3IgPSAoY3NzU2VsZWN0b3IpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoISgwLCBleHBvcnRzLmlzQ3NzU2VsZWN0b3JWYWxpZCkoY3NzU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZENzc1J1bGUgPSAoMCwgY3NzRnVuY3Rpb25zXzEucGFyc2UpKGNzc1NlbGVjdG9yKTtcbiAgICAgICAgbGV0IHRyYXZlcnNlUnVsZSA9IHBhcnNlZENzc1J1bGU7XG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHdoaWxlICh0cmF2ZXJzZVJ1bGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdHJhdmVyc2VSdWxlLml0ZW1zIHx8IFtdO1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdDbGFzc05hbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbENsYXNzZXMuYWRkKGl0ZW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmF2ZXJzZVJ1bGUgPSB0cmF2ZXJzZVJ1bGUubmVzdGVkUnVsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsQ2xhc3NlcztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBwYXJzZSBjbGFzc2VzIGZyb20gc2VsZWN0b3IgJyArIGNzc1NlbGVjdG9yICsgJywgJyArIGUpO1xuICAgICAgICByZXR1cm4gbmV3IFNldCgpO1xuICAgIH1cbn07XG5leHBvcnRzLmdldEFsbENsYXNzZXNGcm9tU2VsZWN0b3IgPSBnZXRBbGxDbGFzc2VzRnJvbVNlbGVjdG9yO1xuY29uc3QgcXVlcnlDaGVjayA9IChzKSA9PiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkucXVlcnlTZWxlY3RvcihzKTtcbmNvbnN0IGlzQ3NzU2VsZWN0b3JWYWxpZCA9IChjc3NTZWxlY3RvcikgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHF1ZXJ5Q2hlY2soY3NzU2VsZWN0b3IpO1xuICAgICAgICBjb25zdCBwYXJzZWRDc3NSdWxlID0gKDAsIGNzc0Z1bmN0aW9uc18xLnBhcnNlKShjc3NTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNDc3NTZWxlY3RvclZhbGlkID0gaXNDc3NTZWxlY3RvclZhbGlkO1xuY29uc3QgY2FtZWxUb1NuYWtlQ2FzZSA9IChzdHIpID0+IHtcbiAgICBpZiAoIXN0cilcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICByZXR1cm4gKHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArXG4gICAgICAgIHN0ci5zdWJzdHJpbmcoMSkucmVwbGFjZSgvW0EtWl0vZywgKGxldHRlcikgPT4gYC0ke2xldHRlci50b0xvd2VyQ2FzZSgpfWApKTtcbn07XG5leHBvcnRzLmNhbWVsVG9TbmFrZUNhc2UgPSBjYW1lbFRvU25ha2VDYXNlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssRuleUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/editTextUtils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/editTextUtils.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.teardownEditableText = exports.setupEditableText = exports.getEditingInfo = exports.currentlyEditing = exports.hasTextContents = exports.canEditText = void 0;\nconst identifierUtils_1 = __webpack_require__(/*! ./identifierUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js\");\nconst sessionStorageUtils_1 = __webpack_require__(/*! ./sessionStorageUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js\");\nconst constantsAndTypes_1 = __webpack_require__(/*! ./constantsAndTypes */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/constantsAndTypes.js\");\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\"));\n/**\n * Evaluates if the element's text can be edited in place.\n *\n * @param element\n */\nconst canEditText = (element) => {\n    const treeElements = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP) || {};\n    const treeElement = treeElements[element.codebaseId];\n    if (!treeElement) {\n        return false;\n    }\n    return treeElement.staticTextContents;\n};\nexports.canEditText = canEditText;\n/**\n * Returns if the node has text contents in the DOM\n */\nconst hasTextContents = (node) => {\n    if (!node) {\n        return false;\n    }\n    let hasText = false;\n    let hasNonText = false;\n    node.childNodes.forEach((child) => {\n        if (child.nodeType === Node.TEXT_NODE) {\n            hasText = true;\n            return;\n        }\n        hasNonText = true;\n    });\n    return hasText && !hasNonText;\n};\nexports.hasTextContents = hasTextContents;\nconst currentlyEditing = () => {\n    const item = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.TEXT_EDIT);\n    return item !== null && item !== undefined;\n};\nexports.currentlyEditing = currentlyEditing;\nconst markAsEditing = (info) => {\n    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.TEXT_EDIT, info);\n};\nconst getEditingInfo = () => {\n    return (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.TEXT_EDIT);\n};\nexports.getEditingInfo = getEditingInfo;\nconst clearEditingInfo = () => {\n    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.TEXT_EDIT, null);\n};\n/**\n * Takes an element and registers it as an editable text element.\n * Mutates the DOM to make the element editable.\n */\nconst setupEditableText = (element, parentPort, storyboardId) => {\n    const classToSearchFor = `.${identifierUtils_1.ELEMENT_KEY_PREFIX}${element.getKey()}`;\n    const domElement = (0, jquery_1.default)(classToSearchFor).get(0);\n    if (!domElement) {\n        return;\n    }\n    const originalText = (0, jquery_1.default)(domElement).text();\n    markAsEditing({\n        key: element.getKey(),\n        originalText,\n    });\n    parentPort.postMessage({\n        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.START_EDITING_TEXT,\n        data: {\n            key: element.getKey(),\n            oldText: originalText,\n        },\n    });\n    (0, jquery_1.default)(domElement).attr('contenteditable', 'plaintext-only').trigger('focus');\n    // Apply styling directly\n    (0, jquery_1.default)(domElement).css({\n        cursor: 'text',\n        outline: 'none',\n        border: 'none',\n    });\n    (0, jquery_1.default)(domElement).on('blur', () => (0, exports.teardownEditableText)(parentPort, storyboardId));\n};\nexports.setupEditableText = setupEditableText;\n/**\n * Used to mark the completion of the editable text process.\n * Reverts the DOM to its original state.\n * Sends a message to the housing frame with updated text, if necessary.\n *\n */\nconst teardownEditableText = (parentPort, storyboardId) => {\n    var _a;\n    const editingInfo = (0, exports.getEditingInfo)();\n    if (!(0, exports.currentlyEditing)()) {\n        return;\n    }\n    clearEditingInfo();\n    if (!editingInfo) {\n        return;\n    }\n    const classToSearchFor = `.${identifierUtils_1.ELEMENT_KEY_PREFIX}${editingInfo.key}`;\n    const domElement = (0, jquery_1.default)(classToSearchFor).get(0);\n    if (!domElement) {\n        return;\n    }\n    const updatedText = (0, jquery_1.default)(domElement).text();\n    parentPort.postMessage({\n        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.EDITED_TEXT,\n        data: {\n            key: editingInfo.key,\n            newText: updatedText,\n            oldText: editingInfo.originalText,\n        },\n    });\n    // Clear any selection\n    (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    // Cleanup\n    (0, jquery_1.default)(domElement).removeAttr('contenteditable').off('blur').css({\n        cursor: '',\n        outline: '',\n        border: '',\n    });\n    clearEditingInfo();\n};\nexports.teardownEditableText = teardownEditableText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2VkaXRUZXh0VXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxtQkFBbUI7QUFDNUosMEJBQTBCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ3JELDhCQUE4QixtQkFBTyxDQUFDLCtHQUF1QjtBQUM3RCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBcUI7QUFDekQsaUNBQWlDLG1CQUFPLENBQUMsMERBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUNBQXFDLEVBQUUsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUNBQXFDLEVBQUUsZ0JBQWdCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3lhaGlcXE9uZURyaXZlXFzYs9i32K0g2KfZhNmF2YPYqtioXFxHYXNzaW1cXGhlYWRzaG90bWFrZXJhaXByb1xcbm9kZV9tb2R1bGVzXFx0ZW1wby1kZXZ0b29sc1xcZGlzdFxcY2hhbm5lbE1lc3NhZ2luZ1xcZWRpdFRleHRVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGVhcmRvd25FZGl0YWJsZVRleHQgPSBleHBvcnRzLnNldHVwRWRpdGFibGVUZXh0ID0gZXhwb3J0cy5nZXRFZGl0aW5nSW5mbyA9IGV4cG9ydHMuY3VycmVudGx5RWRpdGluZyA9IGV4cG9ydHMuaGFzVGV4dENvbnRlbnRzID0gZXhwb3J0cy5jYW5FZGl0VGV4dCA9IHZvaWQgMDtcbmNvbnN0IGlkZW50aWZpZXJVdGlsc18xID0gcmVxdWlyZShcIi4vaWRlbnRpZmllclV0aWxzXCIpO1xuY29uc3Qgc2Vzc2lvblN0b3JhZ2VVdGlsc18xID0gcmVxdWlyZShcIi4vc2Vzc2lvblN0b3JhZ2VVdGlsc1wiKTtcbmNvbnN0IGNvbnN0YW50c0FuZFR5cGVzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNBbmRUeXBlc1wiKTtcbmNvbnN0IGpxdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuLyoqXG4gKiBFdmFsdWF0ZXMgaWYgdGhlIGVsZW1lbnQncyB0ZXh0IGNhbiBiZSBlZGl0ZWQgaW4gcGxhY2UuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRcbiAqL1xuY29uc3QgY2FuRWRpdFRleHQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHRyZWVFbGVtZW50cyA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5UUkVFX0VMRU1FTlRfTE9PS1VQKSB8fCB7fTtcbiAgICBjb25zdCB0cmVlRWxlbWVudCA9IHRyZWVFbGVtZW50c1tlbGVtZW50LmNvZGViYXNlSWRdO1xuICAgIGlmICghdHJlZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZUVsZW1lbnQuc3RhdGljVGV4dENvbnRlbnRzO1xufTtcbmV4cG9ydHMuY2FuRWRpdFRleHQgPSBjYW5FZGl0VGV4dDtcbi8qKlxuICogUmV0dXJucyBpZiB0aGUgbm9kZSBoYXMgdGV4dCBjb250ZW50cyBpbiB0aGUgRE9NXG4gKi9cbmNvbnN0IGhhc1RleHRDb250ZW50cyA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGhhc1RleHQgPSBmYWxzZTtcbiAgICBsZXQgaGFzTm9uVGV4dCA9IGZhbHNlO1xuICAgIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICBoYXNUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYXNOb25UZXh0ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGFzVGV4dCAmJiAhaGFzTm9uVGV4dDtcbn07XG5leHBvcnRzLmhhc1RleHRDb250ZW50cyA9IGhhc1RleHRDb250ZW50cztcbmNvbnN0IGN1cnJlbnRseUVkaXRpbmcgPSAoKSA9PiB7XG4gICAgY29uc3QgaXRlbSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5URVhUX0VESVQpO1xuICAgIHJldHVybiBpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmN1cnJlbnRseUVkaXRpbmcgPSBjdXJyZW50bHlFZGl0aW5nO1xuY29uc3QgbWFya0FzRWRpdGluZyA9IChpbmZvKSA9PiB7XG4gICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlRFWFRfRURJVCwgaW5mbyk7XG59O1xuY29uc3QgZ2V0RWRpdGluZ0luZm8gPSAoKSA9PiB7XG4gICAgcmV0dXJuICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5URVhUX0VESVQpO1xufTtcbmV4cG9ydHMuZ2V0RWRpdGluZ0luZm8gPSBnZXRFZGl0aW5nSW5mbztcbmNvbnN0IGNsZWFyRWRpdGluZ0luZm8gPSAoKSA9PiB7XG4gICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlRFWFRfRURJVCwgbnVsbCk7XG59O1xuLyoqXG4gKiBUYWtlcyBhbiBlbGVtZW50IGFuZCByZWdpc3RlcnMgaXQgYXMgYW4gZWRpdGFibGUgdGV4dCBlbGVtZW50LlxuICogTXV0YXRlcyB0aGUgRE9NIHRvIG1ha2UgdGhlIGVsZW1lbnQgZWRpdGFibGUuXG4gKi9cbmNvbnN0IHNldHVwRWRpdGFibGVUZXh0ID0gKGVsZW1lbnQsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgIGNvbnN0IGNsYXNzVG9TZWFyY2hGb3IgPSBgLiR7aWRlbnRpZmllclV0aWxzXzEuRUxFTUVOVF9LRVlfUFJFRklYfSR7ZWxlbWVudC5nZXRLZXkoKX1gO1xuICAgIGNvbnN0IGRvbUVsZW1lbnQgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoY2xhc3NUb1NlYXJjaEZvcikuZ2V0KDApO1xuICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsVGV4dCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShkb21FbGVtZW50KS50ZXh0KCk7XG4gICAgbWFya0FzRWRpdGluZyh7XG4gICAgICAgIGtleTogZWxlbWVudC5nZXRLZXkoKSxcbiAgICAgICAgb3JpZ2luYWxUZXh0LFxuICAgIH0pO1xuICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogY29uc3RhbnRzQW5kVHlwZXNfMS5GSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU1RBUlRfRURJVElOR19URVhULFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBrZXk6IGVsZW1lbnQuZ2V0S2V5KCksXG4gICAgICAgICAgICBvbGRUZXh0OiBvcmlnaW5hbFRleHQsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGRvbUVsZW1lbnQpLmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScsICdwbGFpbnRleHQtb25seScpLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgLy8gQXBwbHkgc3R5bGluZyBkaXJlY3RseVxuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShkb21FbGVtZW50KS5jc3Moe1xuICAgICAgICBjdXJzb3I6ICd0ZXh0JyxcbiAgICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICB9KTtcbiAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoZG9tRWxlbWVudCkub24oJ2JsdXInLCAoKSA9PiAoMCwgZXhwb3J0cy50ZWFyZG93bkVkaXRhYmxlVGV4dCkocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKSk7XG59O1xuZXhwb3J0cy5zZXR1cEVkaXRhYmxlVGV4dCA9IHNldHVwRWRpdGFibGVUZXh0O1xuLyoqXG4gKiBVc2VkIHRvIG1hcmsgdGhlIGNvbXBsZXRpb24gb2YgdGhlIGVkaXRhYmxlIHRleHQgcHJvY2Vzcy5cbiAqIFJldmVydHMgdGhlIERPTSB0byBpdHMgb3JpZ2luYWwgc3RhdGUuXG4gKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIGhvdXNpbmcgZnJhbWUgd2l0aCB1cGRhdGVkIHRleHQsIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKi9cbmNvbnN0IHRlYXJkb3duRWRpdGFibGVUZXh0ID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBlZGl0aW5nSW5mbyA9ICgwLCBleHBvcnRzLmdldEVkaXRpbmdJbmZvKSgpO1xuICAgIGlmICghKDAsIGV4cG9ydHMuY3VycmVudGx5RWRpdGluZykoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyRWRpdGluZ0luZm8oKTtcbiAgICBpZiAoIWVkaXRpbmdJbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xhc3NUb1NlYXJjaEZvciA9IGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtlZGl0aW5nSW5mby5rZXl9YDtcbiAgICBjb25zdCBkb21FbGVtZW50ID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGNsYXNzVG9TZWFyY2hGb3IpLmdldCgwKTtcbiAgICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkVGV4dCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KShkb21FbGVtZW50KS50ZXh0KCk7XG4gICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBjb25zdGFudHNBbmRUeXBlc18xLkZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5FRElURURfVEVYVCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAga2V5OiBlZGl0aW5nSW5mby5rZXksXG4gICAgICAgICAgICBuZXdUZXh0OiB1cGRhdGVkVGV4dCxcbiAgICAgICAgICAgIG9sZFRleHQ6IGVkaXRpbmdJbmZvLm9yaWdpbmFsVGV4dCxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBDbGVhciBhbnkgc2VsZWN0aW9uXG4gICAgKF9hID0gd2luZG93LmdldFNlbGVjdGlvbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgLy8gQ2xlYW51cFxuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShkb21FbGVtZW50KS5yZW1vdmVBdHRyKCdjb250ZW50ZWRpdGFibGUnKS5vZmYoJ2JsdXInKS5jc3Moe1xuICAgICAgICBjdXJzb3I6ICcnLFxuICAgICAgICBvdXRsaW5lOiAnJyxcbiAgICAgICAgYm9yZGVyOiAnJyxcbiAgICB9KTtcbiAgICBjbGVhckVkaXRpbmdJbmZvKCk7XG59O1xuZXhwb3J0cy50ZWFyZG93bkVkaXRhYmxlVGV4dCA9IHRlYXJkb3duRWRpdGFibGVUZXh0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/editTextUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isElementInSvg = exports.isSkipNavTreeNode = exports.isMovingElement = exports.getAllUnknownClasses = exports.getAllUnknownClasesFromList = exports.isOutline = exports.hasClass = exports.removeUniqueLookupFromNode = exports.getUniqueLookupFromNode = exports.getElementKeyFromNode = exports.addCodebaseIdToNode = exports.addUniqueLookupAsClass = exports.addElementKeyAsClass = exports.getCodebaseIdFromNode = exports.getCodebaseIdFromClassName = exports.validateUuid = exports.KNOWN_ATTRIBUTES = exports.TEMPO_QUEUE_DELETE_AFTER_HOT_RELOAD = exports.TEMPO_TEST_ID = exports.TEMPO_ELEMENT_ID = exports.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH = exports.TEMPO_OUTLINE_UNTIL_REFESH = exports.TEMPO_DELETE_AFTER_REFRESH = exports.TEMPO_INSTANT_UPDATE = exports.TEMPO_DELETE_AFTER_INSTANT_UPDATE = exports.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS = exports.TEMPO_INSTANT_UPDATE_STYLING_PREFIX = exports.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE = exports.TEMPO_INSTANT_DIV_DRAW_CLASS = exports.EDIT_TEXT_BUTTON = exports.OUTLINE_CLASS = exports.UNIQUE_LOOKUP_PREFIX = exports.ELEMENT_KEY_PREFIX = void 0;\nconst changeItemFunctions_1 = __webpack_require__(/*! ./changeItemFunctions */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/changeItemFunctions.js\");\n// Must match identifier utils on the frontend\nexports.ELEMENT_KEY_PREFIX = 'arb89-key-';\nexports.UNIQUE_LOOKUP_PREFIX = 'arb89-lookup-'; // Used only for processing the nav tree\nexports.OUTLINE_CLASS = 'arb89-outline';\nexports.EDIT_TEXT_BUTTON = 'arb89-edit-text-button';\nexports.TEMPO_INSTANT_DIV_DRAW_CLASS = 'arb89-instant-div-draw';\nexports.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE = 'arb89-move-between-parents-outline';\nexports.TEMPO_INSTANT_UPDATE_STYLING_PREFIX = 'arb89-styling-';\nexports.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS = 'arb89-display-none-until-refresh';\nexports.TEMPO_DELETE_AFTER_INSTANT_UPDATE = 'arb89-delete-after-instant-update';\nconst KNOWN_CLASSES = new Set([\n    exports.OUTLINE_CLASS,\n    exports.TEMPO_INSTANT_DIV_DRAW_CLASS,\n    exports.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE,\n    exports.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS,\n    changeItemFunctions_1.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID,\n    changeItemFunctions_1.TEMPORARY_STYLING_CLASS_NAME,\n    exports.EDIT_TEXT_BUTTON,\n]);\nconst KNOWN_CLASS_PREFIXES = [\n    exports.ELEMENT_KEY_PREFIX,\n    exports.UNIQUE_LOOKUP_PREFIX,\n    exports.TEMPO_INSTANT_UPDATE_STYLING_PREFIX,\n    changeItemFunctions_1.DUPLICATE_PLACEHOLDER_PREFIX,\n    changeItemFunctions_1.ADD_JSX_PREFIX,\n];\n// Attributes that are set until the next Nav Tree Refresh\nexports.TEMPO_INSTANT_UPDATE = 'arb89-instant-update';\nexports.TEMPO_DELETE_AFTER_REFRESH = 'arb89-delete-after-refresh';\nexports.TEMPO_OUTLINE_UNTIL_REFESH = 'arb89-outline-until-refresh';\nexports.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH = 'arb89-do-not-show-in-nav';\nexports.TEMPO_ELEMENT_ID = 'tempoelementid';\nexports.TEMPO_TEST_ID = 'data-testid';\nexports.TEMPO_QUEUE_DELETE_AFTER_HOT_RELOAD = 'arb89-queue-delete-after-hot-reload';\nexports.KNOWN_ATTRIBUTES = new Set([\n    exports.TEMPO_INSTANT_UPDATE,\n    exports.TEMPO_DELETE_AFTER_REFRESH,\n    exports.TEMPO_DELETE_AFTER_INSTANT_UPDATE,\n    exports.TEMPO_OUTLINE_UNTIL_REFESH,\n    exports.TEMPO_QUEUE_DELETE_AFTER_HOT_RELOAD,\n    exports.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH,\n    exports.TEMPO_ELEMENT_ID,\n    exports.TEMPO_TEST_ID,\n]);\nconst validateUuid = (uuid) => {\n    return new RegExp('^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$', 'i').test(uuid);\n};\nexports.validateUuid = validateUuid;\nconst getCodebaseIdFromClassName = (className) => {\n    if (className &&\n        className.startsWith('tempo-') &&\n        ((0, exports.validateUuid)(className.substring('tempo-'.length)) ||\n            className === changeItemFunctions_1.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID ||\n            className.startsWith(changeItemFunctions_1.DUPLICATE_PLACEHOLDER_PREFIX))) {\n        return className;\n    }\n    return null;\n};\nexports.getCodebaseIdFromClassName = getCodebaseIdFromClassName;\nconst getCodebaseIdFromNode = (node) => {\n    var _a;\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return null;\n    }\n    let clsFound = null;\n    node.classList.forEach((cls) => {\n        // A bit of a hack -> in the case when there are multiple tempo codebase IDs on an element\n        // we want to use the first one defined. This happens in the case of forward refs, and we\n        // always add the bottom-most className to the end of the classes list, so we want to\n        // show the top-most element in this case\n        if (clsFound) {\n            return;\n        }\n        if (!cls) {\n            return;\n        }\n        const extractedId = (0, exports.getCodebaseIdFromClassName)(cls);\n        if (extractedId) {\n            clsFound = extractedId;\n        }\n    });\n    if (clsFound) {\n        return clsFound;\n    }\n    if (((_a = node === null || node === void 0 ? void 0 : node.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) == 'body') {\n        return 'body';\n    }\n    if ((node === null || node === void 0 ? void 0 : node.id) == 'root') {\n        return 'root';\n    }\n    if ((node === null || node === void 0 ? void 0 : node.id) == '__next') {\n        return '__next';\n    }\n    return null;\n};\nexports.getCodebaseIdFromNode = getCodebaseIdFromNode;\nconst addElementKeyAsClass = (node, safeElementKey) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return;\n    }\n    const classesToRemove = new Set();\n    node.classList.forEach((cls) => {\n        if (cls === null || cls === void 0 ? void 0 : cls.startsWith(exports.ELEMENT_KEY_PREFIX)) {\n            classesToRemove.add(cls);\n        }\n    });\n    classesToRemove.forEach((cls) => {\n        node.classList.remove(cls);\n    });\n    node.classList.add(`${exports.ELEMENT_KEY_PREFIX}${safeElementKey}`);\n};\nexports.addElementKeyAsClass = addElementKeyAsClass;\nconst addUniqueLookupAsClass = (node, uniqueLookup) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return;\n    }\n    const classesToRemove = new Set();\n    node.classList.forEach((cls) => {\n        if (cls === null || cls === void 0 ? void 0 : cls.startsWith(exports.UNIQUE_LOOKUP_PREFIX)) {\n            classesToRemove.add(cls);\n        }\n    });\n    classesToRemove.forEach((cls) => {\n        node.classList.remove(cls);\n    });\n    node.classList.add(`${exports.UNIQUE_LOOKUP_PREFIX}${uniqueLookup}`);\n};\nexports.addUniqueLookupAsClass = addUniqueLookupAsClass;\nconst addCodebaseIdToNode = (node, codebaseId) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return;\n    }\n    const classesToRemove = new Set();\n    node.classList.forEach((cls) => {\n        if (!cls) {\n            return;\n        }\n        if ((0, exports.getCodebaseIdFromClassName)(cls)) {\n            classesToRemove.add(cls);\n        }\n    });\n    classesToRemove.forEach((cls) => {\n        node.classList.remove(cls);\n    });\n    node.classList.add(codebaseId);\n};\nexports.addCodebaseIdToNode = addCodebaseIdToNode;\nconst getElementKeyFromNode = (node) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return null;\n    }\n    let clsFound = null;\n    node.classList.forEach((cls) => {\n        if (cls === null || cls === void 0 ? void 0 : cls.startsWith(exports.ELEMENT_KEY_PREFIX)) {\n            clsFound = cls.substring(exports.ELEMENT_KEY_PREFIX.length);\n        }\n    });\n    return clsFound;\n};\nexports.getElementKeyFromNode = getElementKeyFromNode;\nconst getUniqueLookupFromNode = (node) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return null;\n    }\n    let clsFound = null;\n    node.classList.forEach((cls) => {\n        if (cls === null || cls === void 0 ? void 0 : cls.startsWith(exports.UNIQUE_LOOKUP_PREFIX)) {\n            clsFound = cls.substring(exports.UNIQUE_LOOKUP_PREFIX.length);\n        }\n    });\n    return clsFound;\n};\nexports.getUniqueLookupFromNode = getUniqueLookupFromNode;\nconst removeUniqueLookupFromNode = (node) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return false;\n    }\n    const classesToRemove = new Set();\n    node.classList.forEach((cls) => {\n        if (cls === null || cls === void 0 ? void 0 : cls.startsWith(exports.UNIQUE_LOOKUP_PREFIX)) {\n            classesToRemove.add(cls);\n        }\n    });\n    classesToRemove.forEach((cls) => {\n        node.classList.remove(cls);\n    });\n    return classesToRemove.size > 0;\n};\nexports.removeUniqueLookupFromNode = removeUniqueLookupFromNode;\nconst hasClass = (node, klass) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return false;\n    }\n    let hasClass = false;\n    node.classList.forEach((cls) => {\n        if (cls == klass) {\n            hasClass = true;\n        }\n    });\n    return hasClass;\n};\nexports.hasClass = hasClass;\nconst isOutline = (node) => {\n    return (0, exports.hasClass)(node, exports.OUTLINE_CLASS);\n};\nexports.isOutline = isOutline;\nconst getAllUnknownClasesFromList = (classes) => {\n    return classes.filter((cls) => {\n        if (!cls) {\n            return false;\n        }\n        const isCodebaseId = (0, exports.getCodebaseIdFromClassName)(cls) !== null;\n        const clsStartsWithKnownPrefix = KNOWN_CLASS_PREFIXES.some((prefix) => cls.startsWith(prefix));\n        if (!clsStartsWithKnownPrefix && !KNOWN_CLASSES.has(cls) && !isCodebaseId) {\n            return true;\n        }\n        return false;\n    });\n};\nexports.getAllUnknownClasesFromList = getAllUnknownClasesFromList;\nconst getAllUnknownClasses = (node) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return [];\n    }\n    return (0, exports.getAllUnknownClasesFromList)(Array.from(node.classList));\n};\nexports.getAllUnknownClasses = getAllUnknownClasses;\n/**\n * Accepts a node from mutation observer and determines if it's a moving element.\n * Returns moving if and only if the node has the attribute `arb89-instant-update` set to true.\n * @param node\n * @returns\n */\nconst isMovingElement = (node) => {\n    if (!node) {\n        return false;\n    }\n    // Check if the node responds to getAttribute method.\n    if (typeof node.getAttribute !== 'function') {\n        return false;\n    }\n    return node.getAttribute(exports.TEMPO_INSTANT_UPDATE) === 'true';\n};\nexports.isMovingElement = isMovingElement;\nconst isSkipNavTreeNode = (node) => {\n    if (!node) {\n        return;\n    }\n    return node.getAttribute(exports.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH) === 'true';\n};\nexports.isSkipNavTreeNode = isSkipNavTreeNode;\n/**\n * Check if the node has any parent that is an svg tag\n */\nconst isElementInSvg = (node, parent) => {\n    var _a;\n    if (!node) {\n        return false;\n    }\n    if (parent && ((_a = node.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'svg') {\n        return true;\n    }\n    if (node.parentNode) {\n        return (0, exports.isElementInSvg)(node.parentNode, true);\n    }\n    return false;\n};\nexports.isElementInSvg = isElementInSvg;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2lkZW50aWZpZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUIsR0FBRyw0QkFBNEIsR0FBRyxtQ0FBbUMsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyw2QkFBNkIsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyw0QkFBNEIsR0FBRyw2QkFBNkIsR0FBRyxrQ0FBa0MsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRywyQ0FBMkMsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyw4Q0FBOEMsR0FBRyxrQ0FBa0MsR0FBRyxrQ0FBa0MsR0FBRyw0QkFBNEIsR0FBRyx5Q0FBeUMsR0FBRyw4Q0FBOEMsR0FBRywyQ0FBMkMsR0FBRywwQ0FBMEMsR0FBRyxvQ0FBb0MsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyw0QkFBNEIsR0FBRywwQkFBMEI7QUFDN2pDLDhCQUE4QixtQkFBTyxDQUFDLCtHQUF1QjtBQUM3RDtBQUNBLDBCQUEwQjtBQUMxQiw0QkFBNEIsb0JBQW9CO0FBQ2hELHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsb0NBQW9DO0FBQ3BDLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0MsOENBQThDO0FBQzlDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsOENBQThDO0FBQzlDLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsMkNBQTJDO0FBQzNDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHO0FBQy9GO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQiwyQkFBMkIsRUFBRSxlQUFlO0FBQ3RFO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQiw2QkFBNkIsRUFBRSxhQUFhO0FBQ3RFO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHN5YWhpXFxPbmVEcml2ZVxc2LPYt9itINin2YTZhdmD2KrYqFxcR2Fzc2ltXFxoZWFkc2hvdG1ha2VyYWlwcm9cXG5vZGVfbW9kdWxlc1xcdGVtcG8tZGV2dG9vbHNcXGRpc3RcXGNoYW5uZWxNZXNzYWdpbmdcXGlkZW50aWZpZXJVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNFbGVtZW50SW5TdmcgPSBleHBvcnRzLmlzU2tpcE5hdlRyZWVOb2RlID0gZXhwb3J0cy5pc01vdmluZ0VsZW1lbnQgPSBleHBvcnRzLmdldEFsbFVua25vd25DbGFzc2VzID0gZXhwb3J0cy5nZXRBbGxVbmtub3duQ2xhc2VzRnJvbUxpc3QgPSBleHBvcnRzLmlzT3V0bGluZSA9IGV4cG9ydHMuaGFzQ2xhc3MgPSBleHBvcnRzLnJlbW92ZVVuaXF1ZUxvb2t1cEZyb21Ob2RlID0gZXhwb3J0cy5nZXRVbmlxdWVMb29rdXBGcm9tTm9kZSA9IGV4cG9ydHMuZ2V0RWxlbWVudEtleUZyb21Ob2RlID0gZXhwb3J0cy5hZGRDb2RlYmFzZUlkVG9Ob2RlID0gZXhwb3J0cy5hZGRVbmlxdWVMb29rdXBBc0NsYXNzID0gZXhwb3J0cy5hZGRFbGVtZW50S2V5QXNDbGFzcyA9IGV4cG9ydHMuZ2V0Q29kZWJhc2VJZEZyb21Ob2RlID0gZXhwb3J0cy5nZXRDb2RlYmFzZUlkRnJvbUNsYXNzTmFtZSA9IGV4cG9ydHMudmFsaWRhdGVVdWlkID0gZXhwb3J0cy5LTk9XTl9BVFRSSUJVVEVTID0gZXhwb3J0cy5URU1QT19RVUVVRV9ERUxFVEVfQUZURVJfSE9UX1JFTE9BRCA9IGV4cG9ydHMuVEVNUE9fVEVTVF9JRCA9IGV4cG9ydHMuVEVNUE9fRUxFTUVOVF9JRCA9IGV4cG9ydHMuVEVNUE9fRE9fTk9UX1NIT1dfSU5fTkFWX1VOVElMX1JFRlJFU0ggPSBleHBvcnRzLlRFTVBPX09VVExJTkVfVU5USUxfUkVGRVNIID0gZXhwb3J0cy5URU1QT19ERUxFVEVfQUZURVJfUkVGUkVTSCA9IGV4cG9ydHMuVEVNUE9fSU5TVEFOVF9VUERBVEUgPSBleHBvcnRzLlRFTVBPX0RFTEVURV9BRlRFUl9JTlNUQU5UX1VQREFURSA9IGV4cG9ydHMuVEVNUE9fRElTUExBWV9OT05FX1VOVElMX1JFRlJFU0hfQ0xBU1MgPSBleHBvcnRzLlRFTVBPX0lOU1RBTlRfVVBEQVRFX1NUWUxJTkdfUFJFRklYID0gZXhwb3J0cy5URU1QT19NT1ZFX0JFVFdFRU5fUEFSRU5UU19PVVRMSU5FID0gZXhwb3J0cy5URU1QT19JTlNUQU5UX0RJVl9EUkFXX0NMQVNTID0gZXhwb3J0cy5FRElUX1RFWFRfQlVUVE9OID0gZXhwb3J0cy5PVVRMSU5FX0NMQVNTID0gZXhwb3J0cy5VTklRVUVfTE9PS1VQX1BSRUZJWCA9IGV4cG9ydHMuRUxFTUVOVF9LRVlfUFJFRklYID0gdm9pZCAwO1xuY29uc3QgY2hhbmdlSXRlbUZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4vY2hhbmdlSXRlbUZ1bmN0aW9uc1wiKTtcbi8vIE11c3QgbWF0Y2ggaWRlbnRpZmllciB1dGlscyBvbiB0aGUgZnJvbnRlbmRcbmV4cG9ydHMuRUxFTUVOVF9LRVlfUFJFRklYID0gJ2FyYjg5LWtleS0nO1xuZXhwb3J0cy5VTklRVUVfTE9PS1VQX1BSRUZJWCA9ICdhcmI4OS1sb29rdXAtJzsgLy8gVXNlZCBvbmx5IGZvciBwcm9jZXNzaW5nIHRoZSBuYXYgdHJlZVxuZXhwb3J0cy5PVVRMSU5FX0NMQVNTID0gJ2FyYjg5LW91dGxpbmUnO1xuZXhwb3J0cy5FRElUX1RFWFRfQlVUVE9OID0gJ2FyYjg5LWVkaXQtdGV4dC1idXR0b24nO1xuZXhwb3J0cy5URU1QT19JTlNUQU5UX0RJVl9EUkFXX0NMQVNTID0gJ2FyYjg5LWluc3RhbnQtZGl2LWRyYXcnO1xuZXhwb3J0cy5URU1QT19NT1ZFX0JFVFdFRU5fUEFSRU5UU19PVVRMSU5FID0gJ2FyYjg5LW1vdmUtYmV0d2Vlbi1wYXJlbnRzLW91dGxpbmUnO1xuZXhwb3J0cy5URU1QT19JTlNUQU5UX1VQREFURV9TVFlMSU5HX1BSRUZJWCA9ICdhcmI4OS1zdHlsaW5nLSc7XG5leHBvcnRzLlRFTVBPX0RJU1BMQVlfTk9ORV9VTlRJTF9SRUZSRVNIX0NMQVNTID0gJ2FyYjg5LWRpc3BsYXktbm9uZS11bnRpbC1yZWZyZXNoJztcbmV4cG9ydHMuVEVNUE9fREVMRVRFX0FGVEVSX0lOU1RBTlRfVVBEQVRFID0gJ2FyYjg5LWRlbGV0ZS1hZnRlci1pbnN0YW50LXVwZGF0ZSc7XG5jb25zdCBLTk9XTl9DTEFTU0VTID0gbmV3IFNldChbXG4gICAgZXhwb3J0cy5PVVRMSU5FX0NMQVNTLFxuICAgIGV4cG9ydHMuVEVNUE9fSU5TVEFOVF9ESVZfRFJBV19DTEFTUyxcbiAgICBleHBvcnRzLlRFTVBPX01PVkVfQkVUV0VFTl9QQVJFTlRTX09VVExJTkUsXG4gICAgZXhwb3J0cy5URU1QT19ESVNQTEFZX05PTkVfVU5USUxfUkVGUkVTSF9DTEFTUyxcbiAgICBjaGFuZ2VJdGVtRnVuY3Rpb25zXzEuV1JBUF9JTl9ESVZfUExBQ0VIT0xERVJfQ09ERUJBU0VfSUQsXG4gICAgY2hhbmdlSXRlbUZ1bmN0aW9uc18xLlRFTVBPUkFSWV9TVFlMSU5HX0NMQVNTX05BTUUsXG4gICAgZXhwb3J0cy5FRElUX1RFWFRfQlVUVE9OLFxuXSk7XG5jb25zdCBLTk9XTl9DTEFTU19QUkVGSVhFUyA9IFtcbiAgICBleHBvcnRzLkVMRU1FTlRfS0VZX1BSRUZJWCxcbiAgICBleHBvcnRzLlVOSVFVRV9MT09LVVBfUFJFRklYLFxuICAgIGV4cG9ydHMuVEVNUE9fSU5TVEFOVF9VUERBVEVfU1RZTElOR19QUkVGSVgsXG4gICAgY2hhbmdlSXRlbUZ1bmN0aW9uc18xLkRVUExJQ0FURV9QTEFDRUhPTERFUl9QUkVGSVgsXG4gICAgY2hhbmdlSXRlbUZ1bmN0aW9uc18xLkFERF9KU1hfUFJFRklYLFxuXTtcbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmUgc2V0IHVudGlsIHRoZSBuZXh0IE5hdiBUcmVlIFJlZnJlc2hcbmV4cG9ydHMuVEVNUE9fSU5TVEFOVF9VUERBVEUgPSAnYXJiODktaW5zdGFudC11cGRhdGUnO1xuZXhwb3J0cy5URU1QT19ERUxFVEVfQUZURVJfUkVGUkVTSCA9ICdhcmI4OS1kZWxldGUtYWZ0ZXItcmVmcmVzaCc7XG5leHBvcnRzLlRFTVBPX09VVExJTkVfVU5USUxfUkVGRVNIID0gJ2FyYjg5LW91dGxpbmUtdW50aWwtcmVmcmVzaCc7XG5leHBvcnRzLlRFTVBPX0RPX05PVF9TSE9XX0lOX05BVl9VTlRJTF9SRUZSRVNIID0gJ2FyYjg5LWRvLW5vdC1zaG93LWluLW5hdic7XG5leHBvcnRzLlRFTVBPX0VMRU1FTlRfSUQgPSAndGVtcG9lbGVtZW50aWQnO1xuZXhwb3J0cy5URU1QT19URVNUX0lEID0gJ2RhdGEtdGVzdGlkJztcbmV4cG9ydHMuVEVNUE9fUVVFVUVfREVMRVRFX0FGVEVSX0hPVF9SRUxPQUQgPSAnYXJiODktcXVldWUtZGVsZXRlLWFmdGVyLWhvdC1yZWxvYWQnO1xuZXhwb3J0cy5LTk9XTl9BVFRSSUJVVEVTID0gbmV3IFNldChbXG4gICAgZXhwb3J0cy5URU1QT19JTlNUQU5UX1VQREFURSxcbiAgICBleHBvcnRzLlRFTVBPX0RFTEVURV9BRlRFUl9SRUZSRVNILFxuICAgIGV4cG9ydHMuVEVNUE9fREVMRVRFX0FGVEVSX0lOU1RBTlRfVVBEQVRFLFxuICAgIGV4cG9ydHMuVEVNUE9fT1VUTElORV9VTlRJTF9SRUZFU0gsXG4gICAgZXhwb3J0cy5URU1QT19RVUVVRV9ERUxFVEVfQUZURVJfSE9UX1JFTE9BRCxcbiAgICBleHBvcnRzLlRFTVBPX0RPX05PVF9TSE9XX0lOX05BVl9VTlRJTF9SRUZSRVNILFxuICAgIGV4cG9ydHMuVEVNUE9fRUxFTUVOVF9JRCxcbiAgICBleHBvcnRzLlRFTVBPX1RFU1RfSUQsXG5dKTtcbmNvbnN0IHZhbGlkYXRlVXVpZCA9ICh1dWlkKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQnLCAnaScpLnRlc3QodXVpZCk7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVV1aWQgPSB2YWxpZGF0ZVV1aWQ7XG5jb25zdCBnZXRDb2RlYmFzZUlkRnJvbUNsYXNzTmFtZSA9IChjbGFzc05hbWUpID0+IHtcbiAgICBpZiAoY2xhc3NOYW1lICYmXG4gICAgICAgIGNsYXNzTmFtZS5zdGFydHNXaXRoKCd0ZW1wby0nKSAmJlxuICAgICAgICAoKDAsIGV4cG9ydHMudmFsaWRhdGVVdWlkKShjbGFzc05hbWUuc3Vic3RyaW5nKCd0ZW1wby0nLmxlbmd0aCkpIHx8XG4gICAgICAgICAgICBjbGFzc05hbWUgPT09IGNoYW5nZUl0ZW1GdW5jdGlvbnNfMS5XUkFQX0lOX0RJVl9QTEFDRUhPTERFUl9DT0RFQkFTRV9JRCB8fFxuICAgICAgICAgICAgY2xhc3NOYW1lLnN0YXJ0c1dpdGgoY2hhbmdlSXRlbUZ1bmN0aW9uc18xLkRVUExJQ0FURV9QTEFDRUhPTERFUl9QUkVGSVgpKSkge1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLmdldENvZGViYXNlSWRGcm9tQ2xhc3NOYW1lID0gZ2V0Q29kZWJhc2VJZEZyb21DbGFzc05hbWU7XG5jb25zdCBnZXRDb2RlYmFzZUlkRnJvbU5vZGUgPSAobm9kZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIShub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuY2xhc3NMaXN0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IGNsc0ZvdW5kID0gbnVsbDtcbiAgICBub2RlLmNsYXNzTGlzdC5mb3JFYWNoKChjbHMpID0+IHtcbiAgICAgICAgLy8gQSBiaXQgb2YgYSBoYWNrIC0+IGluIHRoZSBjYXNlIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHRlbXBvIGNvZGViYXNlIElEcyBvbiBhbiBlbGVtZW50XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gdXNlIHRoZSBmaXJzdCBvbmUgZGVmaW5lZC4gVGhpcyBoYXBwZW5zIGluIHRoZSBjYXNlIG9mIGZvcndhcmQgcmVmcywgYW5kIHdlXG4gICAgICAgIC8vIGFsd2F5cyBhZGQgdGhlIGJvdHRvbS1tb3N0IGNsYXNzTmFtZSB0byB0aGUgZW5kIG9mIHRoZSBjbGFzc2VzIGxpc3QsIHNvIHdlIHdhbnQgdG9cbiAgICAgICAgLy8gc2hvdyB0aGUgdG9wLW1vc3QgZWxlbWVudCBpbiB0aGlzIGNhc2VcbiAgICAgICAgaWYgKGNsc0ZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRyYWN0ZWRJZCA9ICgwLCBleHBvcnRzLmdldENvZGViYXNlSWRGcm9tQ2xhc3NOYW1lKShjbHMpO1xuICAgICAgICBpZiAoZXh0cmFjdGVkSWQpIHtcbiAgICAgICAgICAgIGNsc0ZvdW5kID0gZXh0cmFjdGVkSWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY2xzRm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGNsc0ZvdW5kO1xuICAgIH1cbiAgICBpZiAoKChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50YWdOYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT0gJ2JvZHknKSB7XG4gICAgICAgIHJldHVybiAnYm9keSc7XG4gICAgfVxuICAgIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmlkKSA9PSAncm9vdCcpIHtcbiAgICAgICAgcmV0dXJuICdyb290JztcbiAgICB9XG4gICAgaWYgKChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuaWQpID09ICdfX25leHQnKSB7XG4gICAgICAgIHJldHVybiAnX19uZXh0JztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0cy5nZXRDb2RlYmFzZUlkRnJvbU5vZGUgPSBnZXRDb2RlYmFzZUlkRnJvbU5vZGU7XG5jb25zdCBhZGRFbGVtZW50S2V5QXNDbGFzcyA9IChub2RlLCBzYWZlRWxlbWVudEtleSkgPT4ge1xuICAgIGlmICghKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5jbGFzc0xpc3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIG5vZGUuY2xhc3NMaXN0LmZvckVhY2goKGNscykgPT4ge1xuICAgICAgICBpZiAoY2xzID09PSBudWxsIHx8IGNscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xzLnN0YXJ0c1dpdGgoZXhwb3J0cy5FTEVNRU5UX0tFWV9QUkVGSVgpKSB7XG4gICAgICAgICAgICBjbGFzc2VzVG9SZW1vdmUuYWRkKGNscyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjbGFzc2VzVG9SZW1vdmUuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH0pO1xuICAgIG5vZGUuY2xhc3NMaXN0LmFkZChgJHtleHBvcnRzLkVMRU1FTlRfS0VZX1BSRUZJWH0ke3NhZmVFbGVtZW50S2V5fWApO1xufTtcbmV4cG9ydHMuYWRkRWxlbWVudEtleUFzQ2xhc3MgPSBhZGRFbGVtZW50S2V5QXNDbGFzcztcbmNvbnN0IGFkZFVuaXF1ZUxvb2t1cEFzQ2xhc3MgPSAobm9kZSwgdW5pcXVlTG9va3VwKSA9PiB7XG4gICAgaWYgKCEobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgbm9kZS5jbGFzc0xpc3QuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgIGlmIChjbHMgPT09IG51bGwgfHwgY2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbHMuc3RhcnRzV2l0aChleHBvcnRzLlVOSVFVRV9MT09LVVBfUFJFRklYKSkge1xuICAgICAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLmFkZChjbHMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2xhc3Nlc1RvUmVtb3ZlLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9KTtcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoYCR7ZXhwb3J0cy5VTklRVUVfTE9PS1VQX1BSRUZJWH0ke3VuaXF1ZUxvb2t1cH1gKTtcbn07XG5leHBvcnRzLmFkZFVuaXF1ZUxvb2t1cEFzQ2xhc3MgPSBhZGRVbmlxdWVMb29rdXBBc0NsYXNzO1xuY29uc3QgYWRkQ29kZWJhc2VJZFRvTm9kZSA9IChub2RlLCBjb2RlYmFzZUlkKSA9PiB7XG4gICAgaWYgKCEobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgbm9kZS5jbGFzc0xpc3QuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgIGlmICghY2xzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBleHBvcnRzLmdldENvZGViYXNlSWRGcm9tQ2xhc3NOYW1lKShjbHMpKSB7XG4gICAgICAgICAgICBjbGFzc2VzVG9SZW1vdmUuYWRkKGNscyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjbGFzc2VzVG9SZW1vdmUuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH0pO1xuICAgIG5vZGUuY2xhc3NMaXN0LmFkZChjb2RlYmFzZUlkKTtcbn07XG5leHBvcnRzLmFkZENvZGViYXNlSWRUb05vZGUgPSBhZGRDb2RlYmFzZUlkVG9Ob2RlO1xuY29uc3QgZ2V0RWxlbWVudEtleUZyb21Ob2RlID0gKG5vZGUpID0+IHtcbiAgICBpZiAoIShub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuY2xhc3NMaXN0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IGNsc0ZvdW5kID0gbnVsbDtcbiAgICBub2RlLmNsYXNzTGlzdC5mb3JFYWNoKChjbHMpID0+IHtcbiAgICAgICAgaWYgKGNscyA9PT0gbnVsbCB8fCBjbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNscy5zdGFydHNXaXRoKGV4cG9ydHMuRUxFTUVOVF9LRVlfUFJFRklYKSkge1xuICAgICAgICAgICAgY2xzRm91bmQgPSBjbHMuc3Vic3RyaW5nKGV4cG9ydHMuRUxFTUVOVF9LRVlfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xzRm91bmQ7XG59O1xuZXhwb3J0cy5nZXRFbGVtZW50S2V5RnJvbU5vZGUgPSBnZXRFbGVtZW50S2V5RnJvbU5vZGU7XG5jb25zdCBnZXRVbmlxdWVMb29rdXBGcm9tTm9kZSA9IChub2RlKSA9PiB7XG4gICAgaWYgKCEobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBjbHNGb3VuZCA9IG51bGw7XG4gICAgbm9kZS5jbGFzc0xpc3QuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgIGlmIChjbHMgPT09IG51bGwgfHwgY2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbHMuc3RhcnRzV2l0aChleHBvcnRzLlVOSVFVRV9MT09LVVBfUFJFRklYKSkge1xuICAgICAgICAgICAgY2xzRm91bmQgPSBjbHMuc3Vic3RyaW5nKGV4cG9ydHMuVU5JUVVFX0xPT0tVUF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbHNGb3VuZDtcbn07XG5leHBvcnRzLmdldFVuaXF1ZUxvb2t1cEZyb21Ob2RlID0gZ2V0VW5pcXVlTG9va3VwRnJvbU5vZGU7XG5jb25zdCByZW1vdmVVbmlxdWVMb29rdXBGcm9tTm9kZSA9IChub2RlKSA9PiB7XG4gICAgaWYgKCEobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgbm9kZS5jbGFzc0xpc3QuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgIGlmIChjbHMgPT09IG51bGwgfHwgY2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbHMuc3RhcnRzV2l0aChleHBvcnRzLlVOSVFVRV9MT09LVVBfUFJFRklYKSkge1xuICAgICAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLmFkZChjbHMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2xhc3Nlc1RvUmVtb3ZlLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2xhc3Nlc1RvUmVtb3ZlLnNpemUgPiAwO1xufTtcbmV4cG9ydHMucmVtb3ZlVW5pcXVlTG9va3VwRnJvbU5vZGUgPSByZW1vdmVVbmlxdWVMb29rdXBGcm9tTm9kZTtcbmNvbnN0IGhhc0NsYXNzID0gKG5vZGUsIGtsYXNzKSA9PiB7XG4gICAgaWYgKCEobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaGFzQ2xhc3MgPSBmYWxzZTtcbiAgICBub2RlLmNsYXNzTGlzdC5mb3JFYWNoKChjbHMpID0+IHtcbiAgICAgICAgaWYgKGNscyA9PSBrbGFzcykge1xuICAgICAgICAgICAgaGFzQ2xhc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhc0NsYXNzO1xufTtcbmV4cG9ydHMuaGFzQ2xhc3MgPSBoYXNDbGFzcztcbmNvbnN0IGlzT3V0bGluZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmhhc0NsYXNzKShub2RlLCBleHBvcnRzLk9VVExJTkVfQ0xBU1MpO1xufTtcbmV4cG9ydHMuaXNPdXRsaW5lID0gaXNPdXRsaW5lO1xuY29uc3QgZ2V0QWxsVW5rbm93bkNsYXNlc0Zyb21MaXN0ID0gKGNsYXNzZXMpID0+IHtcbiAgICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoKGNscykgPT4ge1xuICAgICAgICBpZiAoIWNscykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQ29kZWJhc2VJZCA9ICgwLCBleHBvcnRzLmdldENvZGViYXNlSWRGcm9tQ2xhc3NOYW1lKShjbHMpICE9PSBudWxsO1xuICAgICAgICBjb25zdCBjbHNTdGFydHNXaXRoS25vd25QcmVmaXggPSBLTk9XTl9DTEFTU19QUkVGSVhFUy5zb21lKChwcmVmaXgpID0+IGNscy5zdGFydHNXaXRoKHByZWZpeCkpO1xuICAgICAgICBpZiAoIWNsc1N0YXJ0c1dpdGhLbm93blByZWZpeCAmJiAhS05PV05fQ0xBU1NFUy5oYXMoY2xzKSAmJiAhaXNDb2RlYmFzZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5nZXRBbGxVbmtub3duQ2xhc2VzRnJvbUxpc3QgPSBnZXRBbGxVbmtub3duQ2xhc2VzRnJvbUxpc3Q7XG5jb25zdCBnZXRBbGxVbmtub3duQ2xhc3NlcyA9IChub2RlKSA9PiB7XG4gICAgaWYgKCEobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZ2V0QWxsVW5rbm93bkNsYXNlc0Zyb21MaXN0KShBcnJheS5mcm9tKG5vZGUuY2xhc3NMaXN0KSk7XG59O1xuZXhwb3J0cy5nZXRBbGxVbmtub3duQ2xhc3NlcyA9IGdldEFsbFVua25vd25DbGFzc2VzO1xuLyoqXG4gKiBBY2NlcHRzIGEgbm9kZSBmcm9tIG11dGF0aW9uIG9ic2VydmVyIGFuZCBkZXRlcm1pbmVzIGlmIGl0J3MgYSBtb3ZpbmcgZWxlbWVudC5cbiAqIFJldHVybnMgbW92aW5nIGlmIGFuZCBvbmx5IGlmIHRoZSBub2RlIGhhcyB0aGUgYXR0cmlidXRlIGBhcmI4OS1pbnN0YW50LXVwZGF0ZWAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnNcbiAqL1xuY29uc3QgaXNNb3ZpbmdFbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSByZXNwb25kcyB0byBnZXRBdHRyaWJ1dGUgbWV0aG9kLlxuICAgIGlmICh0eXBlb2Ygbm9kZS5nZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoZXhwb3J0cy5URU1QT19JTlNUQU5UX1VQREFURSkgPT09ICd0cnVlJztcbn07XG5leHBvcnRzLmlzTW92aW5nRWxlbWVudCA9IGlzTW92aW5nRWxlbWVudDtcbmNvbnN0IGlzU2tpcE5hdlRyZWVOb2RlID0gKG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoZXhwb3J0cy5URU1QT19ET19OT1RfU0hPV19JTl9OQVZfVU5USUxfUkVGUkVTSCkgPT09ICd0cnVlJztcbn07XG5leHBvcnRzLmlzU2tpcE5hdlRyZWVOb2RlID0gaXNTa2lwTmF2VHJlZU5vZGU7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBub2RlIGhhcyBhbnkgcGFyZW50IHRoYXQgaXMgYW4gc3ZnIHRhZ1xuICovXG5jb25zdCBpc0VsZW1lbnRJblN2ZyA9IChub2RlLCBwYXJlbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudCAmJiAoKF9hID0gbm9kZS50YWdOYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09ICdzdmcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc0VsZW1lbnRJblN2Zykobm9kZS5wYXJlbnROb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydHMuaXNFbGVtZW50SW5TdmcgPSBpc0VsZW1lbnRJblN2ZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initChannelMessaging = void 0;\n// KEEP THIS IN SYNC WITH sessionStorageUtils.*.tsx\nconst resqUtils_1 = __webpack_require__(/*! ./resqUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/resqUtils.js\");\nconst lz_string_1 = __importDefault(__webpack_require__(/*! lz-string */ \"(ssr)/./node_modules/lz-string/libs/lz-string.js\"));\nconst posthog_js_1 = __importDefault(__webpack_require__(/*! ../posthog.js */ \"(ssr)/./node_modules/tempo-devtools/dist/posthog.js\"));\nconst channelMessagingFunctions_1 = __webpack_require__(/*! ./channelMessagingFunctions */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/channelMessagingFunctions.js\");\n// For vite only, show errors in the browser\nif (typeof window !== 'undefined' &&\n    window.location.href.includes('framework=VITE')) {\n    const showErrorOverlay = (err) => {\n        // must be within function call because that's when the element is defined for sure.\n        const ErrorOverlay = customElements.get('vite-error-overlay');\n        // don't open outside vite environment\n        if (!ErrorOverlay) {\n            return;\n        }\n        const overlay = new ErrorOverlay(err);\n        document.body.appendChild(overlay);\n    };\n    window.addEventListener('error', showErrorOverlay);\n    window.addEventListener('unhandledrejection', ({ reason }) => showErrorOverlay(reason));\n}\nconst debugLogInDev = (...str) => {\n    var _a;\n    // Only in dev\n    if ((_a = window.location.search) === null || _a === void 0 ? void 0 : _a.includes('debugLog=true')) {\n        console.debug(...str);\n    }\n};\nfunction initChannelMessaging() {\n    var _a;\n    if (typeof window !== 'undefined') {\n        (0, channelMessagingFunctions_1.initChannelMessagingFunctions)();\n        // Only in prod\n        if (window.location.hostname.endsWith('dev.tempolabs.ai') &&\n            !window.location.hostname.endsWith('staging-dev.tempolabs.ai')) {\n            if (posthog_js_1.default) {\n                posthog_js_1.default.init();\n            }\n        }\n    }\n    if (typeof window !== 'undefined') {\n        window.addEventListener('message', (event) => {\n            const { data } = event;\n            if (data.type === 'GET_STATE_AND_PROPS') {\n                const { componentName } = data;\n                // TODO: Support custom root that user provides\n                let rootSelector = '#root';\n                if (!document.querySelector(rootSelector)) {\n                    rootSelector = '#__next';\n                }\n                const root = document.querySelector(rootSelector);\n                const rootReactElement = (0, resqUtils_1.getRootReactElement)();\n                const tree = (0, resqUtils_1.buildNodeTree)(rootReactElement, null);\n                const foundNodes = (0, resqUtils_1.findElementInTree)(tree, (node) => {\n                    if (componentName && node.name == componentName) {\n                        return true;\n                    }\n                    return false;\n                });\n                if (!(foundNodes === null || foundNodes === void 0 ? void 0 : foundNodes.length)) {\n                    const message = {\n                        error: 'No component found',\n                    };\n                    console.log('STATE_AND_PROPS ', JSON.stringify(message));\n                    return;\n                }\n                if (foundNodes.length > 1) {\n                    console.log(foundNodes);\n                    console.log('Warning: more than 1 component found');\n                }\n                const foundNode = foundNodes[0];\n                const sendDataForNode = (node) => {\n                    debugLogInDev('NODE FOUND: ', node);\n                    const PROPS_TO_EXCLUDE = {\n                        tempoelementid: true,\n                        'data-testid': true,\n                    };\n                    const propsToSend = {};\n                    if (node.props) {\n                        Object.keys(node.props).forEach((key) => {\n                            if (!PROPS_TO_EXCLUDE[key]) {\n                                if (typeof node.props[key] === 'object') {\n                                    propsToSend[key] = 'TEMPO_OBJECT_TYPE';\n                                }\n                                else if (typeof node.props[key] === 'function') {\n                                    propsToSend[key] = 'TEMPO_FUNCTION_TYPE';\n                                }\n                                else {\n                                    propsToSend[key] = node.props[key];\n                                }\n                            }\n                        });\n                    }\n                    // TODO: This doesn't fully work because of this bug: https://github.com/baruchvlz/resq/issues/85\n                    let stateToSend = {};\n                    if (node.state) {\n                        if (typeof node.state === 'string') {\n                            stateToSend = {\n                                state: node.state,\n                            };\n                        }\n                        else {\n                            Object.keys(node.state).forEach((key) => {\n                                if (typeof node.state[key] === 'object') {\n                                    stateToSend[key] = 'TEMPO_OBJECT_TYPE';\n                                }\n                                else if (typeof node.state[key] === 'function') {\n                                    stateToSend[key] = 'TEMPO_FUNCTION_TYPE';\n                                }\n                                else {\n                                    stateToSend[key] = node.state[key];\n                                }\n                            });\n                        }\n                    }\n                    const message = {\n                        id: data.id,\n                        props: propsToSend,\n                        state: stateToSend,\n                    };\n                    console.log('STATE_AND_PROPS ', JSON.stringify(message));\n                };\n                sendDataForNode(foundNode);\n            }\n        });\n    }\n    if (typeof window !== 'undefined') {\n        if ((_a = window.location.search) === null || _a === void 0 ? void 0 : _a.includes('storyboard=true')) {\n            let rootEl = document.getElementById('root');\n            if (!rootEl) {\n                rootEl = document.getElementById('__next');\n            }\n            if (rootEl) {\n                if (window.location.search.includes('type=STORY') ||\n                    window.location.search.includes('type=COMPONENT')) {\n                    [rootEl, document.body, document.documentElement].forEach((el) => {\n                        el.style.backgroundColor = 'transparent';\n                        el.style.width = '100vw';\n                        el.style.height = '100vh';\n                        el.style.overflow = 'hidden';\n                    });\n                }\n                else {\n                    rootEl.style.width = '100vw';\n                    rootEl.style.height = '100vh';\n                }\n            }\n        }\n        (function () {\n            let port2 = null;\n            let storyboardId = null;\n            // Setup the transfered port\n            const initPort = (e) => {\n                if (e.data === 'init') {\n                    port2 = e.ports[0];\n                    port2.onmessage = onMessage;\n                }\n                else {\n                    var msgObj = e.data;\n                    onMessage({\n                        data: msgObj,\n                    });\n                }\n            };\n            // Listen for the intial port transfer message\n            window.addEventListener('message', initPort);\n            const onInspectElement = (data) => __awaiter(this, void 0, void 0, function* () {\n                if (!data.payload.componentName) {\n                    console.log('NO COMPONENT NAME');\n                    const message = {\n                        id: data.id,\n                        error: 'No component name',\n                    };\n                    port2.postMessage(message);\n                    return;\n                }\n                // TODO: Support custom root that user provides\n                const rootReactElement = (0, resqUtils_1.getRootReactElement)();\n                const tree = (0, resqUtils_1.buildNodeTree)(rootReactElement, null);\n                const { isComponent, componentName, tempoElementID, componentElementId, } = data.payload;\n                if (!isComponent && !tempoElementID) {\n                    console.log('No tempo element ID provided');\n                    const message = {\n                        id: data.id,\n                        error: 'Could not find element',\n                    };\n                    port2.postMessage(message);\n                    return;\n                }\n                if (isComponent && !tempoElementID && !componentName) {\n                    console.log('No tempo element ID or component name provided');\n                    const message = {\n                        id: data.id,\n                        error: 'Could not find component',\n                    };\n                    port2.postMessage(message);\n                    return;\n                }\n                const foundNodes = (0, resqUtils_1.findElementInTree)(tree, (node) => {\n                    var _a, _b, _c, _d, _e, _f;\n                    if (isComponent) {\n                        // Check tempoElementID, and if it's not provided, use the component name\n                        if (tempoElementID &&\n                            (((_a = node.props) === null || _a === void 0 ? void 0 : _a.tempoelementid) == tempoElementID ||\n                                ((_b = node.props) === null || _b === void 0 ? void 0 : _b['data-testid']) == tempoElementID)) {\n                            return true;\n                        }\n                        if (!tempoElementID &&\n                            componentName &&\n                            node.name == componentName) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // The tempo element ID must always match\n                        if (tempoElementID &&\n                            ((_c = node.props) === null || _c === void 0 ? void 0 : _c.tempoelementid) !== tempoElementID &&\n                            ((_d = node.props) === null || _d === void 0 ? void 0 : _d['data-testid']) !== tempoElementID) {\n                            return false;\n                        }\n                        // If the component instance ID is provided, go up the chain to check if there are any parents with this component instance ID set\n                        if (componentElementId) {\n                            let nodeToCheck = node.parent;\n                            let foundMatchingComponent = false;\n                            while (nodeToCheck) {\n                                if (((_e = nodeToCheck.props) === null || _e === void 0 ? void 0 : _e.tempoelementid) === componentElementId ||\n                                    ((_f = nodeToCheck.props) === null || _f === void 0 ? void 0 : _f['data-testid']) === componentElementId) {\n                                    foundMatchingComponent = true;\n                                    break;\n                                }\n                                nodeToCheck = nodeToCheck.parent;\n                            }\n                            if (!foundMatchingComponent) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                    return false;\n                });\n                if (!(foundNodes === null || foundNodes === void 0 ? void 0 : foundNodes.length)) {\n                    debugLogInDev('NO COMPONENT FOUND');\n                    const message = {\n                        id: data.id,\n                        error: 'No component found',\n                    };\n                    port2.postMessage(message);\n                    return;\n                }\n                if (foundNodes.length > 1) {\n                    console.log(foundNodes);\n                    console.log('Warning: more than 1 component found');\n                }\n                const foundNode = foundNodes[0];\n                const sendDataForNode = (node) => {\n                    debugLogInDev('NODE FOUND: ', node);\n                    const propsToSend = {};\n                    if (node.props) {\n                        Object.keys(node.props).forEach((key) => {\n                            if (typeof node.props[key] === 'object') {\n                                propsToSend[key] = 'TEMPO_OBJECT_TYPE';\n                            }\n                            else if (typeof node.props[key] === 'function') {\n                                propsToSend[key] = 'TEMPO_FUNCTION_TYPE';\n                            }\n                            else {\n                                propsToSend[key] = node.props[key];\n                            }\n                        });\n                    }\n                    // TODO: This doesn't fully work because of this bug: https://github.com/baruchvlz/resq/issues/85\n                    let stateToSend = {};\n                    if (node.state) {\n                        if (typeof node.state === 'string') {\n                            stateToSend = {\n                                state: node.state,\n                            };\n                        }\n                        else {\n                            Object.keys(node.state).forEach((key) => {\n                                if (typeof node.state[key] === 'object') {\n                                    stateToSend[key] = 'TEMPO_OBJECT_TYPE';\n                                }\n                                else if (typeof node.state[key] === 'function') {\n                                    stateToSend[key] = 'TEMPO_FUNCTION_TYPE';\n                                }\n                                else {\n                                    stateToSend[key] = node.state[key];\n                                }\n                            });\n                        }\n                    }\n                    const message = {\n                        id: data.id,\n                        props: propsToSend,\n                        state: stateToSend,\n                    };\n                    debugLogInDev('RESPONDING WITH: ', message);\n                    port2.postMessage(message);\n                };\n                sendDataForNode(foundNode);\n            });\n            // Handle messages received on port2\n            const onMessage = (e) => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                try {\n                    const data = e.data;\n                    const dataToLog = Object.assign({}, data);\n                    if ((_a = data === null || data === void 0 ? void 0 : data.payload) === null || _a === void 0 ? void 0 : _a.compressedArgs) {\n                        dataToLog.payload = Object.assign(Object.assign({}, data.payload), { compressedArgs: 'COMPRESSED' });\n                    }\n                    // These contain args that are too large to log\n                    const LOGS_TO_SKIP_ARGS = [\n                        'initProject',\n                        'setNewLookups',\n                        'processRulesForSelectedElement',\n                    ];\n                    if (((_b = data === null || data === void 0 ? void 0 : data.payload) === null || _b === void 0 ? void 0 : _b.functionName) &&\n                        LOGS_TO_SKIP_ARGS.includes(data.payload.functionName)) {\n                        dataToLog.payload = Object.assign(Object.assign({}, data.payload), { args: 'ARGS_SKIPPED' });\n                    }\n                    debugLogInDev('INNER FRAME: Received message from parent: ', JSON.stringify(dataToLog));\n                    if (!data || !data.payload) {\n                        debugLogInDev('NO PAYLOAD');\n                        return;\n                    }\n                    if (!data.id) {\n                        debugLogInDev('NO ID');\n                        return;\n                    }\n                    if (data.type === 'inspectElement') {\n                        onInspectElement(data);\n                    }\n                    else if (data.type === 'executeFunction') {\n                        const fn = window[data.payload.functionName];\n                        if (typeof fn === 'function') {\n                            // Special case to register the storyboardId\n                            let args = data.payload.args;\n                            if (data.payload.compressedArgs) {\n                                args = JSON.parse(lz_string_1.default.decompress(data.payload.compressedArgs));\n                            }\n                            if (data.payload.functionName === 'initProject') {\n                                storyboardId = args[0];\n                                args = args.slice(1);\n                            }\n                            let res = null;\n                            if (data.payload.args) {\n                                // @ts-ignore\n                                res = fn(port2, storyboardId, ...args);\n                            }\n                            else {\n                                // @ts-ignore\n                                res = fn(port2, storyboardId);\n                            }\n                            if (res) {\n                                port2.postMessage({\n                                    id: data.id,\n                                    result: res,\n                                });\n                            }\n                        }\n                        else {\n                            console.log('INNER FRAME ERROR: Function to execute not found');\n                        }\n                    }\n                }\n                catch (error) {\n                    console.log('INNER FRAME ERROR: ', error);\n                    // TODO: Send error back to parent?\n                }\n            });\n        })();\n    }\n}\nexports.initChannelMessaging = initChannelMessaging;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDJGQUFhO0FBQ3pDLG9DQUFvQyxtQkFBTyxDQUFDLG1FQUFXO0FBQ3ZELHFDQUFxQyxtQkFBTyxDQUFDLDBFQUFlO0FBQzVELG9DQUFvQyxtQkFBTyxDQUFDLDJIQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0U7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLDBFQUEwRSxtQkFBbUIsOEJBQThCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxtQkFBbUIsc0JBQXNCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHRlbXBvLWRldnRvb2xzXFxkaXN0XFxjaGFubmVsTWVzc2FnaW5nXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0Q2hhbm5lbE1lc3NhZ2luZyA9IHZvaWQgMDtcbi8vIEtFRVAgVEhJUyBJTiBTWU5DIFdJVEggc2Vzc2lvblN0b3JhZ2VVdGlscy4qLnRzeFxuY29uc3QgcmVzcVV0aWxzXzEgPSByZXF1aXJlKFwiLi9yZXNxVXRpbHNcIik7XG5jb25zdCBsel9zdHJpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibHotc3RyaW5nXCIpKTtcbmNvbnN0IHBvc3Rob2dfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vcG9zdGhvZy5qc1wiKSk7XG5jb25zdCBjaGFubmVsTWVzc2FnaW5nRnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsTWVzc2FnaW5nRnVuY3Rpb25zXCIpO1xuLy8gRm9yIHZpdGUgb25seSwgc2hvdyBlcnJvcnMgaW4gdGhlIGJyb3dzZXJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluY2x1ZGVzKCdmcmFtZXdvcms9VklURScpKSB7XG4gICAgY29uc3Qgc2hvd0Vycm9yT3ZlcmxheSA9IChlcnIpID0+IHtcbiAgICAgICAgLy8gbXVzdCBiZSB3aXRoaW4gZnVuY3Rpb24gY2FsbCBiZWNhdXNlIHRoYXQncyB3aGVuIHRoZSBlbGVtZW50IGlzIGRlZmluZWQgZm9yIHN1cmUuXG4gICAgICAgIGNvbnN0IEVycm9yT3ZlcmxheSA9IGN1c3RvbUVsZW1lbnRzLmdldCgndml0ZS1lcnJvci1vdmVybGF5Jyk7XG4gICAgICAgIC8vIGRvbid0IG9wZW4gb3V0c2lkZSB2aXRlIGVudmlyb25tZW50XG4gICAgICAgIGlmICghRXJyb3JPdmVybGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3ZlcmxheSA9IG5ldyBFcnJvck92ZXJsYXkoZXJyKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5KTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHNob3dFcnJvck92ZXJsYXkpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCAoeyByZWFzb24gfSkgPT4gc2hvd0Vycm9yT3ZlcmxheShyZWFzb24pKTtcbn1cbmNvbnN0IGRlYnVnTG9nSW5EZXYgPSAoLi4uc3RyKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE9ubHkgaW4gZGV2XG4gICAgaWYgKChfYSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnZGVidWdMb2c9dHJ1ZScpKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoLi4uc3RyKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gaW5pdENoYW5uZWxNZXNzYWdpbmcoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAoMCwgY2hhbm5lbE1lc3NhZ2luZ0Z1bmN0aW9uc18xLmluaXRDaGFubmVsTWVzc2FnaW5nRnVuY3Rpb25zKSgpO1xuICAgICAgICAvLyBPbmx5IGluIHByb2RcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS5lbmRzV2l0aCgnZGV2LnRlbXBvbGFicy5haScpICYmXG4gICAgICAgICAgICAhd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmVuZHNXaXRoKCdzdGFnaW5nLWRldi50ZW1wb2xhYnMuYWknKSkge1xuICAgICAgICAgICAgaWYgKHBvc3Rob2dfanNfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcG9zdGhvZ19qc18xLmRlZmF1bHQuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdHRVRfU1RBVEVfQU5EX1BST1BTJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29tcG9uZW50TmFtZSB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSByb290IHRoYXQgdXNlciBwcm92aWRlc1xuICAgICAgICAgICAgICAgIGxldCByb290U2VsZWN0b3IgPSAnI3Jvb3QnO1xuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihyb290U2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RTZWxlY3RvciA9ICcjX19uZXh0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290UmVhY3RFbGVtZW50ID0gKDAsIHJlc3FVdGlsc18xLmdldFJvb3RSZWFjdEVsZW1lbnQpKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJlZSA9ICgwLCByZXNxVXRpbHNfMS5idWlsZE5vZGVUcmVlKShyb290UmVhY3RFbGVtZW50LCBudWxsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZE5vZGVzID0gKDAsIHJlc3FVdGlsc18xLmZpbmRFbGVtZW50SW5UcmVlKSh0cmVlLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50TmFtZSAmJiBub2RlLm5hbWUgPT0gY29tcG9uZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghKGZvdW5kTm9kZXMgPT09IG51bGwgfHwgZm91bmROb2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm91bmROb2Rlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ05vIGNvbXBvbmVudCBmb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTVEFURV9BTkRfUFJPUFMgJywgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm91bmROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBtb3JlIHRoYW4gMSBjb21wb25lbnQgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmROb2RlID0gZm91bmROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZW5kRGF0YUZvck5vZGUgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZ0luRGV2KCdOT0RFIEZPVU5EOiAnLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgUFJPUFNfVE9fRVhDTFVERSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBvZWxlbWVudGlkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdGVzdGlkJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNUb1NlbmQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUucHJvcHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghUFJPUFNfVE9fRVhDTFVERVtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5wcm9wc1trZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNUb1NlbmRba2V5XSA9ICdURU1QT19PQkpFQ1RfVFlQRSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5vZGUucHJvcHNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNUb1NlbmRba2V5XSA9ICdURU1QT19GVU5DVElPTl9UWVBFJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzVG9TZW5kW2tleV0gPSBub2RlLnByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgZnVsbHkgd29yayBiZWNhdXNlIG9mIHRoaXMgYnVnOiBodHRwczovL2dpdGh1Yi5jb20vYmFydWNodmx6L3Jlc3EvaXNzdWVzLzg1XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZVRvU2VuZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnN0YXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlVG9TZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogbm9kZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobm9kZS5zdGF0ZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5zdGF0ZVtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVUb1NlbmRba2V5XSA9ICdURU1QT19PQkpFQ1RfVFlQRSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5vZGUuc3RhdGVba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVUb1NlbmRba2V5XSA9ICdURU1QT19GVU5DVElPTl9UWVBFJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlVG9TZW5kW2tleV0gPSBub2RlLnN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTVEFURV9BTkRfUFJPUFMgJywgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VuZERhdGFGb3JOb2RlKGZvdW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKChfYSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnc3Rvcnlib2FyZD10cnVlJykpIHtcbiAgICAgICAgICAgIGxldCByb290RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpO1xuICAgICAgICAgICAgaWYgKCFyb290RWwpIHtcbiAgICAgICAgICAgICAgICByb290RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdEVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guaW5jbHVkZXMoJ3R5cGU9U1RPUlknKSB8fFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCd0eXBlPUNPTVBPTkVOVCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIFtyb290RWwsIGRvY3VtZW50LmJvZHksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudF0uZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb290RWwuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgICAgICAgICAgICAgICByb290RWwuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxldCBwb3J0MiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgc3Rvcnlib2FyZElkID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFNldHVwIHRoZSB0cmFuc2ZlcmVkIHBvcnRcbiAgICAgICAgICAgIGNvbnN0IGluaXRQb3J0ID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydDIgPSBlLnBvcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBwb3J0Mi5vbm1lc3NhZ2UgPSBvbk1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnT2JqID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbXNnT2JqLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciB0aGUgaW50aWFsIHBvcnQgdHJhbnNmZXIgbWVzc2FnZVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0UG9ydCk7XG4gICAgICAgICAgICBjb25zdCBvbkluc3BlY3RFbGVtZW50ID0gKGRhdGEpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEucGF5bG9hZC5jb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOTyBDT01QT05FTlQgTkFNRScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ05vIGNvbXBvbmVudCBuYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcG9ydDIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU3VwcG9ydCBjdXN0b20gcm9vdCB0aGF0IHVzZXIgcHJvdmlkZXNcbiAgICAgICAgICAgICAgICBjb25zdCByb290UmVhY3RFbGVtZW50ID0gKDAsIHJlc3FVdGlsc18xLmdldFJvb3RSZWFjdEVsZW1lbnQpKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJlZSA9ICgwLCByZXNxVXRpbHNfMS5idWlsZE5vZGVUcmVlKShyb290UmVhY3RFbGVtZW50LCBudWxsKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzQ29tcG9uZW50LCBjb21wb25lbnROYW1lLCB0ZW1wb0VsZW1lbnRJRCwgY29tcG9uZW50RWxlbWVudElkLCB9ID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIGlmICghaXNDb21wb25lbnQgJiYgIXRlbXBvRWxlbWVudElEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyB0ZW1wbyBlbGVtZW50IElEIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAnQ291bGQgbm90IGZpbmQgZWxlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBvcnQyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCAmJiAhdGVtcG9FbGVtZW50SUQgJiYgIWNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHRlbXBvIGVsZW1lbnQgSUQgb3IgY29tcG9uZW50IG5hbWUgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdDb3VsZCBub3QgZmluZCBjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwb3J0Mi5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZE5vZGVzID0gKDAsIHJlc3FVdGlsc18xLmZpbmRFbGVtZW50SW5UcmVlKSh0cmVlLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0ZW1wb0VsZW1lbnRJRCwgYW5kIGlmIGl0J3Mgbm90IHByb3ZpZGVkLCB1c2UgdGhlIGNvbXBvbmVudCBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcG9FbGVtZW50SUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKChfYSA9IG5vZGUucHJvcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZW1wb2VsZW1lbnRpZCkgPT0gdGVtcG9FbGVtZW50SUQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IG5vZGUucHJvcHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsnZGF0YS10ZXN0aWQnXSkgPT0gdGVtcG9FbGVtZW50SUQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlbXBvRWxlbWVudElEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9PSBjb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGVtcG8gZWxlbWVudCBJRCBtdXN0IGFsd2F5cyBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBvRWxlbWVudElEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYyA9IG5vZGUucHJvcHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50ZW1wb2VsZW1lbnRpZCkgIT09IHRlbXBvRWxlbWVudElEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfZCA9IG5vZGUucHJvcHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFsnZGF0YS10ZXN0aWQnXSkgIT09IHRlbXBvRWxlbWVudElEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBJRCBpcyBwcm92aWRlZCwgZ28gdXAgdGhlIGNoYWluIHRvIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgcGFyZW50cyB3aXRoIHRoaXMgY29tcG9uZW50IGluc3RhbmNlIElEIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEVsZW1lbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlVG9DaGVjayA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZE1hdGNoaW5nQ29tcG9uZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGVUb0NoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKF9lID0gbm9kZVRvQ2hlY2sucHJvcHMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50ZW1wb2VsZW1lbnRpZCkgPT09IGNvbXBvbmVudEVsZW1lbnRJZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfZiA9IG5vZGVUb0NoZWNrLnByb3BzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZbJ2RhdGEtdGVzdGlkJ10pID09PSBjb21wb25lbnRFbGVtZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWF0Y2hpbmdDb21wb25lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvQ2hlY2sgPSBub2RlVG9DaGVjay5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRNYXRjaGluZ0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghKGZvdW5kTm9kZXMgPT09IG51bGwgfHwgZm91bmROb2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm91bmROb2Rlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nSW5EZXYoJ05PIENPTVBPTkVOVCBGT1VORCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ05vIGNvbXBvbmVudCBmb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBvcnQyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm91bmROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBtb3JlIHRoYW4gMSBjb21wb25lbnQgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmROb2RlID0gZm91bmROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZW5kRGF0YUZvck5vZGUgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZ0luRGV2KCdOT0RFIEZPVU5EOiAnLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNUb1NlbmQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUucHJvcHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5wcm9wc1trZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1RvU2VuZFtrZXldID0gJ1RFTVBPX09CSkVDVF9UWVBFJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5vZGUucHJvcHNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1RvU2VuZFtrZXldID0gJ1RFTVBPX0ZVTkNUSU9OX1RZUEUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNUb1NlbmRba2V5XSA9IG5vZGUucHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgZnVsbHkgd29yayBiZWNhdXNlIG9mIHRoaXMgYnVnOiBodHRwczovL2dpdGh1Yi5jb20vYmFydWNodmx6L3Jlc3EvaXNzdWVzLzg1XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZVRvU2VuZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnN0YXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlVG9TZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogbm9kZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobm9kZS5zdGF0ZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5zdGF0ZVtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVUb1NlbmRba2V5XSA9ICdURU1QT19PQkpFQ1RfVFlQRSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5vZGUuc3RhdGVba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVUb1NlbmRba2V5XSA9ICdURU1QT19GVU5DVElPTl9UWVBFJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlVG9TZW5kW2tleV0gPSBub2RlLnN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nSW5EZXYoJ1JFU1BPTkRJTkcgV0lUSDogJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcnQyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VuZERhdGFGb3JOb2RlKGZvdW5kTm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtZXNzYWdlcyByZWNlaXZlZCBvbiBwb3J0MlxuICAgICAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gKGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFUb0xvZyA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnBheWxvYWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21wcmVzc2VkQXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRvTG9nLnBheWxvYWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEucGF5bG9hZCksIHsgY29tcHJlc3NlZEFyZ3M6ICdDT01QUkVTU0VEJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBjb250YWluIGFyZ3MgdGhhdCBhcmUgdG9vIGxhcmdlIHRvIGxvZ1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBMT0dTX1RPX1NLSVBfQVJHUyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0UHJvamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2V0TmV3TG9va3VwcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvY2Vzc1J1bGVzRm9yU2VsZWN0ZWRFbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2IgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEucGF5bG9hZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIExPR1NfVE9fU0tJUF9BUkdTLmluY2x1ZGVzKGRhdGEucGF5bG9hZC5mdW5jdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVG9Mb2cucGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5wYXlsb2FkKSwgeyBhcmdzOiAnQVJHU19TS0lQUEVEJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZ0luRGV2KCdJTk5FUiBGUkFNRTogUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHBhcmVudDogJywgSlNPTi5zdHJpbmdpZnkoZGF0YVRvTG9nKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5wYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZ0luRGV2KCdOTyBQQVlMT0FEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZ0luRGV2KCdOTyBJRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdpbnNwZWN0RWxlbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5zcGVjdEVsZW1lbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSAnZXhlY3V0ZUZ1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSB3aW5kb3dbZGF0YS5wYXlsb2FkLmZ1bmN0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJlZ2lzdGVyIHRoZSBzdG9yeWJvYXJkSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJncyA9IGRhdGEucGF5bG9hZC5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnBheWxvYWQuY29tcHJlc3NlZEFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IEpTT04ucGFyc2UobHpfc3RyaW5nXzEuZGVmYXVsdC5kZWNvbXByZXNzKGRhdGEucGF5bG9hZC5jb21wcmVzc2VkQXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wYXlsb2FkLmZ1bmN0aW9uTmFtZSA9PT0gJ2luaXRQcm9qZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yeWJvYXJkSWQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucGF5bG9hZC5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gZm4ocG9ydDIsIHN0b3J5Ym9hcmRJZCwgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGZuKHBvcnQyLCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJTk5FUiBGUkFNRSBFUlJPUjogRnVuY3Rpb24gdG8gZXhlY3V0ZSBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0lOTkVSIEZSQU1FIEVSUk9SOiAnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNlbmQgZXJyb3IgYmFjayB0byBwYXJlbnQ/XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxufVxuZXhwb3J0cy5pbml0Q2hhbm5lbE1lc3NhZ2luZyA9IGluaXRDaGFubmVsTWVzc2FnaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/navTreeUtils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/navTreeUtils.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runNavTreeBuiltCallbacks = exports.addNavTreeBuiltCallback = exports.buildNavForNode = exports.getNavNodeForVirtualComponent = exports.ExtractedPropType = exports.SKIP_ROOT_CODEBASE_ID = exports.EMPTY_TREE_CODEBASE_ID = exports.TOP_LEVEL_PARENT_COMPONENT_TO_SKIP = exports.UNKNOWN_PARENT_COMPONENT = void 0;\nconst cssFunctions_1 = __webpack_require__(/*! ./cssFunctions */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/cssFunctions.js\");\nconst identifierUtils_1 = __webpack_require__(/*! ./identifierUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js\");\nconst outlineUtils_1 = __webpack_require__(/*! ./outlineUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/outlineUtils.js\");\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\"));\nconst sessionStorageUtils_1 = __webpack_require__(/*! ./sessionStorageUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js\");\nconst tempoElement_1 = __webpack_require__(/*! ./tempoElement */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js\");\nexports.UNKNOWN_PARENT_COMPONENT = 'UnknownComponent';\nexports.TOP_LEVEL_PARENT_COMPONENT_TO_SKIP = 'TOP_LEVEL_PARENT_COMPONENT_TO_SKIP';\nexports.EMPTY_TREE_CODEBASE_ID = 'EMPTY-TREE';\n// Special codebase ID -> if set on the root node it's expected it doesn't get rendered\n// This is used when there are multiple nodes under the root node that we want to return while we don't\n// want to render the root node itself\nexports.SKIP_ROOT_CODEBASE_ID = 'SKIP-ROOT';\n// Matches the interface on the frontend\nvar ExtractedPropType;\n(function (ExtractedPropType) {\n    ExtractedPropType[\"LITERAL\"] = \"LITERAL\";\n    ExtractedPropType[\"FUNCTION\"] = \"FUNCTION\";\n    ExtractedPropType[\"JSON_OBJECT\"] = \"JSON_OBJECT\";\n})(ExtractedPropType || (exports.ExtractedPropType = ExtractedPropType = {}));\nconst extractPropsFromReactFiberNode = (reactFiberNode) => {\n    var _a;\n    if (!((_a = reactFiberNode === null || reactFiberNode === void 0 ? void 0 : reactFiberNode.element) === null || _a === void 0 ? void 0 : _a.memoizedProps)) {\n        return {};\n    }\n    const props = {};\n    Object.keys(reactFiberNode.element.memoizedProps).forEach((key) => {\n        if (key === 'children') {\n            return;\n        }\n        // Filter out known props\n        if (identifierUtils_1.KNOWN_ATTRIBUTES.has(key.toLowerCase())) {\n            return;\n        }\n        let propValue = reactFiberNode.element.memoizedProps[key];\n        // Filter out unknown classes\n        if (key === 'className' && typeof propValue === 'string') {\n            propValue = (0, identifierUtils_1.getAllUnknownClasesFromList)(propValue.split(' ')).join(' ');\n        }\n        if (typeof propValue === 'function') {\n            props[key] = {\n                value: key,\n                type: ExtractedPropType.FUNCTION,\n            };\n        }\n        else if (typeof propValue === 'object') {\n            try {\n                props[key] = {\n                    value: JSON.stringify(propValue),\n                    type: ExtractedPropType.JSON_OBJECT,\n                };\n            }\n            catch (e) {\n                // skip this prop\n            }\n        }\n        else {\n            props[key] = {\n                value: propValue,\n                type: ExtractedPropType.LITERAL,\n            };\n        }\n    });\n    return props;\n};\nconst extractLiteralChildrenFromReactFiberNode = (reactFiberNode) => {\n    var _a, _b;\n    if (!((_b = (_a = reactFiberNode === null || reactFiberNode === void 0 ? void 0 : reactFiberNode.element) === null || _a === void 0 ? void 0 : _a.memoizedProps) === null || _b === void 0 ? void 0 : _b.children)) {\n        return [];\n    }\n    const literalChildren = [];\n    Array.from(reactFiberNode.element.memoizedProps.children || []).forEach((childProp, index) => {\n        if (typeof childProp !== 'object') {\n            literalChildren.push({\n                index,\n                value: childProp,\n            });\n        }\n    });\n    return literalChildren;\n};\nfunction selectorSafe(uniquePath) {\n    // Dictionary of replacements. You can expand this list as needed.\n    const replacements = {\n        '!': '_exclamation_',\n        '@': '_at_',\n        '#': '_hash_',\n        $: '_dollar_',\n        '%': '_percent_',\n        '^': '_caret_',\n        '&': '_and_',\n        '*': '_asterisk_',\n        '(': '_openParen_',\n        ')': '_closeParen_',\n        '+': '_plus_',\n        '=': '_equals_',\n        '[': '_openBracket_',\n        ']': '_closeBracket_',\n        '{': '_openBrace_',\n        '}': '_closeBrace_',\n        '|': '_pipe_',\n        ';': '_semicolon_',\n        ':': '_colon_',\n        ',': '_comma_',\n        '.': '_period_',\n        '<': '_lessThan_',\n        '>': '_greaterThan_',\n        '/': '_slash_',\n        '?': '_question_',\n        '\\\\': '_backslash_',\n        ' ': '_space_',\n    };\n    // Replace each character with its mapped value\n    Object.keys(replacements).forEach((character) => {\n        const regex = new RegExp('\\\\' + character, 'g');\n        uniquePath = uniquePath.replace(regex, replacements[character]);\n    });\n    // Handle invalid starting characters\n    uniquePath = uniquePath.replace(/^[0-9-]/, '_startNumOrHyphen_');\n    // Lastly, replace any remaining non-alphanumeric characters just in case\n    return uniquePath.replace(/[^a-zA-Z0-9_-]/g, '_');\n}\n/**\n * Nav node for a component that has no DOM element associated with it\n */\nconst getNavNodeForVirtualComponent = (parent, componentName, componentInstanceId, uniquePath, scopeLookup, storyboardId, reactFiberNode) => {\n    const navTreeNode = {\n        parent: parent,\n        children: [],\n        classList: [],\n        directlySetClassList: [],\n        name: '',\n        tempoElement: tempoElement_1.TempoElement.empty(),\n    };\n    navTreeNode.name = componentName;\n    navTreeNode.isComponent = true;\n    navTreeNode.tempoElement = new tempoElement_1.TempoElement(componentInstanceId, storyboardId, uniquePath);\n    navTreeNode.props = extractPropsFromReactFiberNode(reactFiberNode);\n    navTreeNode.literalChildren =\n        extractLiteralChildrenFromReactFiberNode(reactFiberNode);\n    Object.keys(scopeLookup).forEach((codebaseId) => {\n        var _a;\n        if (navTreeNode.scope) {\n            return;\n        }\n        if (((_a = scopeLookup[codebaseId].codebaseIds) === null || _a === void 0 ? void 0 : _a.indexOf(componentInstanceId)) > -1) {\n            navTreeNode.scope = scopeLookup[codebaseId];\n        }\n    });\n    return navTreeNode;\n};\nexports.getNavNodeForVirtualComponent = getNavNodeForVirtualComponent;\nconst buildNavForNode = (storyboardId, parent, node, uniquePathBase, uniquePathAddon, scopeLookup, treeElements, lookupIdToReactTreeMap, knownComponentNames, knownComponentInstanceNames, \n// Gets populated by this function, a lookup of element key -> list of element keys that represent this virtual component\nelementKeyToLookupList, elementKeyToNavNode) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    if (!node) {\n        return null;\n    }\n    if ((0, outlineUtils_1.isNodeOutline)(node)) {\n        return null;\n    }\n    if ((0, identifierUtils_1.isSkipNavTreeNode)(node)) {\n        return null;\n    }\n    if (['noscript', 'script'].includes((_a = node === null || node === void 0 ? void 0 : node.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase())) {\n        return null;\n    }\n    const foundId = (0, identifierUtils_1.getCodebaseIdFromNode)(node);\n    const reactFiberLookupId = (0, identifierUtils_1.getUniqueLookupFromNode)(node);\n    // May 15, 2023 -> found bug where a random iframe was being added with the hot reloaded code\n    // I think this is related to this bug:\n    // https://github.com/facebook/create-react-app/issues/11880\n    if (((_b = node === null || node === void 0 ? void 0 : node.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'iframe') {\n        if (!foundId) {\n            node.remove();\n            return null;\n        }\n    }\n    let reactFiberNode = null;\n    if (reactFiberLookupId) {\n        reactFiberNode = lookupIdToReactTreeMap[reactFiberLookupId];\n    }\n    const boundingRect = node.getBoundingClientRect();\n    const { top, left } = (0, jquery_1.default)(node).offset() || { top: 0, left: 0 };\n    let parentToUse = parent;\n    let uniquePathBaseToUse = uniquePathBase;\n    //////////////////////////////////////////////////////////////////\n    // Handle virtual components from the react fiber tree\n    //////////////////////////////////////////////////////////////////\n    // For outlines, components that are added need an outline around all the elements inside\n    // Create lookups in local storage to keep track of this\n    // Element keys of virtual components\n    const virtualComponentElementKeys = [];\n    // When there are react forward refs we want to collapse the node into the top level forward ref\n    let componentNameToCollapseInto;\n    let componentInstanceIdToCollapseInto;\n    if (reactFiberNode && (parent === null || parent === void 0 ? void 0 : parent.reactFiberNode)) {\n        // Traverse up the stack adding components to the tree until you hit this node's parent\n        // Note, we have to account for other children that already performed this operation and added nodes to the tree\n        let searchNode = reactFiberNode.parent;\n        let possibleNodesToAdd = [];\n        // This loop picks all the relevant nodes in between (ignoring if they are already added or not)\n        while (searchNode) {\n            if (searchNode === parent.reactFiberNode) {\n                break;\n            }\n            // Sometimes components are named differently in the react fiber tree from the codebase, but we still want to include them\n            // in the DOM tree if they are components defined in source files\n            // E.g. in next JS if you create a <Link /> element it will be called \"LinkComponent\"\n            const debugSourceFileInCodebase = ((_d = (_c = searchNode === null || searchNode === void 0 ? void 0 : searchNode.element) === null || _c === void 0 ? void 0 : _c._debugSource) === null || _d === void 0 ? void 0 : _d.fileName) &&\n                !((_g = (_f = (_e = searchNode === null || searchNode === void 0 ? void 0 : searchNode.element) === null || _e === void 0 ? void 0 : _e._debugSource) === null || _f === void 0 ? void 0 : _f.fileName) === null || _g === void 0 ? void 0 : _g.includes('node_modules'));\n            if ((((_h = searchNode.props) === null || _h === void 0 ? void 0 : _h.tempoelementid) ||\n                ((_j = searchNode.props) === null || _j === void 0 ? void 0 : _j['data-testid'])) &&\n                ((knownComponentNames === null || knownComponentNames === void 0 ? void 0 : knownComponentNames.has(searchNode.name)) ||\n                    (knownComponentInstanceNames === null || knownComponentInstanceNames === void 0 ? void 0 : knownComponentInstanceNames.has(searchNode.name)) ||\n                    debugSourceFileInCodebase)) {\n                possibleNodesToAdd.push(searchNode);\n            }\n            searchNode = searchNode.parent;\n        }\n        // Found the parent, traverse down the nodes, checking if that node was already added to the tree,\n        // and adding it if it wasn't\n        if (searchNode && possibleNodesToAdd.length) {\n            let currentParent = parent;\n            Array.from(possibleNodesToAdd)\n                .reverse()\n                .forEach((nodeToAdd) => {\n                var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                // If this is a forward ref just move forward in the tree without adding this element, but\n                // but still label the next non-forward ref with this node's name & instance ID\n                // However, only do this the first time (want the highest forward ref)\n                if (((_c = (_b = (_a = nodeToAdd === null || nodeToAdd === void 0 ? void 0 : nodeToAdd.element) === null || _a === void 0 ? void 0 : _a.elementType) === null || _b === void 0 ? void 0 : _b['$$typeof']) === null || _c === void 0 ? void 0 : _c.toString()) ===\n                    'Symbol(react.forward_ref)') {\n                    if (!componentNameToCollapseInto &&\n                        !componentInstanceIdToCollapseInto) {\n                        componentInstanceIdToCollapseInto =\n                            ((_d = nodeToAdd.props) === null || _d === void 0 ? void 0 : _d.tempoelementid) ||\n                                ((_e = nodeToAdd.props) === null || _e === void 0 ? void 0 : _e['data-testid']);\n                        const referenceTreeElement = treeElements[componentInstanceIdToCollapseInto || ''];\n                        if ((referenceTreeElement === null || referenceTreeElement === void 0 ? void 0 : referenceTreeElement.type) === 'component-instance') {\n                            componentNameToCollapseInto =\n                                referenceTreeElement.componentName;\n                        }\n                        else {\n                            componentNameToCollapseInto = nodeToAdd.name;\n                        }\n                    }\n                    return;\n                }\n                const matchingNavTreeNode = currentParent\n                    ? (_f = currentParent.children) === null || _f === void 0 ? void 0 : _f.find((child) => child.reactFiberNode === nodeToAdd)\n                    : null;\n                // Node already matches, increase level and continue\n                if (matchingNavTreeNode) {\n                    currentParent = matchingNavTreeNode;\n                    if (currentParent.tempoElement) {\n                        virtualComponentElementKeys.push(currentParent.tempoElement.getKey());\n                    }\n                    // Increase the size of the bounding box for this element\n                    if (!matchingNavTreeNode.pageBoundingBox) {\n                        matchingNavTreeNode.pageBoundingBox = {\n                            pageX: left,\n                            pageY: top,\n                            width: boundingRect.width,\n                            height: boundingRect.height,\n                        };\n                    }\n                    else {\n                        const newRight = Math.max(matchingNavTreeNode.pageBoundingBox.pageX +\n                            matchingNavTreeNode.pageBoundingBox.width, left + boundingRect.width);\n                        const newLeft = Math.min(matchingNavTreeNode.pageBoundingBox.pageX, boundingRect.left);\n                        const newTop = Math.min(matchingNavTreeNode.pageBoundingBox.pageY, boundingRect.top);\n                        const newBottom = Math.max(matchingNavTreeNode.pageBoundingBox.pageY +\n                            matchingNavTreeNode.pageBoundingBox.height, top + boundingRect.height);\n                        matchingNavTreeNode.pageBoundingBox.pageX = newLeft;\n                        matchingNavTreeNode.pageBoundingBox.pageY = newTop;\n                        matchingNavTreeNode.pageBoundingBox.width = newRight - newLeft;\n                        matchingNavTreeNode.pageBoundingBox.height = newBottom - newTop;\n                    }\n                    return;\n                }\n                else {\n                    // Otherwise, create a new virtual node, add to parent and continue\n                    let componentName;\n                    let componentInstanceId;\n                    if (componentNameToCollapseInto) {\n                        componentName = componentInstanceIdToCollapseInto;\n                        componentInstanceId = componentInstanceIdToCollapseInto;\n                        componentNameToCollapseInto = undefined;\n                        componentInstanceIdToCollapseInto = undefined;\n                    }\n                    else {\n                        componentName = nodeToAdd.name;\n                        componentInstanceId =\n                            ((_g = nodeToAdd.props) === null || _g === void 0 ? void 0 : _g.tempoelementid) ||\n                                ((_h = nodeToAdd.props) === null || _h === void 0 ? void 0 : _h['data-testid']);\n                    }\n                    // Update the unique path and use it\n                    uniquePathBaseToUse = selectorSafe(`${uniquePathBaseToUse}-${((_j = currentParent === null || currentParent === void 0 ? void 0 : currentParent.children) === null || _j === void 0 ? void 0 : _j.length) || 0}`);\n                    const newVirtualComponent = (0, exports.getNavNodeForVirtualComponent)(currentParent, nodeToAdd.name, componentInstanceId, uniquePathBaseToUse, scopeLookup, storyboardId, nodeToAdd);\n                    currentParent.children.push(newVirtualComponent);\n                    currentParent = newVirtualComponent;\n                    virtualComponentElementKeys.push(newVirtualComponent.tempoElement.getKey());\n                    elementKeyToNavNode[newVirtualComponent.tempoElement.getKey()] =\n                        newVirtualComponent;\n                    // Set the bounding box for the new virtual component\n                    newVirtualComponent.pageBoundingBox = {\n                        pageX: left,\n                        pageY: top,\n                        width: boundingRect.width,\n                        height: boundingRect.height,\n                    };\n                }\n            });\n            parentToUse = currentParent;\n        }\n    }\n    // This node corresponds to the DOM element, not any components, unless we are collapsing into the component\n    const navTreeNode = {\n        parent: parentToUse,\n        children: [],\n        classList: (0, identifierUtils_1.getAllUnknownClasses)(node),\n        directlySetClassList: [],\n        name: '',\n        tempoElement: tempoElement_1.TempoElement.empty(),\n    };\n    (_k = parentToUse === null || parentToUse === void 0 ? void 0 : parentToUse.children) === null || _k === void 0 ? void 0 : _k.push(navTreeNode);\n    navTreeNode.name = componentNameToCollapseInto || node.tagName;\n    navTreeNode.elementTagName = node.tagName;\n    // These are only forward ref components, all other components are added as virtual components\n    navTreeNode.isComponent = Boolean(componentInstanceIdToCollapseInto);\n    const uniquePathForNode = selectorSafe(`${uniquePathBaseToUse}${uniquePathAddon}`);\n    const codebaseId = componentInstanceIdToCollapseInto || foundId || undefined;\n    navTreeNode.tempoElement = new tempoElement_1.TempoElement(codebaseId, storyboardId, uniquePathForNode);\n    const nodeElementKey = navTreeNode.tempoElement.getKey();\n    // Using the virtualComponentElementKeys, set the elementKey in a list for this element\n    virtualComponentElementKeys.forEach((elementKey) => {\n        if (elementKeyToLookupList[elementKey]) {\n            elementKeyToLookupList[elementKey].push(nodeElementKey);\n        }\n        else {\n            elementKeyToLookupList[elementKey] = [nodeElementKey];\n        }\n    });\n    // Set the lookup list for the specific node itself as well\n    elementKeyToLookupList[nodeElementKey] = [nodeElementKey];\n    // Add the element key to the class to help with referencing\n    // Note - even if there is no codebase ID we still mark it as something processed in the nav tree\n    (0, identifierUtils_1.addElementKeyAsClass)(node, nodeElementKey);\n    const treeElementForNode = treeElements[navTreeNode.tempoElement.codebaseId];\n    if (treeElementForNode) {\n        const removableClasses = new Set((treeElementForNode === null || treeElementForNode === void 0 ? void 0 : treeElementForNode.removableClasses) || []);\n        navTreeNode.directlySetClassList = (_l = navTreeNode.classList) === null || _l === void 0 ? void 0 : _l.filter((cls) => {\n            return removableClasses.has(cls);\n        });\n    }\n    navTreeNode.reactFiberNode = reactFiberNode;\n    navTreeNode.props = extractPropsFromReactFiberNode(reactFiberNode);\n    navTreeNode.literalChildren =\n        extractLiteralChildrenFromReactFiberNode(reactFiberNode);\n    navTreeNode.pageBoundingBox = {\n        pageX: left,\n        pageY: top,\n        width: boundingRect.width,\n        height: boundingRect.height,\n    };\n    navTreeNode.displayType = (0, cssFunctions_1.cssEval)(node, 'display');\n    navTreeNode.positionType = (0, cssFunctions_1.cssEval)(node, 'position');\n    navTreeNode.flexDirection = (0, cssFunctions_1.cssEval)(node, 'flex-direction');\n    navTreeNode.floatVal = (0, cssFunctions_1.cssEval)(node, 'float');\n    if (navTreeNode.tempoElement.codebaseId) {\n        Object.keys(scopeLookup).forEach((codebaseId) => {\n            var _a;\n            if (navTreeNode.scope) {\n                return;\n            }\n            if (((_a = scopeLookup[codebaseId].codebaseIds) === null || _a === void 0 ? void 0 : _a.indexOf(navTreeNode.tempoElement.codebaseId)) > -1) {\n                navTreeNode.scope = scopeLookup[codebaseId];\n            }\n        });\n    }\n    // Only parse children for non-svg elements\n    if (node.children && node.tagName !== 'svg') {\n        let indexForUniqueness = 0;\n        Array.from(node.children).forEach((child) => {\n            (0, exports.buildNavForNode)(storyboardId, navTreeNode, child, uniquePathForNode, `-${indexForUniqueness}`, scopeLookup, treeElements, lookupIdToReactTreeMap, knownComponentNames, knownComponentInstanceNames, elementKeyToLookupList, elementKeyToNavNode);\n            indexForUniqueness += 1;\n        });\n    }\n    elementKeyToNavNode[nodeElementKey] = navTreeNode;\n    // This is the top-level node\n    if (!parentToUse) {\n        let newNavTree = filterOutNodesWithoutCodebaseId(navTreeNode, elementKeyToNavNode, treeElements, storyboardId);\n        return newNavTree;\n    }\n    return null;\n};\nexports.buildNavForNode = buildNavForNode;\nconst filterOutNodesWithoutCodebaseId = (finishedNavTree, elementKeyToNavNode, treeElements, storyboardId) => {\n    let treeToReturn = finishedNavTree;\n    const storyboardType = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.STORYBOARD_TYPE) || 'APPLICATION';\n    const storyboardSavedComponentFile = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SAVED_STORYBOARD_COMPONENT_FILENAME);\n    const originalStoryboardUrl = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ORIGINAL_STORYBOARD_URL);\n    const userNavigatedToNewRoute = originalStoryboardUrl &&\n        !window.location.href.includes(originalStoryboardUrl);\n    /**\n     * Returns whether the given tree element is in the top-level file of the storyboard\n     * Note - for saved components the top-level file is the saved component file\n     */\n    const isElementDirectlyInStoryboard = (node) => {\n        var _a, _b, _c, _d, _e, _f;\n        const filename = (_a = treeElements[node.tempoElement.codebaseId]) === null || _a === void 0 ? void 0 : _a.filename;\n        // For stories, just filter for anything not in _app or _document\n        if (storyboardType === 'STORY' &&\n            filename &&\n            !filename.includes('_app') &&\n            !filename.includes('_document')) {\n            return true;\n        }\n        // Special case -> if the parent is the body element this might be in a portal\n        // go all the way up the react fiber tree and see if there are any elements\n        // that are in the storyboard\n        if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.name) === 'BODY') {\n            let parentFiberNode = (_c = node.reactFiberNode) === null || _c === void 0 ? void 0 : _c.parent;\n            while (parentFiberNode) {\n                const codebaseId = ((_d = parentFiberNode === null || parentFiberNode === void 0 ? void 0 : parentFiberNode.props) === null || _d === void 0 ? void 0 : _d.tempoelementid) ||\n                    ((_e = parentFiberNode === null || parentFiberNode === void 0 ? void 0 : parentFiberNode.props) === null || _e === void 0 ? void 0 : _e['data-testid']) ||\n                    '';\n                if (codebaseId) {\n                    const treeElementFilename = (_f = treeElements[codebaseId]) === null || _f === void 0 ? void 0 : _f.filename;\n                    const valid = Boolean(treeElementFilename === null || treeElementFilename === void 0 ? void 0 : treeElementFilename.includes('tempobook/storyboards')) ||\n                        Boolean(treeElementFilename &&\n                            treeElementFilename === storyboardSavedComponentFile);\n                    if (valid) {\n                        return true;\n                    }\n                }\n                parentFiberNode = parentFiberNode === null || parentFiberNode === void 0 ? void 0 : parentFiberNode.parent;\n            }\n        }\n        // For everything else, filter anything that is not in the storyboard itself\n        return (Boolean(filename === null || filename === void 0 ? void 0 : filename.includes('tempobook/storyboards')) ||\n            Boolean(filename && filename === storyboardSavedComponentFile));\n    };\n    const processNode = (node, elementInStoryboardFound) => {\n        var _a, _b;\n        // Process the children first\n        for (let i = node.children.length - 1; i >= 0; i--) {\n            processNode(node.children[i], elementInStoryboardFound || isElementDirectlyInStoryboard(node));\n        }\n        // Product decision: Filter out nodes that don't exist in storyboard file for the corresponding component URL\n        //\n        // Historical context:\n        // Dec 14 - a bug was found where in cases that components were dynamically loaded (e.g. in Next JS _app.tsx), when you click\n        // on the top level component it would point to this location in the codebase:\n        //\n        // function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {\n        //   return (\n        //     <SessionProvider session={session}>\n        //       <Component {...pageProps} />\n        //       <Analytics />\n        //     </SessionProvider>\n        //   );\n        // }\n        //\n        // This was especially an issue for component storyboards. Thus the decision was made to hide any top-level components or divs\n        // that are not in the storyboard file\n        const inComponentStoryboardAndSkip = storyboardType !== 'APPLICATION' &&\n            !userNavigatedToNewRoute &&\n            !elementInStoryboardFound &&\n            !isElementDirectlyInStoryboard(node);\n        // If this node doesn't have a codebaseId, move its children to its parent\n        if (!((_a = node.tempoElement.codebaseId) === null || _a === void 0 ? void 0 : _a.startsWith('tempo-')) ||\n            inComponentStoryboardAndSkip) {\n            if (node.parent) {\n                // Move the children in the spot where the node was\n                const childrenToMove = node.children;\n                const indexOfNodeInParent = (_b = node.parent.children) === null || _b === void 0 ? void 0 : _b.indexOf(node);\n                node.parent.children.splice(indexOfNodeInParent, 1, ...childrenToMove);\n                // Change the parent of all the children to the new parent\n                childrenToMove.forEach((child) => {\n                    child.parent = node.parent;\n                });\n                // Remove the node from the known nodes\n                delete elementKeyToNavNode[node.tempoElement.getKey()];\n            }\n            else if (node.children.length === 1) {\n                // This is the top-level node, move it down\n                treeToReturn = node.children[0];\n                delete elementKeyToNavNode[node.tempoElement.getKey()];\n                treeToReturn.parent = undefined;\n            }\n            else if (node.children.length === 0) {\n                // 0 children, no nav tree to return\n                treeToReturn = {\n                    children: [],\n                    tempoElement: new tempoElement_1.TempoElement(exports.EMPTY_TREE_CODEBASE_ID, storyboardId, '1'),\n                    name: '',\n                };\n                delete elementKeyToNavNode[node.tempoElement.getKey()];\n            }\n            else {\n                // 2+ children, return this node, but make the codebase ID one to skip\n                node.tempoElement = new tempoElement_1.TempoElement(exports.SKIP_ROOT_CODEBASE_ID, node.tempoElement.storyboardId, node.tempoElement.uniquePath);\n                delete elementKeyToNavNode[node.tempoElement.getKey()];\n            }\n        }\n    };\n    processNode(finishedNavTree, false);\n    const postProcess = (node, level) => {\n        // Remove the react fiber node after processing\n        delete node['reactFiberNode'];\n        node.level = level;\n        node.children.forEach((child) => {\n            postProcess(child, node.tempoElement.codebaseId === exports.SKIP_ROOT_CODEBASE_ID\n                ? level\n                : level + 1);\n        });\n    };\n    postProcess(treeToReturn, 0);\n    return treeToReturn;\n};\nconst addNavTreeBuiltCallback = (callbackToAdd) => {\n    const { callbackFn, state } = callbackToAdd;\n    const callbacks = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.NAV_TREE_CALLBACKS) || [];\n    // Sort the multiSelectedElementKeys for consistency before adding\n    state.multiSelectedElementKeys = (state.multiSelectedElementKeys || []).sort();\n    const existingCallback = callbacks.find((callback) => callback.callbackFn.toString() === callbackFn.toString() &&\n        callback.state.selectedElementKey === state.selectedElementKey &&\n        callback.state.multiSelectedElementKeys.join(',') ===\n            state.multiSelectedElementKeys.join(','));\n    if (existingCallback) {\n        return;\n    }\n    callbacks.push(callbackToAdd);\n    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.NAV_TREE_CALLBACKS, callbacks);\n};\nexports.addNavTreeBuiltCallback = addNavTreeBuiltCallback;\nconst runNavTreeBuiltCallbacks = () => {\n    const callbacks = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.NAV_TREE_CALLBACKS) || [];\n    if (!callbacks.length) {\n        return;\n    }\n    const currentSelectedKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n    const multiSelectedElementKeys = ((0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS) || []).sort();\n    callbacks.forEach((callback) => {\n        const { callbackFn, state } = callback;\n        if (state.selectedElementKey === currentSelectedKey &&\n            state.multiSelectedElementKeys.join(',') ===\n                multiSelectedElementKeys.join(',')) {\n            callbackFn();\n        }\n    });\n    (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.NAV_TREE_CALLBACKS);\n};\nexports.runNavTreeBuiltCallbacks = runNavTreeBuiltCallbacks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL25hdlRyZWVVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLCtCQUErQixHQUFHLHVCQUF1QixHQUFHLHFDQUFxQyxHQUFHLHlCQUF5QixHQUFHLDZCQUE2QixHQUFHLDhCQUE4QixHQUFHLDBDQUEwQyxHQUFHLGdDQUFnQztBQUNqVCx1QkFBdUIsbUJBQU8sQ0FBQyxpR0FBZ0I7QUFDL0MsMEJBQTBCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLGlHQUFnQjtBQUMvQyxpQ0FBaUMsbUJBQU8sQ0FBQywwREFBUTtBQUNqRCw4QkFBOEIsbUJBQU8sQ0FBQywrR0FBdUI7QUFDN0QsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWdCO0FBQy9DLGdDQUFnQztBQUNoQywwQ0FBMEM7QUFDMUMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix5QkFBeUIseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVksNENBQTRDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxvQkFBb0IsR0FBRyxrSkFBa0o7QUFDbk87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9CQUFvQixFQUFFLGdCQUFnQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLG1CQUFtQjtBQUNySDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3Qix5QkFBeUI7QUFDN0U7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRCw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHN5YWhpXFxPbmVEcml2ZVxc2LPYt9itINin2YTZhdmD2KrYqFxcR2Fzc2ltXFxoZWFkc2hvdG1ha2VyYWlwcm9cXG5vZGVfbW9kdWxlc1xcdGVtcG8tZGV2dG9vbHNcXGRpc3RcXGNoYW5uZWxNZXNzYWdpbmdcXG5hdlRyZWVVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucnVuTmF2VHJlZUJ1aWx0Q2FsbGJhY2tzID0gZXhwb3J0cy5hZGROYXZUcmVlQnVpbHRDYWxsYmFjayA9IGV4cG9ydHMuYnVpbGROYXZGb3JOb2RlID0gZXhwb3J0cy5nZXROYXZOb2RlRm9yVmlydHVhbENvbXBvbmVudCA9IGV4cG9ydHMuRXh0cmFjdGVkUHJvcFR5cGUgPSBleHBvcnRzLlNLSVBfUk9PVF9DT0RFQkFTRV9JRCA9IGV4cG9ydHMuRU1QVFlfVFJFRV9DT0RFQkFTRV9JRCA9IGV4cG9ydHMuVE9QX0xFVkVMX1BBUkVOVF9DT01QT05FTlRfVE9fU0tJUCA9IGV4cG9ydHMuVU5LTk9XTl9QQVJFTlRfQ09NUE9ORU5UID0gdm9pZCAwO1xuY29uc3QgY3NzRnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi9jc3NGdW5jdGlvbnNcIik7XG5jb25zdCBpZGVudGlmaWVyVXRpbHNfMSA9IHJlcXVpcmUoXCIuL2lkZW50aWZpZXJVdGlsc1wiKTtcbmNvbnN0IG91dGxpbmVVdGlsc18xID0gcmVxdWlyZShcIi4vb3V0bGluZVV0aWxzXCIpO1xuY29uc3QganF1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5jb25zdCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi9zZXNzaW9uU3RvcmFnZVV0aWxzXCIpO1xuY29uc3QgdGVtcG9FbGVtZW50XzEgPSByZXF1aXJlKFwiLi90ZW1wb0VsZW1lbnRcIik7XG5leHBvcnRzLlVOS05PV05fUEFSRU5UX0NPTVBPTkVOVCA9ICdVbmtub3duQ29tcG9uZW50JztcbmV4cG9ydHMuVE9QX0xFVkVMX1BBUkVOVF9DT01QT05FTlRfVE9fU0tJUCA9ICdUT1BfTEVWRUxfUEFSRU5UX0NPTVBPTkVOVF9UT19TS0lQJztcbmV4cG9ydHMuRU1QVFlfVFJFRV9DT0RFQkFTRV9JRCA9ICdFTVBUWS1UUkVFJztcbi8vIFNwZWNpYWwgY29kZWJhc2UgSUQgLT4gaWYgc2V0IG9uIHRoZSByb290IG5vZGUgaXQncyBleHBlY3RlZCBpdCBkb2Vzbid0IGdldCByZW5kZXJlZFxuLy8gVGhpcyBpcyB1c2VkIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIG5vZGVzIHVuZGVyIHRoZSByb290IG5vZGUgdGhhdCB3ZSB3YW50IHRvIHJldHVybiB3aGlsZSB3ZSBkb24ndFxuLy8gd2FudCB0byByZW5kZXIgdGhlIHJvb3Qgbm9kZSBpdHNlbGZcbmV4cG9ydHMuU0tJUF9ST09UX0NPREVCQVNFX0lEID0gJ1NLSVAtUk9PVCc7XG4vLyBNYXRjaGVzIHRoZSBpbnRlcmZhY2Ugb24gdGhlIGZyb250ZW5kXG52YXIgRXh0cmFjdGVkUHJvcFR5cGU7XG4oZnVuY3Rpb24gKEV4dHJhY3RlZFByb3BUeXBlKSB7XG4gICAgRXh0cmFjdGVkUHJvcFR5cGVbXCJMSVRFUkFMXCJdID0gXCJMSVRFUkFMXCI7XG4gICAgRXh0cmFjdGVkUHJvcFR5cGVbXCJGVU5DVElPTlwiXSA9IFwiRlVOQ1RJT05cIjtcbiAgICBFeHRyYWN0ZWRQcm9wVHlwZVtcIkpTT05fT0JKRUNUXCJdID0gXCJKU09OX09CSkVDVFwiO1xufSkoRXh0cmFjdGVkUHJvcFR5cGUgfHwgKGV4cG9ydHMuRXh0cmFjdGVkUHJvcFR5cGUgPSBFeHRyYWN0ZWRQcm9wVHlwZSA9IHt9KSk7XG5jb25zdCBleHRyYWN0UHJvcHNGcm9tUmVhY3RGaWJlck5vZGUgPSAocmVhY3RGaWJlck5vZGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEoKF9hID0gcmVhY3RGaWJlck5vZGUgPT09IG51bGwgfHwgcmVhY3RGaWJlck5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlYWN0RmliZXJOb2RlLmVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZW1vaXplZFByb3BzKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgT2JqZWN0LmtleXMocmVhY3RGaWJlck5vZGUuZWxlbWVudC5tZW1vaXplZFByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbHRlciBvdXQga25vd24gcHJvcHNcbiAgICAgICAgaWYgKGlkZW50aWZpZXJVdGlsc18xLktOT1dOX0FUVFJJQlVURVMuaGFzKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcm9wVmFsdWUgPSByZWFjdEZpYmVyTm9kZS5lbGVtZW50Lm1lbW9pemVkUHJvcHNba2V5XTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCB1bmtub3duIGNsYXNzZXNcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzTmFtZScgJiYgdHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHByb3BWYWx1ZSA9ICgwLCBpZGVudGlmaWVyVXRpbHNfMS5nZXRBbGxVbmtub3duQ2xhc2VzRnJvbUxpc3QpKHByb3BWYWx1ZS5zcGxpdCgnICcpKS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGtleSxcbiAgICAgICAgICAgICAgICB0eXBlOiBFeHRyYWN0ZWRQcm9wVHlwZS5GVU5DVElPTixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KHByb3BWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV4dHJhY3RlZFByb3BUeXBlLkpTT05fT0JKRUNULFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhpcyBwcm9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wVmFsdWUsXG4gICAgICAgICAgICAgICAgdHlwZTogRXh0cmFjdGVkUHJvcFR5cGUuTElURVJBTCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvcHM7XG59O1xuY29uc3QgZXh0cmFjdExpdGVyYWxDaGlsZHJlbkZyb21SZWFjdEZpYmVyTm9kZSA9IChyZWFjdEZpYmVyTm9kZSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCEoKF9iID0gKF9hID0gcmVhY3RGaWJlck5vZGUgPT09IG51bGwgfHwgcmVhY3RGaWJlck5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlYWN0RmliZXJOb2RlLmVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZW1vaXplZFByb3BzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hpbGRyZW4pKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgbGl0ZXJhbENoaWxkcmVuID0gW107XG4gICAgQXJyYXkuZnJvbShyZWFjdEZpYmVyTm9kZS5lbGVtZW50Lm1lbW9pemVkUHJvcHMuY2hpbGRyZW4gfHwgW10pLmZvckVhY2goKGNoaWxkUHJvcCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFByb3AgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsaXRlcmFsQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkUHJvcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpdGVyYWxDaGlsZHJlbjtcbn07XG5mdW5jdGlvbiBzZWxlY3RvclNhZmUodW5pcXVlUGF0aCkge1xuICAgIC8vIERpY3Rpb25hcnkgb2YgcmVwbGFjZW1lbnRzLiBZb3UgY2FuIGV4cGFuZCB0aGlzIGxpc3QgYXMgbmVlZGVkLlxuICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IHtcbiAgICAgICAgJyEnOiAnX2V4Y2xhbWF0aW9uXycsXG4gICAgICAgICdAJzogJ19hdF8nLFxuICAgICAgICAnIyc6ICdfaGFzaF8nLFxuICAgICAgICAkOiAnX2RvbGxhcl8nLFxuICAgICAgICAnJSc6ICdfcGVyY2VudF8nLFxuICAgICAgICAnXic6ICdfY2FyZXRfJyxcbiAgICAgICAgJyYnOiAnX2FuZF8nLFxuICAgICAgICAnKic6ICdfYXN0ZXJpc2tfJyxcbiAgICAgICAgJygnOiAnX29wZW5QYXJlbl8nLFxuICAgICAgICAnKSc6ICdfY2xvc2VQYXJlbl8nLFxuICAgICAgICAnKyc6ICdfcGx1c18nLFxuICAgICAgICAnPSc6ICdfZXF1YWxzXycsXG4gICAgICAgICdbJzogJ19vcGVuQnJhY2tldF8nLFxuICAgICAgICAnXSc6ICdfY2xvc2VCcmFja2V0XycsXG4gICAgICAgICd7JzogJ19vcGVuQnJhY2VfJyxcbiAgICAgICAgJ30nOiAnX2Nsb3NlQnJhY2VfJyxcbiAgICAgICAgJ3wnOiAnX3BpcGVfJyxcbiAgICAgICAgJzsnOiAnX3NlbWljb2xvbl8nLFxuICAgICAgICAnOic6ICdfY29sb25fJyxcbiAgICAgICAgJywnOiAnX2NvbW1hXycsXG4gICAgICAgICcuJzogJ19wZXJpb2RfJyxcbiAgICAgICAgJzwnOiAnX2xlc3NUaGFuXycsXG4gICAgICAgICc+JzogJ19ncmVhdGVyVGhhbl8nLFxuICAgICAgICAnLyc6ICdfc2xhc2hfJyxcbiAgICAgICAgJz8nOiAnX3F1ZXN0aW9uXycsXG4gICAgICAgICdcXFxcJzogJ19iYWNrc2xhc2hfJyxcbiAgICAgICAgJyAnOiAnX3NwYWNlXycsXG4gICAgfTtcbiAgICAvLyBSZXBsYWNlIGVhY2ggY2hhcmFjdGVyIHdpdGggaXRzIG1hcHBlZCB2YWx1ZVxuICAgIE9iamVjdC5rZXlzKHJlcGxhY2VtZW50cykuZm9yRWFjaCgoY2hhcmFjdGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXCcgKyBjaGFyYWN0ZXIsICdnJyk7XG4gICAgICAgIHVuaXF1ZVBhdGggPSB1bmlxdWVQYXRoLnJlcGxhY2UocmVnZXgsIHJlcGxhY2VtZW50c1tjaGFyYWN0ZXJdKTtcbiAgICB9KTtcbiAgICAvLyBIYW5kbGUgaW52YWxpZCBzdGFydGluZyBjaGFyYWN0ZXJzXG4gICAgdW5pcXVlUGF0aCA9IHVuaXF1ZVBhdGgucmVwbGFjZSgvXlswLTktXS8sICdfc3RhcnROdW1Pckh5cGhlbl8nKTtcbiAgICAvLyBMYXN0bHksIHJlcGxhY2UgYW55IHJlbWFpbmluZyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMganVzdCBpbiBjYXNlXG4gICAgcmV0dXJuIHVuaXF1ZVBhdGgucmVwbGFjZSgvW15hLXpBLVowLTlfLV0vZywgJ18nKTtcbn1cbi8qKlxuICogTmF2IG5vZGUgZm9yIGEgY29tcG9uZW50IHRoYXQgaGFzIG5vIERPTSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBpdFxuICovXG5jb25zdCBnZXROYXZOb2RlRm9yVmlydHVhbENvbXBvbmVudCA9IChwYXJlbnQsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudEluc3RhbmNlSWQsIHVuaXF1ZVBhdGgsIHNjb3BlTG9va3VwLCBzdG9yeWJvYXJkSWQsIHJlYWN0RmliZXJOb2RlKSA9PiB7XG4gICAgY29uc3QgbmF2VHJlZU5vZGUgPSB7XG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIGNsYXNzTGlzdDogW10sXG4gICAgICAgIGRpcmVjdGx5U2V0Q2xhc3NMaXN0OiBbXSxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIHRlbXBvRWxlbWVudDogdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmVtcHR5KCksXG4gICAgfTtcbiAgICBuYXZUcmVlTm9kZS5uYW1lID0gY29tcG9uZW50TmFtZTtcbiAgICBuYXZUcmVlTm9kZS5pc0NvbXBvbmVudCA9IHRydWU7XG4gICAgbmF2VHJlZU5vZGUudGVtcG9FbGVtZW50ID0gbmV3IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudChjb21wb25lbnRJbnN0YW5jZUlkLCBzdG9yeWJvYXJkSWQsIHVuaXF1ZVBhdGgpO1xuICAgIG5hdlRyZWVOb2RlLnByb3BzID0gZXh0cmFjdFByb3BzRnJvbVJlYWN0RmliZXJOb2RlKHJlYWN0RmliZXJOb2RlKTtcbiAgICBuYXZUcmVlTm9kZS5saXRlcmFsQ2hpbGRyZW4gPVxuICAgICAgICBleHRyYWN0TGl0ZXJhbENoaWxkcmVuRnJvbVJlYWN0RmliZXJOb2RlKHJlYWN0RmliZXJOb2RlKTtcbiAgICBPYmplY3Qua2V5cyhzY29wZUxvb2t1cCkuZm9yRWFjaCgoY29kZWJhc2VJZCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChuYXZUcmVlTm9kZS5zY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gc2NvcGVMb29rdXBbY29kZWJhc2VJZF0uY29kZWJhc2VJZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRleE9mKGNvbXBvbmVudEluc3RhbmNlSWQpKSA+IC0xKSB7XG4gICAgICAgICAgICBuYXZUcmVlTm9kZS5zY29wZSA9IHNjb3BlTG9va3VwW2NvZGViYXNlSWRdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5hdlRyZWVOb2RlO1xufTtcbmV4cG9ydHMuZ2V0TmF2Tm9kZUZvclZpcnR1YWxDb21wb25lbnQgPSBnZXROYXZOb2RlRm9yVmlydHVhbENvbXBvbmVudDtcbmNvbnN0IGJ1aWxkTmF2Rm9yTm9kZSA9IChzdG9yeWJvYXJkSWQsIHBhcmVudCwgbm9kZSwgdW5pcXVlUGF0aEJhc2UsIHVuaXF1ZVBhdGhBZGRvbiwgc2NvcGVMb29rdXAsIHRyZWVFbGVtZW50cywgbG9va3VwSWRUb1JlYWN0VHJlZU1hcCwga25vd25Db21wb25lbnROYW1lcywga25vd25Db21wb25lbnRJbnN0YW5jZU5hbWVzLCBcbi8vIEdldHMgcG9wdWxhdGVkIGJ5IHRoaXMgZnVuY3Rpb24sIGEgbG9va3VwIG9mIGVsZW1lbnQga2V5IC0+IGxpc3Qgb2YgZWxlbWVudCBrZXlzIHRoYXQgcmVwcmVzZW50IHRoaXMgdmlydHVhbCBjb21wb25lbnRcbmVsZW1lbnRLZXlUb0xvb2t1cExpc3QsIGVsZW1lbnRLZXlUb05hdk5vZGUpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCgwLCBvdXRsaW5lVXRpbHNfMS5pc05vZGVPdXRsaW5lKShub2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCgwLCBpZGVudGlmaWVyVXRpbHNfMS5pc1NraXBOYXZUcmVlTm9kZSkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChbJ25vc2NyaXB0JywgJ3NjcmlwdCddLmluY2x1ZGVzKChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50YWdOYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kSWQgPSAoMCwgaWRlbnRpZmllclV0aWxzXzEuZ2V0Q29kZWJhc2VJZEZyb21Ob2RlKShub2RlKTtcbiAgICBjb25zdCByZWFjdEZpYmVyTG9va3VwSWQgPSAoMCwgaWRlbnRpZmllclV0aWxzXzEuZ2V0VW5pcXVlTG9va3VwRnJvbU5vZGUpKG5vZGUpO1xuICAgIC8vIE1heSAxNSwgMjAyMyAtPiBmb3VuZCBidWcgd2hlcmUgYSByYW5kb20gaWZyYW1lIHdhcyBiZWluZyBhZGRlZCB3aXRoIHRoZSBob3QgcmVsb2FkZWQgY29kZVxuICAgIC8vIEkgdGhpbmsgdGhpcyBpcyByZWxhdGVkIHRvIHRoaXMgYnVnOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8xMTg4MFxuICAgIGlmICgoKF9iID0gbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRhZ05hbWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpKSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgaWYgKCFmb3VuZElkKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlYWN0RmliZXJOb2RlID0gbnVsbDtcbiAgICBpZiAocmVhY3RGaWJlckxvb2t1cElkKSB7XG4gICAgICAgIHJlYWN0RmliZXJOb2RlID0gbG9va3VwSWRUb1JlYWN0VHJlZU1hcFtyZWFjdEZpYmVyTG9va3VwSWRdO1xuICAgIH1cbiAgICBjb25zdCBib3VuZGluZ1JlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0IH0gPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkobm9kZSkub2Zmc2V0KCkgfHwgeyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICBsZXQgcGFyZW50VG9Vc2UgPSBwYXJlbnQ7XG4gICAgbGV0IHVuaXF1ZVBhdGhCYXNlVG9Vc2UgPSB1bmlxdWVQYXRoQmFzZTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBIYW5kbGUgdmlydHVhbCBjb21wb25lbnRzIGZyb20gdGhlIHJlYWN0IGZpYmVyIHRyZWVcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBGb3Igb3V0bGluZXMsIGNvbXBvbmVudHMgdGhhdCBhcmUgYWRkZWQgbmVlZCBhbiBvdXRsaW5lIGFyb3VuZCBhbGwgdGhlIGVsZW1lbnRzIGluc2lkZVxuICAgIC8vIENyZWF0ZSBsb29rdXBzIGluIGxvY2FsIHN0b3JhZ2UgdG8ga2VlcCB0cmFjayBvZiB0aGlzXG4gICAgLy8gRWxlbWVudCBrZXlzIG9mIHZpcnR1YWwgY29tcG9uZW50c1xuICAgIGNvbnN0IHZpcnR1YWxDb21wb25lbnRFbGVtZW50S2V5cyA9IFtdO1xuICAgIC8vIFdoZW4gdGhlcmUgYXJlIHJlYWN0IGZvcndhcmQgcmVmcyB3ZSB3YW50IHRvIGNvbGxhcHNlIHRoZSBub2RlIGludG8gdGhlIHRvcCBsZXZlbCBmb3J3YXJkIHJlZlxuICAgIGxldCBjb21wb25lbnROYW1lVG9Db2xsYXBzZUludG87XG4gICAgbGV0IGNvbXBvbmVudEluc3RhbmNlSWRUb0NvbGxhcHNlSW50bztcbiAgICBpZiAocmVhY3RGaWJlck5vZGUgJiYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5yZWFjdEZpYmVyTm9kZSkpIHtcbiAgICAgICAgLy8gVHJhdmVyc2UgdXAgdGhlIHN0YWNrIGFkZGluZyBjb21wb25lbnRzIHRvIHRoZSB0cmVlIHVudGlsIHlvdSBoaXQgdGhpcyBub2RlJ3MgcGFyZW50XG4gICAgICAgIC8vIE5vdGUsIHdlIGhhdmUgdG8gYWNjb3VudCBmb3Igb3RoZXIgY2hpbGRyZW4gdGhhdCBhbHJlYWR5IHBlcmZvcm1lZCB0aGlzIG9wZXJhdGlvbiBhbmQgYWRkZWQgbm9kZXMgdG8gdGhlIHRyZWVcbiAgICAgICAgbGV0IHNlYXJjaE5vZGUgPSByZWFjdEZpYmVyTm9kZS5wYXJlbnQ7XG4gICAgICAgIGxldCBwb3NzaWJsZU5vZGVzVG9BZGQgPSBbXTtcbiAgICAgICAgLy8gVGhpcyBsb29wIHBpY2tzIGFsbCB0aGUgcmVsZXZhbnQgbm9kZXMgaW4gYmV0d2VlbiAoaWdub3JpbmcgaWYgdGhleSBhcmUgYWxyZWFkeSBhZGRlZCBvciBub3QpXG4gICAgICAgIHdoaWxlIChzZWFyY2hOb2RlKSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoTm9kZSA9PT0gcGFyZW50LnJlYWN0RmliZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgY29tcG9uZW50cyBhcmUgbmFtZWQgZGlmZmVyZW50bHkgaW4gdGhlIHJlYWN0IGZpYmVyIHRyZWUgZnJvbSB0aGUgY29kZWJhc2UsIGJ1dCB3ZSBzdGlsbCB3YW50IHRvIGluY2x1ZGUgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIERPTSB0cmVlIGlmIHRoZXkgYXJlIGNvbXBvbmVudHMgZGVmaW5lZCBpbiBzb3VyY2UgZmlsZXNcbiAgICAgICAgICAgIC8vIEUuZy4gaW4gbmV4dCBKUyBpZiB5b3UgY3JlYXRlIGEgPExpbmsgLz4gZWxlbWVudCBpdCB3aWxsIGJlIGNhbGxlZCBcIkxpbmtDb21wb25lbnRcIlxuICAgICAgICAgICAgY29uc3QgZGVidWdTb3VyY2VGaWxlSW5Db2RlYmFzZSA9ICgoX2QgPSAoX2MgPSBzZWFyY2hOb2RlID09PSBudWxsIHx8IHNlYXJjaE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlYXJjaE5vZGUuZWxlbWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLl9kZWJ1Z1NvdXJjZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmZpbGVOYW1lKSAmJlxuICAgICAgICAgICAgICAgICEoKF9nID0gKF9mID0gKF9lID0gc2VhcmNoTm9kZSA9PT0gbnVsbCB8fCBzZWFyY2hOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hOb2RlLmVsZW1lbnQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5fZGVidWdTb3VyY2UpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5maWxlTmFtZSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmluY2x1ZGVzKCdub2RlX21vZHVsZXMnKSk7XG4gICAgICAgICAgICBpZiAoKCgoX2ggPSBzZWFyY2hOb2RlLnByb3BzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gudGVtcG9lbGVtZW50aWQpIHx8XG4gICAgICAgICAgICAgICAgKChfaiA9IHNlYXJjaE5vZGUucHJvcHMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfalsnZGF0YS10ZXN0aWQnXSkpICYmXG4gICAgICAgICAgICAgICAgKChrbm93bkNvbXBvbmVudE5hbWVzID09PSBudWxsIHx8IGtub3duQ29tcG9uZW50TmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGtub3duQ29tcG9uZW50TmFtZXMuaGFzKHNlYXJjaE5vZGUubmFtZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIChrbm93bkNvbXBvbmVudEluc3RhbmNlTmFtZXMgPT09IG51bGwgfHwga25vd25Db21wb25lbnRJbnN0YW5jZU5hbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBrbm93bkNvbXBvbmVudEluc3RhbmNlTmFtZXMuaGFzKHNlYXJjaE5vZGUubmFtZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnU291cmNlRmlsZUluQ29kZWJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcG9zc2libGVOb2Rlc1RvQWRkLnB1c2goc2VhcmNoTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWFyY2hOb2RlID0gc2VhcmNoTm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm91bmQgdGhlIHBhcmVudCwgdHJhdmVyc2UgZG93biB0aGUgbm9kZXMsIGNoZWNraW5nIGlmIHRoYXQgbm9kZSB3YXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgdHJlZSxcbiAgICAgICAgLy8gYW5kIGFkZGluZyBpdCBpZiBpdCB3YXNuJ3RcbiAgICAgICAgaWYgKHNlYXJjaE5vZGUgJiYgcG9zc2libGVOb2Rlc1RvQWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBBcnJheS5mcm9tKHBvc3NpYmxlTm9kZXNUb0FkZClcbiAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKG5vZGVUb0FkZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBmb3J3YXJkIHJlZiBqdXN0IG1vdmUgZm9yd2FyZCBpbiB0aGUgdHJlZSB3aXRob3V0IGFkZGluZyB0aGlzIGVsZW1lbnQsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBzdGlsbCBsYWJlbCB0aGUgbmV4dCBub24tZm9yd2FyZCByZWYgd2l0aCB0aGlzIG5vZGUncyBuYW1lICYgaW5zdGFuY2UgSURcbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBvbmx5IGRvIHRoaXMgdGhlIGZpcnN0IHRpbWUgKHdhbnQgdGhlIGhpZ2hlc3QgZm9yd2FyZCByZWYpXG4gICAgICAgICAgICAgICAgaWYgKCgoX2MgPSAoX2IgPSAoX2EgPSBub2RlVG9BZGQgPT09IG51bGwgfHwgbm9kZVRvQWRkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlVG9BZGQuZWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsZW1lbnRUeXBlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJyQkdHlwZW9mJ10pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgJ1N5bWJvbChyZWFjdC5mb3J3YXJkX3JlZiknKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50TmFtZVRvQ29sbGFwc2VJbnRvICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhY29tcG9uZW50SW5zdGFuY2VJZFRvQ29sbGFwc2VJbnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZUlkVG9Db2xsYXBzZUludG8gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2QgPSBub2RlVG9BZGQucHJvcHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50ZW1wb2VsZW1lbnRpZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfZSA9IG5vZGVUb0FkZC5wcm9wcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWydkYXRhLXRlc3RpZCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZVRyZWVFbGVtZW50ID0gdHJlZUVsZW1lbnRzW2NvbXBvbmVudEluc3RhbmNlSWRUb0NvbGxhcHNlSW50byB8fCAnJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlZmVyZW5jZVRyZWVFbGVtZW50ID09PSBudWxsIHx8IHJlZmVyZW5jZVRyZWVFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZlcmVuY2VUcmVlRWxlbWVudC50eXBlKSA9PT0gJ2NvbXBvbmVudC1pbnN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lVG9Db2xsYXBzZUludG8gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VUcmVlRWxlbWVudC5jb21wb25lbnROYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVRvQ29sbGFwc2VJbnRvID0gbm9kZVRvQWRkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ05hdlRyZWVOb2RlID0gY3VycmVudFBhcmVudFxuICAgICAgICAgICAgICAgICAgICA/IChfZiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5maW5kKChjaGlsZCkgPT4gY2hpbGQucmVhY3RGaWJlck5vZGUgPT09IG5vZGVUb0FkZClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIE5vZGUgYWxyZWFkeSBtYXRjaGVzLCBpbmNyZWFzZSBsZXZlbCBhbmQgY29udGludWVcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdOYXZUcmVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gbWF0Y2hpbmdOYXZUcmVlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQudGVtcG9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsQ29tcG9uZW50RWxlbWVudEtleXMucHVzaChjdXJyZW50UGFyZW50LnRlbXBvRWxlbWVudC5nZXRLZXkoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hpbmdOYXZUcmVlTm9kZS5wYWdlQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nTmF2VHJlZU5vZGUucGFnZUJvdW5kaW5nQm94ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UmlnaHQgPSBNYXRoLm1heChtYXRjaGluZ05hdlRyZWVOb2RlLnBhZ2VCb3VuZGluZ0JveC5wYWdlWCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdOYXZUcmVlTm9kZS5wYWdlQm91bmRpbmdCb3gud2lkdGgsIGxlZnQgKyBib3VuZGluZ1JlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TGVmdCA9IE1hdGgubWluKG1hdGNoaW5nTmF2VHJlZU5vZGUucGFnZUJvdW5kaW5nQm94LnBhZ2VYLCBib3VuZGluZ1JlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUb3AgPSBNYXRoLm1pbihtYXRjaGluZ05hdlRyZWVOb2RlLnBhZ2VCb3VuZGluZ0JveC5wYWdlWSwgYm91bmRpbmdSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdCb3R0b20gPSBNYXRoLm1heChtYXRjaGluZ05hdlRyZWVOb2RlLnBhZ2VCb3VuZGluZ0JveC5wYWdlWSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdOYXZUcmVlTm9kZS5wYWdlQm91bmRpbmdCb3guaGVpZ2h0LCB0b3AgKyBib3VuZGluZ1JlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nTmF2VHJlZU5vZGUucGFnZUJvdW5kaW5nQm94LnBhZ2VYID0gbmV3TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nTmF2VHJlZU5vZGUucGFnZUJvdW5kaW5nQm94LnBhZ2VZID0gbmV3VG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdOYXZUcmVlTm9kZS5wYWdlQm91bmRpbmdCb3gud2lkdGggPSBuZXdSaWdodCAtIG5ld0xlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ05hdlRyZWVOb2RlLnBhZ2VCb3VuZGluZ0JveC5oZWlnaHQgPSBuZXdCb3R0b20gLSBuZXdUb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgdmlydHVhbCBub2RlLCBhZGQgdG8gcGFyZW50IGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcG9uZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbXBvbmVudEluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnROYW1lVG9Db2xsYXBzZUludG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnRJbnN0YW5jZUlkVG9Db2xsYXBzZUludG87XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZUlkID0gY29tcG9uZW50SW5zdGFuY2VJZFRvQ29sbGFwc2VJbnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVRvQ29sbGFwc2VJbnRvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2VJZFRvQ29sbGFwc2VJbnRvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSA9IG5vZGVUb0FkZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2VJZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfZyA9IG5vZGVUb0FkZC5wcm9wcykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnRlbXBvZWxlbWVudGlkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9oID0gbm9kZVRvQWRkLnByb3BzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hbJ2RhdGEtdGVzdGlkJ10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdW5pcXVlIHBhdGggYW5kIHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVQYXRoQmFzZVRvVXNlID0gc2VsZWN0b3JTYWZlKGAke3VuaXF1ZVBhdGhCYXNlVG9Vc2V9LSR7KChfaiA9IGN1cnJlbnRQYXJlbnQgPT09IG51bGwgfHwgY3VycmVudFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFBhcmVudC5jaGlsZHJlbikgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmxlbmd0aCkgfHwgMH1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmlydHVhbENvbXBvbmVudCA9ICgwLCBleHBvcnRzLmdldE5hdk5vZGVGb3JWaXJ0dWFsQ29tcG9uZW50KShjdXJyZW50UGFyZW50LCBub2RlVG9BZGQubmFtZSwgY29tcG9uZW50SW5zdGFuY2VJZCwgdW5pcXVlUGF0aEJhc2VUb1VzZSwgc2NvcGVMb29rdXAsIHN0b3J5Ym9hcmRJZCwgbm9kZVRvQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKG5ld1ZpcnR1YWxDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gbmV3VmlydHVhbENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgdmlydHVhbENvbXBvbmVudEVsZW1lbnRLZXlzLnB1c2gobmV3VmlydHVhbENvbXBvbmVudC50ZW1wb0VsZW1lbnQuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50S2V5VG9OYXZOb2RlW25ld1ZpcnR1YWxDb21wb25lbnQudGVtcG9FbGVtZW50LmdldEtleSgpXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWaXJ0dWFsQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhlIG5ldyB2aXJ0dWFsIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBuZXdWaXJ0dWFsQ29tcG9uZW50LnBhZ2VCb3VuZGluZ0JveCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRUb1VzZSA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBub2RlIGNvcnJlc3BvbmRzIHRvIHRoZSBET00gZWxlbWVudCwgbm90IGFueSBjb21wb25lbnRzLCB1bmxlc3Mgd2UgYXJlIGNvbGxhcHNpbmcgaW50byB0aGUgY29tcG9uZW50XG4gICAgY29uc3QgbmF2VHJlZU5vZGUgPSB7XG4gICAgICAgIHBhcmVudDogcGFyZW50VG9Vc2UsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgY2xhc3NMaXN0OiAoMCwgaWRlbnRpZmllclV0aWxzXzEuZ2V0QWxsVW5rbm93bkNsYXNzZXMpKG5vZGUpLFxuICAgICAgICBkaXJlY3RseVNldENsYXNzTGlzdDogW10sXG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICB0ZW1wb0VsZW1lbnQ6IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5lbXB0eSgpLFxuICAgIH07XG4gICAgKF9rID0gcGFyZW50VG9Vc2UgPT09IG51bGwgfHwgcGFyZW50VG9Vc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudFRvVXNlLmNoaWxkcmVuKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2sucHVzaChuYXZUcmVlTm9kZSk7XG4gICAgbmF2VHJlZU5vZGUubmFtZSA9IGNvbXBvbmVudE5hbWVUb0NvbGxhcHNlSW50byB8fCBub2RlLnRhZ05hbWU7XG4gICAgbmF2VHJlZU5vZGUuZWxlbWVudFRhZ05hbWUgPSBub2RlLnRhZ05hbWU7XG4gICAgLy8gVGhlc2UgYXJlIG9ubHkgZm9yd2FyZCByZWYgY29tcG9uZW50cywgYWxsIG90aGVyIGNvbXBvbmVudHMgYXJlIGFkZGVkIGFzIHZpcnR1YWwgY29tcG9uZW50c1xuICAgIG5hdlRyZWVOb2RlLmlzQ29tcG9uZW50ID0gQm9vbGVhbihjb21wb25lbnRJbnN0YW5jZUlkVG9Db2xsYXBzZUludG8pO1xuICAgIGNvbnN0IHVuaXF1ZVBhdGhGb3JOb2RlID0gc2VsZWN0b3JTYWZlKGAke3VuaXF1ZVBhdGhCYXNlVG9Vc2V9JHt1bmlxdWVQYXRoQWRkb259YCk7XG4gICAgY29uc3QgY29kZWJhc2VJZCA9IGNvbXBvbmVudEluc3RhbmNlSWRUb0NvbGxhcHNlSW50byB8fCBmb3VuZElkIHx8IHVuZGVmaW5lZDtcbiAgICBuYXZUcmVlTm9kZS50ZW1wb0VsZW1lbnQgPSBuZXcgdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50KGNvZGViYXNlSWQsIHN0b3J5Ym9hcmRJZCwgdW5pcXVlUGF0aEZvck5vZGUpO1xuICAgIGNvbnN0IG5vZGVFbGVtZW50S2V5ID0gbmF2VHJlZU5vZGUudGVtcG9FbGVtZW50LmdldEtleSgpO1xuICAgIC8vIFVzaW5nIHRoZSB2aXJ0dWFsQ29tcG9uZW50RWxlbWVudEtleXMsIHNldCB0aGUgZWxlbWVudEtleSBpbiBhIGxpc3QgZm9yIHRoaXMgZWxlbWVudFxuICAgIHZpcnR1YWxDb21wb25lbnRFbGVtZW50S2V5cy5mb3JFYWNoKChlbGVtZW50S2V5KSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50S2V5VG9Mb29rdXBMaXN0W2VsZW1lbnRLZXldKSB7XG4gICAgICAgICAgICBlbGVtZW50S2V5VG9Mb29rdXBMaXN0W2VsZW1lbnRLZXldLnB1c2gobm9kZUVsZW1lbnRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudEtleVRvTG9va3VwTGlzdFtlbGVtZW50S2V5XSA9IFtub2RlRWxlbWVudEtleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBTZXQgdGhlIGxvb2t1cCBsaXN0IGZvciB0aGUgc3BlY2lmaWMgbm9kZSBpdHNlbGYgYXMgd2VsbFxuICAgIGVsZW1lbnRLZXlUb0xvb2t1cExpc3Rbbm9kZUVsZW1lbnRLZXldID0gW25vZGVFbGVtZW50S2V5XTtcbiAgICAvLyBBZGQgdGhlIGVsZW1lbnQga2V5IHRvIHRoZSBjbGFzcyB0byBoZWxwIHdpdGggcmVmZXJlbmNpbmdcbiAgICAvLyBOb3RlIC0gZXZlbiBpZiB0aGVyZSBpcyBubyBjb2RlYmFzZSBJRCB3ZSBzdGlsbCBtYXJrIGl0IGFzIHNvbWV0aGluZyBwcm9jZXNzZWQgaW4gdGhlIG5hdiB0cmVlXG4gICAgKDAsIGlkZW50aWZpZXJVdGlsc18xLmFkZEVsZW1lbnRLZXlBc0NsYXNzKShub2RlLCBub2RlRWxlbWVudEtleSk7XG4gICAgY29uc3QgdHJlZUVsZW1lbnRGb3JOb2RlID0gdHJlZUVsZW1lbnRzW25hdlRyZWVOb2RlLnRlbXBvRWxlbWVudC5jb2RlYmFzZUlkXTtcbiAgICBpZiAodHJlZUVsZW1lbnRGb3JOb2RlKSB7XG4gICAgICAgIGNvbnN0IHJlbW92YWJsZUNsYXNzZXMgPSBuZXcgU2V0KCh0cmVlRWxlbWVudEZvck5vZGUgPT09IG51bGwgfHwgdHJlZUVsZW1lbnRGb3JOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmVlRWxlbWVudEZvck5vZGUucmVtb3ZhYmxlQ2xhc3NlcykgfHwgW10pO1xuICAgICAgICBuYXZUcmVlTm9kZS5kaXJlY3RseVNldENsYXNzTGlzdCA9IChfbCA9IG5hdlRyZWVOb2RlLmNsYXNzTGlzdCkgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmZpbHRlcigoY2xzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZhYmxlQ2xhc3Nlcy5oYXMoY2xzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5hdlRyZWVOb2RlLnJlYWN0RmliZXJOb2RlID0gcmVhY3RGaWJlck5vZGU7XG4gICAgbmF2VHJlZU5vZGUucHJvcHMgPSBleHRyYWN0UHJvcHNGcm9tUmVhY3RGaWJlck5vZGUocmVhY3RGaWJlck5vZGUpO1xuICAgIG5hdlRyZWVOb2RlLmxpdGVyYWxDaGlsZHJlbiA9XG4gICAgICAgIGV4dHJhY3RMaXRlcmFsQ2hpbGRyZW5Gcm9tUmVhY3RGaWJlck5vZGUocmVhY3RGaWJlck5vZGUpO1xuICAgIG5hdlRyZWVOb2RlLnBhZ2VCb3VuZGluZ0JveCA9IHtcbiAgICAgICAgcGFnZVg6IGxlZnQsXG4gICAgICAgIHBhZ2VZOiB0b3AsXG4gICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodCxcbiAgICB9O1xuICAgIG5hdlRyZWVOb2RlLmRpc3BsYXlUeXBlID0gKDAsIGNzc0Z1bmN0aW9uc18xLmNzc0V2YWwpKG5vZGUsICdkaXNwbGF5Jyk7XG4gICAgbmF2VHJlZU5vZGUucG9zaXRpb25UeXBlID0gKDAsIGNzc0Z1bmN0aW9uc18xLmNzc0V2YWwpKG5vZGUsICdwb3NpdGlvbicpO1xuICAgIG5hdlRyZWVOb2RlLmZsZXhEaXJlY3Rpb24gPSAoMCwgY3NzRnVuY3Rpb25zXzEuY3NzRXZhbCkobm9kZSwgJ2ZsZXgtZGlyZWN0aW9uJyk7XG4gICAgbmF2VHJlZU5vZGUuZmxvYXRWYWwgPSAoMCwgY3NzRnVuY3Rpb25zXzEuY3NzRXZhbCkobm9kZSwgJ2Zsb2F0Jyk7XG4gICAgaWYgKG5hdlRyZWVOb2RlLnRlbXBvRWxlbWVudC5jb2RlYmFzZUlkKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNjb3BlTG9va3VwKS5mb3JFYWNoKChjb2RlYmFzZUlkKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAobmF2VHJlZU5vZGUuc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKChfYSA9IHNjb3BlTG9va3VwW2NvZGViYXNlSWRdLmNvZGViYXNlSWRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXhPZihuYXZUcmVlTm9kZS50ZW1wb0VsZW1lbnQuY29kZWJhc2VJZCkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBuYXZUcmVlTm9kZS5zY29wZSA9IHNjb3BlTG9va3VwW2NvZGViYXNlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gT25seSBwYXJzZSBjaGlsZHJlbiBmb3Igbm9uLXN2ZyBlbGVtZW50c1xuICAgIGlmIChub2RlLmNoaWxkcmVuICYmIG5vZGUudGFnTmFtZSAhPT0gJ3N2ZycpIHtcbiAgICAgICAgbGV0IGluZGV4Rm9yVW5pcXVlbmVzcyA9IDA7XG4gICAgICAgIEFycmF5LmZyb20obm9kZS5jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICgwLCBleHBvcnRzLmJ1aWxkTmF2Rm9yTm9kZSkoc3Rvcnlib2FyZElkLCBuYXZUcmVlTm9kZSwgY2hpbGQsIHVuaXF1ZVBhdGhGb3JOb2RlLCBgLSR7aW5kZXhGb3JVbmlxdWVuZXNzfWAsIHNjb3BlTG9va3VwLCB0cmVlRWxlbWVudHMsIGxvb2t1cElkVG9SZWFjdFRyZWVNYXAsIGtub3duQ29tcG9uZW50TmFtZXMsIGtub3duQ29tcG9uZW50SW5zdGFuY2VOYW1lcywgZWxlbWVudEtleVRvTG9va3VwTGlzdCwgZWxlbWVudEtleVRvTmF2Tm9kZSk7XG4gICAgICAgICAgICBpbmRleEZvclVuaXF1ZW5lc3MgKz0gMTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsZW1lbnRLZXlUb05hdk5vZGVbbm9kZUVsZW1lbnRLZXldID0gbmF2VHJlZU5vZGU7XG4gICAgLy8gVGhpcyBpcyB0aGUgdG9wLWxldmVsIG5vZGVcbiAgICBpZiAoIXBhcmVudFRvVXNlKSB7XG4gICAgICAgIGxldCBuZXdOYXZUcmVlID0gZmlsdGVyT3V0Tm9kZXNXaXRob3V0Q29kZWJhc2VJZChuYXZUcmVlTm9kZSwgZWxlbWVudEtleVRvTmF2Tm9kZSwgdHJlZUVsZW1lbnRzLCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICByZXR1cm4gbmV3TmF2VHJlZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0cy5idWlsZE5hdkZvck5vZGUgPSBidWlsZE5hdkZvck5vZGU7XG5jb25zdCBmaWx0ZXJPdXROb2Rlc1dpdGhvdXRDb2RlYmFzZUlkID0gKGZpbmlzaGVkTmF2VHJlZSwgZWxlbWVudEtleVRvTmF2Tm9kZSwgdHJlZUVsZW1lbnRzLCBzdG9yeWJvYXJkSWQpID0+IHtcbiAgICBsZXQgdHJlZVRvUmV0dXJuID0gZmluaXNoZWROYXZUcmVlO1xuICAgIGNvbnN0IHN0b3J5Ym9hcmRUeXBlID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNUT1JZQk9BUkRfVFlQRSkgfHwgJ0FQUExJQ0FUSU9OJztcbiAgICBjb25zdCBzdG9yeWJvYXJkU2F2ZWRDb21wb25lbnRGaWxlID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNBVkVEX1NUT1JZQk9BUkRfQ09NUE9ORU5UX0ZJTEVOQU1FKTtcbiAgICBjb25zdCBvcmlnaW5hbFN0b3J5Ym9hcmRVcmwgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuT1JJR0lOQUxfU1RPUllCT0FSRF9VUkwpO1xuICAgIGNvbnN0IHVzZXJOYXZpZ2F0ZWRUb05ld1JvdXRlID0gb3JpZ2luYWxTdG9yeWJvYXJkVXJsICYmXG4gICAgICAgICF3aW5kb3cubG9jYXRpb24uaHJlZi5pbmNsdWRlcyhvcmlnaW5hbFN0b3J5Ym9hcmRVcmwpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gdHJlZSBlbGVtZW50IGlzIGluIHRoZSB0b3AtbGV2ZWwgZmlsZSBvZiB0aGUgc3Rvcnlib2FyZFxuICAgICAqIE5vdGUgLSBmb3Igc2F2ZWQgY29tcG9uZW50cyB0aGUgdG9wLWxldmVsIGZpbGUgaXMgdGhlIHNhdmVkIGNvbXBvbmVudCBmaWxlXG4gICAgICovXG4gICAgY29uc3QgaXNFbGVtZW50RGlyZWN0bHlJblN0b3J5Ym9hcmQgPSAobm9kZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoX2EgPSB0cmVlRWxlbWVudHNbbm9kZS50ZW1wb0VsZW1lbnQuY29kZWJhc2VJZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWxlbmFtZTtcbiAgICAgICAgLy8gRm9yIHN0b3JpZXMsIGp1c3QgZmlsdGVyIGZvciBhbnl0aGluZyBub3QgaW4gX2FwcCBvciBfZG9jdW1lbnRcbiAgICAgICAgaWYgKHN0b3J5Ym9hcmRUeXBlID09PSAnU1RPUlknICYmXG4gICAgICAgICAgICBmaWxlbmFtZSAmJlxuICAgICAgICAgICAgIWZpbGVuYW1lLmluY2x1ZGVzKCdfYXBwJykgJiZcbiAgICAgICAgICAgICFmaWxlbmFtZS5pbmNsdWRlcygnX2RvY3VtZW50JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSAtPiBpZiB0aGUgcGFyZW50IGlzIHRoZSBib2R5IGVsZW1lbnQgdGhpcyBtaWdodCBiZSBpbiBhIHBvcnRhbFxuICAgICAgICAvLyBnbyBhbGwgdGhlIHdheSB1cCB0aGUgcmVhY3QgZmliZXIgdHJlZSBhbmQgc2VlIGlmIHRoZXJlIGFyZSBhbnkgZWxlbWVudHNcbiAgICAgICAgLy8gdGhhdCBhcmUgaW4gdGhlIHN0b3J5Ym9hcmRcbiAgICAgICAgaWYgKCgoX2IgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRGaWJlck5vZGUgPSAoX2MgPSBub2RlLnJlYWN0RmliZXJOb2RlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudEZpYmVyTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGViYXNlSWQgPSAoKF9kID0gcGFyZW50RmliZXJOb2RlID09PSBudWxsIHx8IHBhcmVudEZpYmVyTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50RmliZXJOb2RlLnByb3BzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudGVtcG9lbGVtZW50aWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICgoX2UgPSBwYXJlbnRGaWJlck5vZGUgPT09IG51bGwgfHwgcGFyZW50RmliZXJOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRGaWJlck5vZGUucHJvcHMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVsnZGF0YS10ZXN0aWQnXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgJyc7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGViYXNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJlZUVsZW1lbnRGaWxlbmFtZSA9IChfZiA9IHRyZWVFbGVtZW50c1tjb2RlYmFzZUlkXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IEJvb2xlYW4odHJlZUVsZW1lbnRGaWxlbmFtZSA9PT0gbnVsbCB8fCB0cmVlRWxlbWVudEZpbGVuYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmVlRWxlbWVudEZpbGVuYW1lLmluY2x1ZGVzKCd0ZW1wb2Jvb2svc3Rvcnlib2FyZHMnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIEJvb2xlYW4odHJlZUVsZW1lbnRGaWxlbmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVFbGVtZW50RmlsZW5hbWUgPT09IHN0b3J5Ym9hcmRTYXZlZENvbXBvbmVudEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudEZpYmVyTm9kZSA9IHBhcmVudEZpYmVyTm9kZSA9PT0gbnVsbCB8fCBwYXJlbnRGaWJlck5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEZpYmVyTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGV2ZXJ5dGhpbmcgZWxzZSwgZmlsdGVyIGFueXRoaW5nIHRoYXQgaXMgbm90IGluIHRoZSBzdG9yeWJvYXJkIGl0c2VsZlxuICAgICAgICByZXR1cm4gKEJvb2xlYW4oZmlsZW5hbWUgPT09IG51bGwgfHwgZmlsZW5hbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVuYW1lLmluY2x1ZGVzKCd0ZW1wb2Jvb2svc3Rvcnlib2FyZHMnKSkgfHxcbiAgICAgICAgICAgIEJvb2xlYW4oZmlsZW5hbWUgJiYgZmlsZW5hbWUgPT09IHN0b3J5Ym9hcmRTYXZlZENvbXBvbmVudEZpbGUpKTtcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NOb2RlID0gKG5vZGUsIGVsZW1lbnRJblN0b3J5Ym9hcmRGb3VuZCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGlsZHJlbiBmaXJzdFxuICAgICAgICBmb3IgKGxldCBpID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcHJvY2Vzc05vZGUobm9kZS5jaGlsZHJlbltpXSwgZWxlbWVudEluU3Rvcnlib2FyZEZvdW5kIHx8IGlzRWxlbWVudERpcmVjdGx5SW5TdG9yeWJvYXJkKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9kdWN0IGRlY2lzaW9uOiBGaWx0ZXIgb3V0IG5vZGVzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gc3Rvcnlib2FyZCBmaWxlIGZvciB0aGUgY29ycmVzcG9uZGluZyBjb21wb25lbnQgVVJMXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhpc3RvcmljYWwgY29udGV4dDpcbiAgICAgICAgLy8gRGVjIDE0IC0gYSBidWcgd2FzIGZvdW5kIHdoZXJlIGluIGNhc2VzIHRoYXQgY29tcG9uZW50cyB3ZXJlIGR5bmFtaWNhbGx5IGxvYWRlZCAoZS5nLiBpbiBOZXh0IEpTIF9hcHAudHN4KSwgd2hlbiB5b3UgY2xpY2tcbiAgICAgICAgLy8gb24gdGhlIHRvcCBsZXZlbCBjb21wb25lbnQgaXQgd291bGQgcG9pbnQgdG8gdGhpcyBsb2NhdGlvbiBpbiB0aGUgY29kZWJhc2U6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGZ1bmN0aW9uIE15QXBwKHsgQ29tcG9uZW50LCBwYWdlUHJvcHM6IHsgc2Vzc2lvbiwgLi4ucGFnZVByb3BzIH0gfTogQXBwUHJvcHMpIHtcbiAgICAgICAgLy8gICByZXR1cm4gKFxuICAgICAgICAvLyAgICAgPFNlc3Npb25Qcm92aWRlciBzZXNzaW9uPXtzZXNzaW9ufT5cbiAgICAgICAgLy8gICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxuICAgICAgICAvLyAgICAgICA8QW5hbHl0aWNzIC8+XG4gICAgICAgIC8vICAgICA8L1Nlc3Npb25Qcm92aWRlcj5cbiAgICAgICAgLy8gICApO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgd2FzIGVzcGVjaWFsbHkgYW4gaXNzdWUgZm9yIGNvbXBvbmVudCBzdG9yeWJvYXJkcy4gVGh1cyB0aGUgZGVjaXNpb24gd2FzIG1hZGUgdG8gaGlkZSBhbnkgdG9wLWxldmVsIGNvbXBvbmVudHMgb3IgZGl2c1xuICAgICAgICAvLyB0aGF0IGFyZSBub3QgaW4gdGhlIHN0b3J5Ym9hcmQgZmlsZVxuICAgICAgICBjb25zdCBpbkNvbXBvbmVudFN0b3J5Ym9hcmRBbmRTa2lwID0gc3Rvcnlib2FyZFR5cGUgIT09ICdBUFBMSUNBVElPTicgJiZcbiAgICAgICAgICAgICF1c2VyTmF2aWdhdGVkVG9OZXdSb3V0ZSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRJblN0b3J5Ym9hcmRGb3VuZCAmJlxuICAgICAgICAgICAgIWlzRWxlbWVudERpcmVjdGx5SW5TdG9yeWJvYXJkKG5vZGUpO1xuICAgICAgICAvLyBJZiB0aGlzIG5vZGUgZG9lc24ndCBoYXZlIGEgY29kZWJhc2VJZCwgbW92ZSBpdHMgY2hpbGRyZW4gdG8gaXRzIHBhcmVudFxuICAgICAgICBpZiAoISgoX2EgPSBub2RlLnRlbXBvRWxlbWVudC5jb2RlYmFzZUlkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRzV2l0aCgndGVtcG8tJykpIHx8XG4gICAgICAgICAgICBpbkNvbXBvbmVudFN0b3J5Ym9hcmRBbmRTa2lwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBjaGlsZHJlbiBpbiB0aGUgc3BvdCB3aGVyZSB0aGUgbm9kZSB3YXNcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlblRvTW92ZSA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhPZk5vZGVJblBhcmVudCA9IChfYiA9IG5vZGUucGFyZW50LmNoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXhPZk5vZGVJblBhcmVudCwgMSwgLi4uY2hpbGRyZW5Ub01vdmUpO1xuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgcGFyZW50IG9mIGFsbCB0aGUgY2hpbGRyZW4gdG8gdGhlIG5ldyBwYXJlbnRcbiAgICAgICAgICAgICAgICBjaGlsZHJlblRvTW92ZS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUga25vd24gbm9kZXNcbiAgICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudEtleVRvTmF2Tm9kZVtub2RlLnRlbXBvRWxlbWVudC5nZXRLZXkoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHRvcC1sZXZlbCBub2RlLCBtb3ZlIGl0IGRvd25cbiAgICAgICAgICAgICAgICB0cmVlVG9SZXR1cm4gPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50S2V5VG9OYXZOb2RlW25vZGUudGVtcG9FbGVtZW50LmdldEtleSgpXTtcbiAgICAgICAgICAgICAgICB0cmVlVG9SZXR1cm4ucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAwIGNoaWxkcmVuLCBubyBuYXYgdHJlZSB0byByZXR1cm5cbiAgICAgICAgICAgICAgICB0cmVlVG9SZXR1cm4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcG9FbGVtZW50OiBuZXcgdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50KGV4cG9ydHMuRU1QVFlfVFJFRV9DT0RFQkFTRV9JRCwgc3Rvcnlib2FyZElkLCAnMScpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50S2V5VG9OYXZOb2RlW25vZGUudGVtcG9FbGVtZW50LmdldEtleSgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDIrIGNoaWxkcmVuLCByZXR1cm4gdGhpcyBub2RlLCBidXQgbWFrZSB0aGUgY29kZWJhc2UgSUQgb25lIHRvIHNraXBcbiAgICAgICAgICAgICAgICBub2RlLnRlbXBvRWxlbWVudCA9IG5ldyB0ZW1wb0VsZW1lbnRfMS5UZW1wb0VsZW1lbnQoZXhwb3J0cy5TS0lQX1JPT1RfQ09ERUJBU0VfSUQsIG5vZGUudGVtcG9FbGVtZW50LnN0b3J5Ym9hcmRJZCwgbm9kZS50ZW1wb0VsZW1lbnQudW5pcXVlUGF0aCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRLZXlUb05hdk5vZGVbbm9kZS50ZW1wb0VsZW1lbnQuZ2V0S2V5KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzTm9kZShmaW5pc2hlZE5hdlRyZWUsIGZhbHNlKTtcbiAgICBjb25zdCBwb3N0UHJvY2VzcyA9IChub2RlLCBsZXZlbCkgPT4ge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlYWN0IGZpYmVyIG5vZGUgYWZ0ZXIgcHJvY2Vzc2luZ1xuICAgICAgICBkZWxldGUgbm9kZVsncmVhY3RGaWJlck5vZGUnXTtcbiAgICAgICAgbm9kZS5sZXZlbCA9IGxldmVsO1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBwb3N0UHJvY2VzcyhjaGlsZCwgbm9kZS50ZW1wb0VsZW1lbnQuY29kZWJhc2VJZCA9PT0gZXhwb3J0cy5TS0lQX1JPT1RfQ09ERUJBU0VfSURcbiAgICAgICAgICAgICAgICA/IGxldmVsXG4gICAgICAgICAgICAgICAgOiBsZXZlbCArIDEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHBvc3RQcm9jZXNzKHRyZWVUb1JldHVybiwgMCk7XG4gICAgcmV0dXJuIHRyZWVUb1JldHVybjtcbn07XG5jb25zdCBhZGROYXZUcmVlQnVpbHRDYWxsYmFjayA9IChjYWxsYmFja1RvQWRkKSA9PiB7XG4gICAgY29uc3QgeyBjYWxsYmFja0ZuLCBzdGF0ZSB9ID0gY2FsbGJhY2tUb0FkZDtcbiAgICBjb25zdCBjYWxsYmFja3MgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuTkFWX1RSRUVfQ0FMTEJBQ0tTKSB8fCBbXTtcbiAgICAvLyBTb3J0IHRoZSBtdWx0aVNlbGVjdGVkRWxlbWVudEtleXMgZm9yIGNvbnNpc3RlbmN5IGJlZm9yZSBhZGRpbmdcbiAgICBzdGF0ZS5tdWx0aVNlbGVjdGVkRWxlbWVudEtleXMgPSAoc3RhdGUubXVsdGlTZWxlY3RlZEVsZW1lbnRLZXlzIHx8IFtdKS5zb3J0KCk7XG4gICAgY29uc3QgZXhpc3RpbmdDYWxsYmFjayA9IGNhbGxiYWNrcy5maW5kKChjYWxsYmFjaykgPT4gY2FsbGJhY2suY2FsbGJhY2tGbi50b1N0cmluZygpID09PSBjYWxsYmFja0ZuLnRvU3RyaW5nKCkgJiZcbiAgICAgICAgY2FsbGJhY2suc3RhdGUuc2VsZWN0ZWRFbGVtZW50S2V5ID09PSBzdGF0ZS5zZWxlY3RlZEVsZW1lbnRLZXkgJiZcbiAgICAgICAgY2FsbGJhY2suc3RhdGUubXVsdGlTZWxlY3RlZEVsZW1lbnRLZXlzLmpvaW4oJywnKSA9PT1cbiAgICAgICAgICAgIHN0YXRlLm11bHRpU2VsZWN0ZWRFbGVtZW50S2V5cy5qb2luKCcsJykpO1xuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2tUb0FkZCk7XG4gICAgKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5zZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLk5BVl9UUkVFX0NBTExCQUNLUywgY2FsbGJhY2tzKTtcbn07XG5leHBvcnRzLmFkZE5hdlRyZWVCdWlsdENhbGxiYWNrID0gYWRkTmF2VHJlZUJ1aWx0Q2FsbGJhY2s7XG5jb25zdCBydW5OYXZUcmVlQnVpbHRDYWxsYmFja3MgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLk5BVl9UUkVFX0NBTExCQUNLUykgfHwgW107XG4gICAgaWYgKCFjYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNlbGVjdGVkS2V5ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLlNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICBjb25zdCBtdWx0aVNlbGVjdGVkRWxlbWVudEtleXMgPSAoKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLk1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZUykgfHwgW10pLnNvcnQoKTtcbiAgICBjYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFja0ZuLCBzdGF0ZSB9ID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3RlZEVsZW1lbnRLZXkgPT09IGN1cnJlbnRTZWxlY3RlZEtleSAmJlxuICAgICAgICAgICAgc3RhdGUubXVsdGlTZWxlY3RlZEVsZW1lbnRLZXlzLmpvaW4oJywnKSA9PT1cbiAgICAgICAgICAgICAgICBtdWx0aVNlbGVjdGVkRWxlbWVudEtleXMuam9pbignLCcpKSB7XG4gICAgICAgICAgICBjYWxsYmFja0ZuKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLnJlbW92ZU1lbW9yeVN0b3JhZ2VJdGVtKShzZXNzaW9uU3RvcmFnZVV0aWxzXzEuTkFWX1RSRUVfQ0FMTEJBQ0tTKTtcbn07XG5leHBvcnRzLnJ1bk5hdlRyZWVCdWlsdENhbGxiYWNrcyA9IHJ1bk5hdlRyZWVCdWlsdENhbGxiYWNrcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/navTreeUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/outlineUtils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/outlineUtils.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isNodeOutline = exports.updateOutlines = exports.clearAllOutlines = exports.getOutlineElement = exports.OutlineType = exports.PRIMARY_COMPONENT_OUTLINE_COLOR = exports.SECONDARY_OUTLINE_COLOUR = exports.PRIMARY_OUTLINE_COLOUR = void 0;\nconst identifierUtils_1 = __webpack_require__(/*! ./identifierUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js\");\nconst sessionStorageUtils_1 = __webpack_require__(/*! ./sessionStorageUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js\");\n// @ts-ignore\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\"));\nconst tempoElement_1 = __webpack_require__(/*! ./tempoElement */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js\");\nconst editTextUtils_1 = __webpack_require__(/*! ./editTextUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/editTextUtils.js\");\nconst constantsAndTypes_1 = __webpack_require__(/*! ./constantsAndTypes */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/constantsAndTypes.js\");\nexports.PRIMARY_OUTLINE_COLOUR = '#4597F7';\nexports.SECONDARY_OUTLINE_COLOUR = '#4597F7';\nexports.PRIMARY_COMPONENT_OUTLINE_COLOR = '#6183e4';\nvar OutlineType;\n(function (OutlineType) {\n    OutlineType[OutlineType[\"PRIMARY\"] = 0] = \"PRIMARY\";\n    OutlineType[OutlineType[\"SECONDARY\"] = 1] = \"SECONDARY\";\n    OutlineType[OutlineType[\"CHILD\"] = 2] = \"CHILD\";\n    OutlineType[OutlineType[\"MOVE\"] = 3] = \"MOVE\";\n})(OutlineType || (exports.OutlineType = OutlineType = {}));\n/**\n * Returns a context-based palette of colours to use for the outlines.\n */\nconst colours = () => {\n    const aiContextSelection = (0, sessionStorageUtils_1.getMemoryStorageItem)('aiContext');\n    if (aiContextSelection) {\n        return {\n            primary: '#6858f5',\n            secondary: '#6858f5',\n            component: '#5246C2',\n        };\n    }\n    return {\n        primary: exports.PRIMARY_OUTLINE_COLOUR,\n        secondary: exports.SECONDARY_OUTLINE_COLOUR,\n        component: exports.PRIMARY_COMPONENT_OUTLINE_COLOR,\n    };\n};\nconst getDashedBackgroundImage = (strokeColor, dashWidth, dashGap) => {\n    return `url(\"data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' stroke='${strokeColor.replace('#', '%23')}' stroke-width='${dashWidth}' stroke-dasharray='1%2c ${dashGap}' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e\")`;\n};\nconst capitalizeFirstLetter = (str) => {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nconst getPencilSVG = () => {\n    return `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-pencil\"><path d=\"M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z\"/><path d=\"m15 5 4 4\"/></svg>`;\n};\nconst getEditTextButtonNode = (parentPort, bgColor, elementKey) => {\n    const el = document.createElement('div');\n    const textEl = document.createElement('div');\n    textEl.innerText = 'Edit Dynamic Text';\n    textEl.classList.add(identifierUtils_1.EDIT_TEXT_BUTTON);\n    textEl.classList.add(identifierUtils_1.OUTLINE_CLASS);\n    // First append the pencil SVG\n    const pencilSVG = document.createElement('div');\n    pencilSVG.innerHTML = getPencilSVG();\n    pencilSVG.style.width = '22px';\n    pencilSVG.style.height = '22px';\n    pencilSVG.classList.add(identifierUtils_1.EDIT_TEXT_BUTTON);\n    pencilSVG.classList.add(identifierUtils_1.OUTLINE_CLASS);\n    el.appendChild(pencilSVG);\n    el.appendChild(textEl);\n    el.classList.add(identifierUtils_1.OUTLINE_CLASS);\n    el.classList.add(identifierUtils_1.EDIT_TEXT_BUTTON);\n    el.style.color = 'white';\n    el.style.cursor = 'pointer';\n    el.style.backgroundColor = bgColor;\n    el.style.padding = '4px 12px 4px 12px';\n    el.style.borderRadius = '8px';\n    el.style.fontSize = '20px';\n    el.style.pointerEvents = 'auto';\n    el.style.display = 'flex';\n    el.style.flexDirection = 'row';\n    el.style.alignItems = 'center';\n    el.style.justifyContent = 'center';\n    el.style.gap = '8px';\n    // When clicking, trigger an open in editor action\n    el.addEventListener('pointerdown', (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        parentPort.postMessage({\n            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.EDIT_DYNAMIC_TEXT,\n            elementKey,\n        });\n    });\n    el.addEventListener('pointerup', (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n    });\n    return el;\n};\nconst getOutlineElement = (parentPort, type, pageLeft, pageTop, width, height, selected, tagName, isComponent, elementKey) => {\n    const palette = colours();\n    const left = pageLeft;\n    const top = pageTop;\n    const zoomPerc = (0, sessionStorageUtils_1.getMemoryStorageItem)('zoomPerc');\n    const zoomMultiplier = zoomPerc ? 1 / Number(zoomPerc) : 1;\n    const newElement = document.createElement('div');\n    newElement.classList.add(identifierUtils_1.OUTLINE_CLASS);\n    if (type === OutlineType.CHILD || type === OutlineType.MOVE) {\n        const dashThickness = 5 * zoomMultiplier;\n        newElement.style.backgroundImage = getDashedBackgroundImage(isComponent ? palette.component : palette.primary, Math.max(1, Math.round(dashThickness)), Math.max(3, Math.round(dashThickness * 3)));\n    }\n    else {\n        const thickness = type === OutlineType.SECONDARY\n            ? 0.5 * zoomMultiplier\n            : 1 * zoomMultiplier;\n        if (thickness >= 0.5) {\n            newElement.style.outline = `${thickness}px solid ${type === OutlineType.SECONDARY\n                ? palette.secondary\n                : isComponent\n                    ? palette.component\n                    : palette.primary}`;\n        }\n        newElement.style.border = `${thickness >= 0.5 ? thickness : thickness * 2}px solid ${type === OutlineType.SECONDARY\n            ? palette.secondary\n            : isComponent\n                ? palette.component\n                : palette.primary}`;\n    }\n    newElement.style.position = 'fixed';\n    newElement.style.pointerEvents = 'none';\n    switch (type) {\n        case OutlineType.PRIMARY:\n            newElement.style.zIndex = '2000000002';\n            break;\n        case OutlineType.SECONDARY:\n            newElement.style.zIndex = '2000000001';\n            break;\n        case OutlineType.CHILD:\n            newElement.style.zIndex = '2000000000';\n            break;\n        case OutlineType.MOVE:\n            newElement.style.zIndex = '2000000003';\n            break;\n    }\n    newElement.style.boxSizing = 'border-box';\n    newElement.style.left = left + 'px';\n    newElement.style.top = top + 'px';\n    newElement.style.width = width + 'px';\n    newElement.style.height = height + 'px';\n    newElement.style.cursor = 'default !important';\n    const limitedZoomMultiplier = Math.min(2, zoomMultiplier);\n    if (type === OutlineType.PRIMARY && selected) {\n        // Draw the size of the element underneath\n        const sizeElement = document.createElement('div');\n        newElement.appendChild(sizeElement);\n        sizeElement.classList.add(identifierUtils_1.OUTLINE_CLASS);\n        sizeElement.innerHTML = `${Math.round(width)} x ${Math.round(height)}`;\n        sizeElement.style.color = 'white';\n        sizeElement.style.backgroundColor = isComponent\n            ? palette.component\n            : palette.primary;\n        sizeElement.style.padding = '4px 12px 4px 12px';\n        sizeElement.style.height = '38px';\n        sizeElement.style.borderRadius = '8px';\n        sizeElement.style.position = 'absolute';\n        sizeElement.style.left = `calc(${width}px / 2)`;\n        sizeElement.style.fontSize = '20px';\n        sizeElement.style.whiteSpace = 'nowrap';\n        // After 22 it starts to merge into the border\n        // 52 is the size of the element (38px) + double the size of the gap between the border and the element (7px)\n        const bottomValue = -Math.max(22, 45 + (52 * limitedZoomMultiplier - 52) / 2);\n        sizeElement.style.bottom = `${bottomValue}px`;\n        sizeElement.style.transform = `scale(${limitedZoomMultiplier}) translateX(${-50 / limitedZoomMultiplier}%)`;\n    }\n    if (selected && tagName) {\n        const topControlsWrapper = document.createElement('div');\n        newElement.appendChild(topControlsWrapper);\n        topControlsWrapper.style.display = 'flex';\n        topControlsWrapper.style.width = width / limitedZoomMultiplier + 'px';\n        topControlsWrapper.style.justifyContent = 'space-between';\n        topControlsWrapper.style.flexDirection = 'row';\n        topControlsWrapper.style.gap = '4px';\n        topControlsWrapper.style.position = 'absolute';\n        topControlsWrapper.style.left = `0px`;\n        topControlsWrapper.style.transform = `scale(${limitedZoomMultiplier}) translateX(${50 - 50 / limitedZoomMultiplier}%) translateY(${-70 - 50 / limitedZoomMultiplier}%)`;\n        // Draw the tagname above\n        const tagNameElement = document.createElement('div');\n        topControlsWrapper.appendChild(tagNameElement);\n        tagNameElement.classList.add(identifierUtils_1.OUTLINE_CLASS);\n        tagNameElement.innerHTML = tagName\n            ? isComponent\n                ? capitalizeFirstLetter(tagName)\n                : tagName.toLowerCase()\n            : '';\n        tagNameElement.style.color = 'white';\n        tagNameElement.style.backgroundColor = isComponent\n            ? palette.component\n            : palette.primary;\n        tagNameElement.style.padding = '4px 12px 4px 12px';\n        tagNameElement.style.height = '38px';\n        tagNameElement.style.borderRadius = '8px';\n        tagNameElement.style.fontSize = '20px';\n        // If this node has direct static text inside of it, but is not editable, show the edit text\n        // dynamically button\n        if (type === OutlineType.PRIMARY) {\n            const matchingNode = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKey}`).get(0);\n            const tempoElement = tempoElement_1.TempoElement.fromKey(elementKey || '');\n            if ((0, editTextUtils_1.hasTextContents)(matchingNode) && !(0, editTextUtils_1.canEditText)(tempoElement)) {\n                const newNode = getEditTextButtonNode(parentPort, isComponent ? palette.component : palette.primary, elementKey);\n                topControlsWrapper.appendChild(newNode);\n            }\n        }\n    }\n    // TODO: Add in when we add resizing in the canvas\n    // if (primary && selected) {\n    //   for (let top = 1; top >= 0; top -= 1) {\n    //     for (let left = 1; left >= 0; left -= 1) {\n    //       const cornerElement = document.createElement(\"div\");\n    //       newElement.appendChild(cornerElement);\n    //       cornerElement.classList.add(OUTLINE_CLASS);\n    //       cornerElement.style.position = \"absolute\";\n    //       cornerElement.style.width = Math.max(14 * zoomMultiplier, 1) + \"px\";\n    //       cornerElement.style.height = Math.max(14 * zoomMultiplier, 1) + \"px\";\n    //       cornerElement.style.backgroundColor = \"white\";\n    //       cornerElement.style.cursor = \"pointer\";\n    //       cornerElement.style.zIndex = \"2000000002\";\n    //       if (top) {\n    //         cornerElement.style.top = Math.min(-7 * zoomMultiplier, -0.5) + \"px\";\n    //       } else {\n    //         cornerElement.style.bottom = Math.min(-7 * zoomMultiplier, -0.5) + \"px\";\n    //       }\n    //       if (left) {\n    //         cornerElement.style.left = Math.min(-8 * zoomMultiplier, -0.5) + \"px\";\n    //       } else {\n    //         cornerElement.style.right = Math.min(-8 * zoomMultiplier, -0.5) + \"px\";\n    //       }\n    //       cornerElement.style.outline = 2 * zoomMultiplier + \"px solid \" + PRIMARY_OUTLINE_COLOUR;\n    //       cornerElement.style.pointerEvents = \"auto\";\n    //     }\n    //   }\n    // }\n    return newElement;\n};\nexports.getOutlineElement = getOutlineElement;\nconst clearAllOutlines = () => {\n    (0, jquery_1.default)(`.${identifierUtils_1.OUTLINE_CLASS}`).remove();\n};\nexports.clearAllOutlines = clearAllOutlines;\n/**\n * Creates all the necessary outlines for the hovered and selected elements\n * @returns\n */\nconst updateOutlines = (parentPort, storyboardId) => {\n    (0, exports.clearAllOutlines)();\n    const driveModeEnabled = !!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId);\n    if (driveModeEnabled) {\n        return;\n    }\n    const hoveredElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);\n    const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);\n    const multiselectedElementKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);\n    const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);\n    const body = document.getElementsByTagName('body')[0];\n    const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};\n    const getBoundingBoxForElementKey = (elementKey) => {\n        var _a, _b;\n        const navNode = elementKeyToNavNode[elementKey];\n        // Try to get the bounding box directly from the DOM, but fall back to the one cached\n        // at Nav Tree build time\n        const boundingBoxToUse = (_b = (_a = (0, jquery_1.default)('body')\n            .find(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKey}`)\n            .get(0)) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (boundingBoxToUse) {\n            return {\n                left: boundingBoxToUse.left,\n                top: boundingBoxToUse.top,\n                width: boundingBoxToUse.width,\n                height: boundingBoxToUse.height,\n            };\n        }\n        if (navNode === null || navNode === void 0 ? void 0 : navNode.pageBoundingBox) {\n            return {\n                left: navNode.pageBoundingBox.pageX,\n                top: navNode.pageBoundingBox.pageY,\n                width: navNode.pageBoundingBox.width,\n                height: navNode.pageBoundingBox.height,\n            };\n        }\n        return null;\n    };\n    const createOutlinesForElementKey = (elementKey, selected, isChild, outlineChildren) => {\n        var _a, _b;\n        const navNode = elementKeyToNavNode[elementKey];\n        if (!navNode) {\n            return;\n        }\n        const tagNameToUse = navNode === null || navNode === void 0 ? void 0 : navNode.name;\n        const boundingBox = getBoundingBoxForElementKey(elementKey);\n        if (boundingBox) {\n            body.appendChild((0, exports.getOutlineElement)(parentPort, isChild ? OutlineType.CHILD : OutlineType.PRIMARY, boundingBox.left, boundingBox.top, boundingBox.width, boundingBox.height, selected, tagNameToUse, navNode === null || navNode === void 0 ? void 0 : navNode.isComponent, elementKey));\n            const mouseDragData = (0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext');\n            const mousePosData = (0, sessionStorageUtils_1.getMemoryStorageItem)('mousePos');\n            if (selected && (mouseDragData === null || mouseDragData === void 0 ? void 0 : mouseDragData.dragging) && mousePosData) {\n                body.appendChild((0, exports.getOutlineElement)(parentPort, OutlineType.MOVE, mousePosData.pageX - boundingBox.width / 2 + mouseDragData.offsetX, mousePosData.pageY - boundingBox.height / 2 + mouseDragData.offsetY, boundingBox.width, boundingBox.height, undefined, undefined, navNode === null || navNode === void 0 ? void 0 : navNode.isComponent, elementKey));\n            }\n        }\n        if (outlineChildren) {\n            (_b = (_a = navNode === null || navNode === void 0 ? void 0 : navNode.children) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, (child) => {\n                createOutlinesForElementKey(child.tempoElement.getKey(), false, true, false);\n            });\n        }\n    };\n    if (hoveredElementKey) {\n        createOutlinesForElementKey(hoveredElementKey, false, false, true);\n    }\n    if (multiselectedElementKeys === null || multiselectedElementKeys === void 0 ? void 0 : multiselectedElementKeys.length) {\n        let fullBoundingBox = getBoundingBoxForElementKey(multiselectedElementKeys[0]);\n        multiselectedElementKeys.slice(1).forEach((elementKey) => {\n            const boundingRect = getBoundingBoxForElementKey(elementKey);\n            if (boundingRect) {\n                if (fullBoundingBox) {\n                    const prevRight = fullBoundingBox.left + fullBoundingBox.width;\n                    const prevBottom = fullBoundingBox.top + fullBoundingBox.height;\n                    fullBoundingBox.left = Math.min(fullBoundingBox.left, boundingRect.left);\n                    fullBoundingBox.top = Math.min(fullBoundingBox.top, boundingRect.top);\n                    const right = Math.max(prevRight, boundingRect.left + boundingRect.width);\n                    const bottom = Math.max(prevBottom, boundingRect.top + boundingRect.height);\n                    fullBoundingBox.width = right - fullBoundingBox.left;\n                    fullBoundingBox.height = bottom - fullBoundingBox.top;\n                }\n                else {\n                    fullBoundingBox = boundingRect;\n                }\n            }\n        });\n        if (fullBoundingBox) {\n            body.appendChild((0, exports.getOutlineElement)(parentPort, OutlineType.PRIMARY, fullBoundingBox.left, fullBoundingBox.top, fullBoundingBox.width, fullBoundingBox.height, true, `${multiselectedElementKeys.length} Elements`, false));\n        }\n        multiselectedElementKeys.forEach((elementKey) => {\n            createOutlinesForElementKey(elementKey, false, false, false);\n        });\n    }\n    else if (selectedElementKey) {\n        createOutlinesForElementKey(selectedElementKey, true, false, false);\n    }\n    // Create outlines\n    (0, jquery_1.default)(`.${identifierUtils_1.TEMPO_INSTANT_DIV_DRAW_CLASS}`).each((index, item) => {\n        const boundingRect = item.getBoundingClientRect();\n        body.appendChild((0, exports.getOutlineElement)(parentPort, OutlineType.PRIMARY, boundingRect.left, boundingRect.top, boundingRect.width, boundingRect.height));\n    });\n    (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_OUTLINE_UNTIL_REFESH}=true]`).each((index, item) => {\n        const boundingRect = item.getBoundingClientRect();\n        body.appendChild((0, exports.getOutlineElement)(parentPort, OutlineType.PRIMARY, boundingRect.left, boundingRect.top, boundingRect.width, boundingRect.height));\n    });\n    // Create secondary outlines for all matching IDs in the codebase for the clicked element\n    if (selectedElement === null || selectedElement === void 0 ? void 0 : selectedElement.codebaseId) {\n        (0, jquery_1.default)('body')\n            .find(`.${selectedElement === null || selectedElement === void 0 ? void 0 : selectedElement.codebaseId}`)\n            .not(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${selectedElementKey}`)\n            .not(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${hoveredElementKey}`)\n            .each((index, item) => {\n            const boundingRect = item.getBoundingClientRect();\n            body.appendChild((0, exports.getOutlineElement)(parentPort, OutlineType.SECONDARY, boundingRect.left, boundingRect.top, boundingRect.width, boundingRect.height));\n        });\n    }\n};\nexports.updateOutlines = updateOutlines;\nconst isNodeOutline = (node) => {\n    if (!(node === null || node === void 0 ? void 0 : node.classList)) {\n        return false;\n    }\n    let isOutline = false;\n    node.classList.forEach((cls) => {\n        if (cls === identifierUtils_1.OUTLINE_CLASS) {\n            isOutline = true;\n        }\n    });\n    return isOutline;\n};\nexports.isNodeOutline = isNodeOutline;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL291dGxpbmVVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLG1CQUFtQixHQUFHLHVDQUF1QyxHQUFHLGdDQUFnQyxHQUFHLDhCQUE4QjtBQUN6TywwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBbUI7QUFDckQsOEJBQThCLG1CQUFPLENBQUMsK0dBQXVCO0FBQzdEO0FBQ0EsaUNBQWlDLG1CQUFPLENBQUMsMERBQVE7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLG1HQUFpQjtBQUNqRCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBcUI7QUFDekQsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0IsbUJBQW1CLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRLQUE0SyxnQ0FBZ0Msa0JBQWtCLFVBQVUsMkJBQTJCLFFBQVE7QUFDM1E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVLFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EscUNBQXFDLDZDQUE2QyxXQUFXO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQixJQUFJLG1CQUFtQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xELCtDQUErQyxzQkFBc0IsZUFBZSw0QkFBNEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0IsZUFBZSxnQ0FBZ0MsZ0JBQWdCLGlDQUFpQztBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFDQUFxQyxFQUFFLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckMsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSw4QkFBOEIsZ0NBQWdDO0FBQzlEO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQyxFQUFFLFdBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnTUFBZ00saUNBQWlDO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUErQztBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkZBQTZGO0FBQ25ILHFCQUFxQixxQ0FBcUMsRUFBRSxtQkFBbUI7QUFDL0UscUJBQXFCLHFDQUFxQyxFQUFFLGtCQUFrQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHRlbXBvLWRldnRvb2xzXFxkaXN0XFxjaGFubmVsTWVzc2FnaW5nXFxvdXRsaW5lVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzTm9kZU91dGxpbmUgPSBleHBvcnRzLnVwZGF0ZU91dGxpbmVzID0gZXhwb3J0cy5jbGVhckFsbE91dGxpbmVzID0gZXhwb3J0cy5nZXRPdXRsaW5lRWxlbWVudCA9IGV4cG9ydHMuT3V0bGluZVR5cGUgPSBleHBvcnRzLlBSSU1BUllfQ09NUE9ORU5UX09VVExJTkVfQ09MT1IgPSBleHBvcnRzLlNFQ09OREFSWV9PVVRMSU5FX0NPTE9VUiA9IGV4cG9ydHMuUFJJTUFSWV9PVVRMSU5FX0NPTE9VUiA9IHZvaWQgMDtcbmNvbnN0IGlkZW50aWZpZXJVdGlsc18xID0gcmVxdWlyZShcIi4vaWRlbnRpZmllclV0aWxzXCIpO1xuY29uc3Qgc2Vzc2lvblN0b3JhZ2VVdGlsc18xID0gcmVxdWlyZShcIi4vc2Vzc2lvblN0b3JhZ2VVdGlsc1wiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGpxdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuY29uc3QgdGVtcG9FbGVtZW50XzEgPSByZXF1aXJlKFwiLi90ZW1wb0VsZW1lbnRcIik7XG5jb25zdCBlZGl0VGV4dFV0aWxzXzEgPSByZXF1aXJlKFwiLi9lZGl0VGV4dFV0aWxzXCIpO1xuY29uc3QgY29uc3RhbnRzQW5kVHlwZXNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c0FuZFR5cGVzXCIpO1xuZXhwb3J0cy5QUklNQVJZX09VVExJTkVfQ09MT1VSID0gJyM0NTk3RjcnO1xuZXhwb3J0cy5TRUNPTkRBUllfT1VUTElORV9DT0xPVVIgPSAnIzQ1OTdGNyc7XG5leHBvcnRzLlBSSU1BUllfQ09NUE9ORU5UX09VVExJTkVfQ09MT1IgPSAnIzYxODNlNCc7XG52YXIgT3V0bGluZVR5cGU7XG4oZnVuY3Rpb24gKE91dGxpbmVUeXBlKSB7XG4gICAgT3V0bGluZVR5cGVbT3V0bGluZVR5cGVbXCJQUklNQVJZXCJdID0gMF0gPSBcIlBSSU1BUllcIjtcbiAgICBPdXRsaW5lVHlwZVtPdXRsaW5lVHlwZVtcIlNFQ09OREFSWVwiXSA9IDFdID0gXCJTRUNPTkRBUllcIjtcbiAgICBPdXRsaW5lVHlwZVtPdXRsaW5lVHlwZVtcIkNISUxEXCJdID0gMl0gPSBcIkNISUxEXCI7XG4gICAgT3V0bGluZVR5cGVbT3V0bGluZVR5cGVbXCJNT1ZFXCJdID0gM10gPSBcIk1PVkVcIjtcbn0pKE91dGxpbmVUeXBlIHx8IChleHBvcnRzLk91dGxpbmVUeXBlID0gT3V0bGluZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBSZXR1cm5zIGEgY29udGV4dC1iYXNlZCBwYWxldHRlIG9mIGNvbG91cnMgdG8gdXNlIGZvciB0aGUgb3V0bGluZXMuXG4gKi9cbmNvbnN0IGNvbG91cnMgPSAoKSA9PiB7XG4gICAgY29uc3QgYWlDb250ZXh0U2VsZWN0aW9uID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoJ2FpQ29udGV4dCcpO1xuICAgIGlmIChhaUNvbnRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByaW1hcnk6ICcjNjg1OGY1JyxcbiAgICAgICAgICAgIHNlY29uZGFyeTogJyM2ODU4ZjUnLFxuICAgICAgICAgICAgY29tcG9uZW50OiAnIzUyNDZDMicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByaW1hcnk6IGV4cG9ydHMuUFJJTUFSWV9PVVRMSU5FX0NPTE9VUixcbiAgICAgICAgc2Vjb25kYXJ5OiBleHBvcnRzLlNFQ09OREFSWV9PVVRMSU5FX0NPTE9VUixcbiAgICAgICAgY29tcG9uZW50OiBleHBvcnRzLlBSSU1BUllfQ09NUE9ORU5UX09VVExJTkVfQ09MT1IsXG4gICAgfTtcbn07XG5jb25zdCBnZXREYXNoZWRCYWNrZ3JvdW5kSW1hZ2UgPSAoc3Ryb2tlQ29sb3IsIGRhc2hXaWR0aCwgZGFzaEdhcCkgPT4ge1xuICAgIHJldHVybiBgdXJsKFwiZGF0YTppbWFnZS9zdmcreG1sLCUzY3N2ZyB3aWR0aD0nMTAwJTI1JyBoZWlnaHQ9JzEwMCUyNScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyUzZSUzY3JlY3Qgd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnIGZpbGw9J25vbmUnIHN0cm9rZT0nJHtzdHJva2VDb2xvci5yZXBsYWNlKCcjJywgJyUyMycpfScgc3Ryb2tlLXdpZHRoPScke2Rhc2hXaWR0aH0nIHN0cm9rZS1kYXNoYXJyYXk9JzElMmMgJHtkYXNoR2FwfScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAnIHN0cm9rZS1saW5lY2FwPSdzcXVhcmUnLyUzZSUzYy9zdmclM2VcIilgO1xufTtcbmNvbnN0IGNhcGl0YWxpemVGaXJzdExldHRlciA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcbmNvbnN0IGdldFBlbmNpbFNWRyA9ICgpID0+IHtcbiAgICByZXR1cm4gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBjbGFzcz1cImx1Y2lkZSBsdWNpZGUtcGVuY2lsXCI+PHBhdGggZD1cIk0xNyAzYTIuODUgMi44MyAwIDEgMSA0IDRMNy41IDIwLjUgMiAyMmwxLjUtNS41WlwiLz48cGF0aCBkPVwibTE1IDUgNCA0XCIvPjwvc3ZnPmA7XG59O1xuY29uc3QgZ2V0RWRpdFRleHRCdXR0b25Ob2RlID0gKHBhcmVudFBvcnQsIGJnQ29sb3IsIGVsZW1lbnRLZXkpID0+IHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRleHRFbC5pbm5lclRleHQgPSAnRWRpdCBEeW5hbWljIFRleHQnO1xuICAgIHRleHRFbC5jbGFzc0xpc3QuYWRkKGlkZW50aWZpZXJVdGlsc18xLkVESVRfVEVYVF9CVVRUT04pO1xuICAgIHRleHRFbC5jbGFzc0xpc3QuYWRkKGlkZW50aWZpZXJVdGlsc18xLk9VVExJTkVfQ0xBU1MpO1xuICAgIC8vIEZpcnN0IGFwcGVuZCB0aGUgcGVuY2lsIFNWR1xuICAgIGNvbnN0IHBlbmNpbFNWRyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHBlbmNpbFNWRy5pbm5lckhUTUwgPSBnZXRQZW5jaWxTVkcoKTtcbiAgICBwZW5jaWxTVkcuc3R5bGUud2lkdGggPSAnMjJweCc7XG4gICAgcGVuY2lsU1ZHLnN0eWxlLmhlaWdodCA9ICcyMnB4JztcbiAgICBwZW5jaWxTVkcuY2xhc3NMaXN0LmFkZChpZGVudGlmaWVyVXRpbHNfMS5FRElUX1RFWFRfQlVUVE9OKTtcbiAgICBwZW5jaWxTVkcuY2xhc3NMaXN0LmFkZChpZGVudGlmaWVyVXRpbHNfMS5PVVRMSU5FX0NMQVNTKTtcbiAgICBlbC5hcHBlbmRDaGlsZChwZW5jaWxTVkcpO1xuICAgIGVsLmFwcGVuZENoaWxkKHRleHRFbCk7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChpZGVudGlmaWVyVXRpbHNfMS5PVVRMSU5FX0NMQVNTKTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGlkZW50aWZpZXJVdGlsc18xLkVESVRfVEVYVF9CVVRUT04pO1xuICAgIGVsLnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICBlbC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYmdDb2xvcjtcbiAgICBlbC5zdHlsZS5wYWRkaW5nID0gJzRweCAxMnB4IDRweCAxMnB4JztcbiAgICBlbC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnOHB4JztcbiAgICBlbC5zdHlsZS5mb250U2l6ZSA9ICcyMHB4JztcbiAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgZWwuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdyb3cnO1xuICAgIGVsLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcbiAgICBlbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdjZW50ZXInO1xuICAgIGVsLnN0eWxlLmdhcCA9ICc4cHgnO1xuICAgIC8vIFdoZW4gY2xpY2tpbmcsIHRyaWdnZXIgYW4gb3BlbiBpbiBlZGl0b3IgYWN0aW9uXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IGNvbnN0YW50c0FuZFR5cGVzXzEuRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkVESVRfRFlOQU1JQ19URVhULFxuICAgICAgICAgICAgZWxlbWVudEtleSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICAgIHJldHVybiBlbDtcbn07XG5jb25zdCBnZXRPdXRsaW5lRWxlbWVudCA9IChwYXJlbnRQb3J0LCB0eXBlLCBwYWdlTGVmdCwgcGFnZVRvcCwgd2lkdGgsIGhlaWdodCwgc2VsZWN0ZWQsIHRhZ05hbWUsIGlzQ29tcG9uZW50LCBlbGVtZW50S2V5KSA9PiB7XG4gICAgY29uc3QgcGFsZXR0ZSA9IGNvbG91cnMoKTtcbiAgICBjb25zdCBsZWZ0ID0gcGFnZUxlZnQ7XG4gICAgY29uc3QgdG9wID0gcGFnZVRvcDtcbiAgICBjb25zdCB6b29tUGVyYyA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKCd6b29tUGVyYycpO1xuICAgIGNvbnN0IHpvb21NdWx0aXBsaWVyID0gem9vbVBlcmMgPyAxIC8gTnVtYmVyKHpvb21QZXJjKSA6IDE7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChpZGVudGlmaWVyVXRpbHNfMS5PVVRMSU5FX0NMQVNTKTtcbiAgICBpZiAodHlwZSA9PT0gT3V0bGluZVR5cGUuQ0hJTEQgfHwgdHlwZSA9PT0gT3V0bGluZVR5cGUuTU9WRSkge1xuICAgICAgICBjb25zdCBkYXNoVGhpY2tuZXNzID0gNSAqIHpvb21NdWx0aXBsaWVyO1xuICAgICAgICBuZXdFbGVtZW50LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGdldERhc2hlZEJhY2tncm91bmRJbWFnZShpc0NvbXBvbmVudCA/IHBhbGV0dGUuY29tcG9uZW50IDogcGFsZXR0ZS5wcmltYXJ5LCBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGRhc2hUaGlja25lc3MpKSwgTWF0aC5tYXgoMywgTWF0aC5yb3VuZChkYXNoVGhpY2tuZXNzICogMykpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRoaWNrbmVzcyA9IHR5cGUgPT09IE91dGxpbmVUeXBlLlNFQ09OREFSWVxuICAgICAgICAgICAgPyAwLjUgKiB6b29tTXVsdGlwbGllclxuICAgICAgICAgICAgOiAxICogem9vbU11bHRpcGxpZXI7XG4gICAgICAgIGlmICh0aGlja25lc3MgPj0gMC41KSB7XG4gICAgICAgICAgICBuZXdFbGVtZW50LnN0eWxlLm91dGxpbmUgPSBgJHt0aGlja25lc3N9cHggc29saWQgJHt0eXBlID09PSBPdXRsaW5lVHlwZS5TRUNPTkRBUllcbiAgICAgICAgICAgICAgICA/IHBhbGV0dGUuc2Vjb25kYXJ5XG4gICAgICAgICAgICAgICAgOiBpc0NvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IHBhbGV0dGUuY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIDogcGFsZXR0ZS5wcmltYXJ5fWA7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RWxlbWVudC5zdHlsZS5ib3JkZXIgPSBgJHt0aGlja25lc3MgPj0gMC41ID8gdGhpY2tuZXNzIDogdGhpY2tuZXNzICogMn1weCBzb2xpZCAke3R5cGUgPT09IE91dGxpbmVUeXBlLlNFQ09OREFSWVxuICAgICAgICAgICAgPyBwYWxldHRlLnNlY29uZGFyeVxuICAgICAgICAgICAgOiBpc0NvbXBvbmVudFxuICAgICAgICAgICAgICAgID8gcGFsZXR0ZS5jb21wb25lbnRcbiAgICAgICAgICAgICAgICA6IHBhbGV0dGUucHJpbWFyeX1gO1xuICAgIH1cbiAgICBuZXdFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBuZXdFbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgT3V0bGluZVR5cGUuUFJJTUFSWTpcbiAgICAgICAgICAgIG5ld0VsZW1lbnQuc3R5bGUuekluZGV4ID0gJzIwMDAwMDAwMDInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT3V0bGluZVR5cGUuU0VDT05EQVJZOlxuICAgICAgICAgICAgbmV3RWxlbWVudC5zdHlsZS56SW5kZXggPSAnMjAwMDAwMDAwMSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPdXRsaW5lVHlwZS5DSElMRDpcbiAgICAgICAgICAgIG5ld0VsZW1lbnQuc3R5bGUuekluZGV4ID0gJzIwMDAwMDAwMDAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT3V0bGluZVR5cGUuTU9WRTpcbiAgICAgICAgICAgIG5ld0VsZW1lbnQuc3R5bGUuekluZGV4ID0gJzIwMDAwMDAwMDMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5ld0VsZW1lbnQuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgIG5ld0VsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgIG5ld0VsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICBuZXdFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIG5ld0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBuZXdFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0ICFpbXBvcnRhbnQnO1xuICAgIGNvbnN0IGxpbWl0ZWRab29tTXVsdGlwbGllciA9IE1hdGgubWluKDIsIHpvb21NdWx0aXBsaWVyKTtcbiAgICBpZiAodHlwZSA9PT0gT3V0bGluZVR5cGUuUFJJTUFSWSAmJiBzZWxlY3RlZCkge1xuICAgICAgICAvLyBEcmF3IHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IHVuZGVybmVhdGhcbiAgICAgICAgY29uc3Qgc2l6ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbmV3RWxlbWVudC5hcHBlbmRDaGlsZChzaXplRWxlbWVudCk7XG4gICAgICAgIHNpemVFbGVtZW50LmNsYXNzTGlzdC5hZGQoaWRlbnRpZmllclV0aWxzXzEuT1VUTElORV9DTEFTUyk7XG4gICAgICAgIHNpemVFbGVtZW50LmlubmVySFRNTCA9IGAke01hdGgucm91bmQod2lkdGgpfSB4ICR7TWF0aC5yb3VuZChoZWlnaHQpfWA7XG4gICAgICAgIHNpemVFbGVtZW50LnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgc2l6ZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaXNDb21wb25lbnRcbiAgICAgICAgICAgID8gcGFsZXR0ZS5jb21wb25lbnRcbiAgICAgICAgICAgIDogcGFsZXR0ZS5wcmltYXJ5O1xuICAgICAgICBzaXplRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzRweCAxMnB4IDRweCAxMnB4JztcbiAgICAgICAgc2l6ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzM4cHgnO1xuICAgICAgICBzaXplRWxlbWVudC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnOHB4JztcbiAgICAgICAgc2l6ZUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBzaXplRWxlbWVudC5zdHlsZS5sZWZ0ID0gYGNhbGMoJHt3aWR0aH1weCAvIDIpYDtcbiAgICAgICAgc2l6ZUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnMjBweCc7XG4gICAgICAgIHNpemVFbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcbiAgICAgICAgLy8gQWZ0ZXIgMjIgaXQgc3RhcnRzIHRvIG1lcmdlIGludG8gdGhlIGJvcmRlclxuICAgICAgICAvLyA1MiBpcyB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudCAoMzhweCkgKyBkb3VibGUgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIHRoZSBib3JkZXIgYW5kIHRoZSBlbGVtZW50ICg3cHgpXG4gICAgICAgIGNvbnN0IGJvdHRvbVZhbHVlID0gLU1hdGgubWF4KDIyLCA0NSArICg1MiAqIGxpbWl0ZWRab29tTXVsdGlwbGllciAtIDUyKSAvIDIpO1xuICAgICAgICBzaXplRWxlbWVudC5zdHlsZS5ib3R0b20gPSBgJHtib3R0b21WYWx1ZX1weGA7XG4gICAgICAgIHNpemVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke2xpbWl0ZWRab29tTXVsdGlwbGllcn0pIHRyYW5zbGF0ZVgoJHstNTAgLyBsaW1pdGVkWm9vbU11bHRpcGxpZXJ9JSlgO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWQgJiYgdGFnTmFtZSkge1xuICAgICAgICBjb25zdCB0b3BDb250cm9sc1dyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbmV3RWxlbWVudC5hcHBlbmRDaGlsZCh0b3BDb250cm9sc1dyYXBwZXIpO1xuICAgICAgICB0b3BDb250cm9sc1dyYXBwZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgdG9wQ29udHJvbHNXcmFwcGVyLnN0eWxlLndpZHRoID0gd2lkdGggLyBsaW1pdGVkWm9vbU11bHRpcGxpZXIgKyAncHgnO1xuICAgICAgICB0b3BDb250cm9sc1dyYXBwZXIuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnc3BhY2UtYmV0d2Vlbic7XG4gICAgICAgIHRvcENvbnRyb2xzV3JhcHBlci5zdHlsZS5mbGV4RGlyZWN0aW9uID0gJ3Jvdyc7XG4gICAgICAgIHRvcENvbnRyb2xzV3JhcHBlci5zdHlsZS5nYXAgPSAnNHB4JztcbiAgICAgICAgdG9wQ29udHJvbHNXcmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdG9wQ29udHJvbHNXcmFwcGVyLnN0eWxlLmxlZnQgPSBgMHB4YDtcbiAgICAgICAgdG9wQ29udHJvbHNXcmFwcGVyLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke2xpbWl0ZWRab29tTXVsdGlwbGllcn0pIHRyYW5zbGF0ZVgoJHs1MCAtIDUwIC8gbGltaXRlZFpvb21NdWx0aXBsaWVyfSUpIHRyYW5zbGF0ZVkoJHstNzAgLSA1MCAvIGxpbWl0ZWRab29tTXVsdGlwbGllcn0lKWA7XG4gICAgICAgIC8vIERyYXcgdGhlIHRhZ25hbWUgYWJvdmVcbiAgICAgICAgY29uc3QgdGFnTmFtZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9wQ29udHJvbHNXcmFwcGVyLmFwcGVuZENoaWxkKHRhZ05hbWVFbGVtZW50KTtcbiAgICAgICAgdGFnTmFtZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChpZGVudGlmaWVyVXRpbHNfMS5PVVRMSU5FX0NMQVNTKTtcbiAgICAgICAgdGFnTmFtZUVsZW1lbnQuaW5uZXJIVE1MID0gdGFnTmFtZVxuICAgICAgICAgICAgPyBpc0NvbXBvbmVudFxuICAgICAgICAgICAgICAgID8gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHRhZ05hbWUpXG4gICAgICAgICAgICAgICAgOiB0YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIHRhZ05hbWVFbGVtZW50LnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgdGFnTmFtZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaXNDb21wb25lbnRcbiAgICAgICAgICAgID8gcGFsZXR0ZS5jb21wb25lbnRcbiAgICAgICAgICAgIDogcGFsZXR0ZS5wcmltYXJ5O1xuICAgICAgICB0YWdOYW1lRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzRweCAxMnB4IDRweCAxMnB4JztcbiAgICAgICAgdGFnTmFtZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzM4cHgnO1xuICAgICAgICB0YWdOYW1lRWxlbWVudC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnOHB4JztcbiAgICAgICAgdGFnTmFtZUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnMjBweCc7XG4gICAgICAgIC8vIElmIHRoaXMgbm9kZSBoYXMgZGlyZWN0IHN0YXRpYyB0ZXh0IGluc2lkZSBvZiBpdCwgYnV0IGlzIG5vdCBlZGl0YWJsZSwgc2hvdyB0aGUgZWRpdCB0ZXh0XG4gICAgICAgIC8vIGR5bmFtaWNhbGx5IGJ1dHRvblxuICAgICAgICBpZiAodHlwZSA9PT0gT3V0bGluZVR5cGUuUFJJTUFSWSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdOb2RlID0gKDAsIGpxdWVyeV8xLmRlZmF1bHQpKGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtlbGVtZW50S2V5fWApLmdldCgwKTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBvRWxlbWVudCA9IHRlbXBvRWxlbWVudF8xLlRlbXBvRWxlbWVudC5mcm9tS2V5KGVsZW1lbnRLZXkgfHwgJycpO1xuICAgICAgICAgICAgaWYgKCgwLCBlZGl0VGV4dFV0aWxzXzEuaGFzVGV4dENvbnRlbnRzKShtYXRjaGluZ05vZGUpICYmICEoMCwgZWRpdFRleHRVdGlsc18xLmNhbkVkaXRUZXh0KSh0ZW1wb0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGdldEVkaXRUZXh0QnV0dG9uTm9kZShwYXJlbnRQb3J0LCBpc0NvbXBvbmVudCA/IHBhbGV0dGUuY29tcG9uZW50IDogcGFsZXR0ZS5wcmltYXJ5LCBlbGVtZW50S2V5KTtcbiAgICAgICAgICAgICAgICB0b3BDb250cm9sc1dyYXBwZXIuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETzogQWRkIGluIHdoZW4gd2UgYWRkIHJlc2l6aW5nIGluIHRoZSBjYW52YXNcbiAgICAvLyBpZiAocHJpbWFyeSAmJiBzZWxlY3RlZCkge1xuICAgIC8vICAgZm9yIChsZXQgdG9wID0gMTsgdG9wID49IDA7IHRvcCAtPSAxKSB7XG4gICAgLy8gICAgIGZvciAobGV0IGxlZnQgPSAxOyBsZWZ0ID49IDA7IGxlZnQgLT0gMSkge1xuICAgIC8vICAgICAgIGNvbnN0IGNvcm5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIC8vICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQoY29ybmVyRWxlbWVudCk7XG4gICAgLy8gICAgICAgY29ybmVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKE9VVExJTkVfQ0xBU1MpO1xuICAgIC8vICAgICAgIGNvcm5lckVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgLy8gICAgICAgY29ybmVyRWxlbWVudC5zdHlsZS53aWR0aCA9IE1hdGgubWF4KDE0ICogem9vbU11bHRpcGxpZXIsIDEpICsgXCJweFwiO1xuICAgIC8vICAgICAgIGNvcm5lckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMTQgKiB6b29tTXVsdGlwbGllciwgMSkgKyBcInB4XCI7XG4gICAgLy8gICAgICAgY29ybmVyRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIndoaXRlXCI7XG4gICAgLy8gICAgICAgY29ybmVyRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAvLyAgICAgICBjb3JuZXJFbGVtZW50LnN0eWxlLnpJbmRleCA9IFwiMjAwMDAwMDAwMlwiO1xuICAgIC8vICAgICAgIGlmICh0b3ApIHtcbiAgICAvLyAgICAgICAgIGNvcm5lckVsZW1lbnQuc3R5bGUudG9wID0gTWF0aC5taW4oLTcgKiB6b29tTXVsdGlwbGllciwgLTAuNSkgKyBcInB4XCI7XG4gICAgLy8gICAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgIGNvcm5lckVsZW1lbnQuc3R5bGUuYm90dG9tID0gTWF0aC5taW4oLTcgKiB6b29tTXVsdGlwbGllciwgLTAuNSkgKyBcInB4XCI7XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIGlmIChsZWZ0KSB7XG4gICAgLy8gICAgICAgICBjb3JuZXJFbGVtZW50LnN0eWxlLmxlZnQgPSBNYXRoLm1pbigtOCAqIHpvb21NdWx0aXBsaWVyLCAtMC41KSArIFwicHhcIjtcbiAgICAvLyAgICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgY29ybmVyRWxlbWVudC5zdHlsZS5yaWdodCA9IE1hdGgubWluKC04ICogem9vbU11bHRpcGxpZXIsIC0wLjUpICsgXCJweFwiO1xuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgICBjb3JuZXJFbGVtZW50LnN0eWxlLm91dGxpbmUgPSAyICogem9vbU11bHRpcGxpZXIgKyBcInB4IHNvbGlkIFwiICsgUFJJTUFSWV9PVVRMSU5FX0NPTE9VUjtcbiAgICAvLyAgICAgICBjb3JuZXJFbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5leHBvcnRzLmdldE91dGxpbmVFbGVtZW50ID0gZ2V0T3V0bGluZUVsZW1lbnQ7XG5jb25zdCBjbGVhckFsbE91dGxpbmVzID0gKCkgPT4ge1xuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgLiR7aWRlbnRpZmllclV0aWxzXzEuT1VUTElORV9DTEFTU31gKS5yZW1vdmUoKTtcbn07XG5leHBvcnRzLmNsZWFyQWxsT3V0bGluZXMgPSBjbGVhckFsbE91dGxpbmVzO1xuLyoqXG4gKiBDcmVhdGVzIGFsbCB0aGUgbmVjZXNzYXJ5IG91dGxpbmVzIGZvciB0aGUgaG92ZXJlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IHVwZGF0ZU91dGxpbmVzID0gKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgICgwLCBleHBvcnRzLmNsZWFyQWxsT3V0bGluZXMpKCk7XG4gICAgY29uc3QgZHJpdmVNb2RlRW5hYmxlZCA9ICEhKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRTZXNzaW9uU3RvcmFnZUl0ZW0pKCdkcml2ZU1vZGVFbmFibGVkJywgc3Rvcnlib2FyZElkKTtcbiAgICBpZiAoZHJpdmVNb2RlRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyZWRFbGVtZW50S2V5ID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkhPVkVSRURfRUxFTUVOVF9LRVkpO1xuICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudEtleSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKHNlc3Npb25TdG9yYWdlVXRpbHNfMS5TRUxFQ1RFRF9FTEVNRU5UX0tFWSk7XG4gICAgY29uc3QgbXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLk1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZUyk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gdGVtcG9FbGVtZW50XzEuVGVtcG9FbGVtZW50LmZyb21LZXkoc2VsZWN0ZWRFbGVtZW50S2V5KTtcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICBjb25zdCBlbGVtZW50S2V5VG9OYXZOb2RlID0gKDAsIHNlc3Npb25TdG9yYWdlVXRpbHNfMS5nZXRNZW1vcnlTdG9yYWdlSXRlbSkoc2Vzc2lvblN0b3JhZ2VVdGlsc18xLkVMRU1FTlRfS0VZX1RPX05BVl9OT0RFKSB8fCB7fTtcbiAgICBjb25zdCBnZXRCb3VuZGluZ0JveEZvckVsZW1lbnRLZXkgPSAoZWxlbWVudEtleSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBuYXZOb2RlID0gZWxlbWVudEtleVRvTmF2Tm9kZVtlbGVtZW50S2V5XTtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCB0aGUgYm91bmRpbmcgYm94IGRpcmVjdGx5IGZyb20gdGhlIERPTSwgYnV0IGZhbGwgYmFjayB0byB0aGUgb25lIGNhY2hlZFxuICAgICAgICAvLyBhdCBOYXYgVHJlZSBidWlsZCB0aW1lXG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94VG9Vc2UgPSAoX2IgPSAoX2EgPSAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoJ2JvZHknKVxuICAgICAgICAgICAgLmZpbmQoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke2VsZW1lbnRLZXl9YClcbiAgICAgICAgICAgIC5nZXQoMCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgaWYgKGJvdW5kaW5nQm94VG9Vc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmRpbmdCb3hUb1VzZS5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogYm91bmRpbmdCb3hUb1VzZS50b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nQm94VG9Vc2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ0JveFRvVXNlLmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hdk5vZGUgPT09IG51bGwgfHwgbmF2Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2Tm9kZS5wYWdlQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogbmF2Tm9kZS5wYWdlQm91bmRpbmdCb3gucGFnZVgsXG4gICAgICAgICAgICAgICAgdG9wOiBuYXZOb2RlLnBhZ2VCb3VuZGluZ0JveC5wYWdlWSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmF2Tm9kZS5wYWdlQm91bmRpbmdCb3gud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBuYXZOb2RlLnBhZ2VCb3VuZGluZ0JveC5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlT3V0bGluZXNGb3JFbGVtZW50S2V5ID0gKGVsZW1lbnRLZXksIHNlbGVjdGVkLCBpc0NoaWxkLCBvdXRsaW5lQ2hpbGRyZW4pID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbmF2Tm9kZSA9IGVsZW1lbnRLZXlUb05hdk5vZGVbZWxlbWVudEtleV07XG4gICAgICAgIGlmICghbmF2Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ05hbWVUb1VzZSA9IG5hdk5vZGUgPT09IG51bGwgfHwgbmF2Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2Tm9kZS5uYW1lO1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IGdldEJvdW5kaW5nQm94Rm9yRWxlbWVudEtleShlbGVtZW50S2V5KTtcbiAgICAgICAgaWYgKGJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKCgwLCBleHBvcnRzLmdldE91dGxpbmVFbGVtZW50KShwYXJlbnRQb3J0LCBpc0NoaWxkID8gT3V0bGluZVR5cGUuQ0hJTEQgOiBPdXRsaW5lVHlwZS5QUklNQVJZLCBib3VuZGluZ0JveC5sZWZ0LCBib3VuZGluZ0JveC50b3AsIGJvdW5kaW5nQm94LndpZHRoLCBib3VuZGluZ0JveC5oZWlnaHQsIHNlbGVjdGVkLCB0YWdOYW1lVG9Vc2UsIG5hdk5vZGUgPT09IG51bGwgfHwgbmF2Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2Tm9kZS5pc0NvbXBvbmVudCwgZWxlbWVudEtleSkpO1xuICAgICAgICAgICAgY29uc3QgbW91c2VEcmFnRGF0YSA9ICgwLCBzZXNzaW9uU3RvcmFnZVV0aWxzXzEuZ2V0TWVtb3J5U3RvcmFnZUl0ZW0pKCdtb3VzZURyYWdDb250ZXh0Jyk7XG4gICAgICAgICAgICBjb25zdCBtb3VzZVBvc0RhdGEgPSAoMCwgc2Vzc2lvblN0b3JhZ2VVdGlsc18xLmdldE1lbW9yeVN0b3JhZ2VJdGVtKSgnbW91c2VQb3MnKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiAobW91c2VEcmFnRGF0YSA9PT0gbnVsbCB8fCBtb3VzZURyYWdEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3VzZURyYWdEYXRhLmRyYWdnaW5nKSAmJiBtb3VzZVBvc0RhdGEpIHtcbiAgICAgICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKCgwLCBleHBvcnRzLmdldE91dGxpbmVFbGVtZW50KShwYXJlbnRQb3J0LCBPdXRsaW5lVHlwZS5NT1ZFLCBtb3VzZVBvc0RhdGEucGFnZVggLSBib3VuZGluZ0JveC53aWR0aCAvIDIgKyBtb3VzZURyYWdEYXRhLm9mZnNldFgsIG1vdXNlUG9zRGF0YS5wYWdlWSAtIGJvdW5kaW5nQm94LmhlaWdodCAvIDIgKyBtb3VzZURyYWdEYXRhLm9mZnNldFksIGJvdW5kaW5nQm94LndpZHRoLCBib3VuZGluZ0JveC5oZWlnaHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuYXZOb2RlID09PSBudWxsIHx8IG5hdk5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdk5vZGUuaXNDb21wb25lbnQsIGVsZW1lbnRLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0bGluZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBuYXZOb2RlID09PSBudWxsIHx8IG5hdk5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdk5vZGUuY2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlT3V0bGluZXNGb3JFbGVtZW50S2V5KGNoaWxkLnRlbXBvRWxlbWVudC5nZXRLZXkoKSwgZmFsc2UsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaG92ZXJlZEVsZW1lbnRLZXkpIHtcbiAgICAgICAgY3JlYXRlT3V0bGluZXNGb3JFbGVtZW50S2V5KGhvdmVyZWRFbGVtZW50S2V5LCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAobXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzID09PSBudWxsIHx8IG11bHRpc2VsZWN0ZWRFbGVtZW50S2V5cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZnVsbEJvdW5kaW5nQm94ID0gZ2V0Qm91bmRpbmdCb3hGb3JFbGVtZW50S2V5KG11bHRpc2VsZWN0ZWRFbGVtZW50S2V5c1swXSk7XG4gICAgICAgIG11bHRpc2VsZWN0ZWRFbGVtZW50S2V5cy5zbGljZSgxKS5mb3JFYWNoKChlbGVtZW50S2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib3VuZGluZ1JlY3QgPSBnZXRCb3VuZGluZ0JveEZvckVsZW1lbnRLZXkoZWxlbWVudEtleSk7XG4gICAgICAgICAgICBpZiAoYm91bmRpbmdSZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxCb3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2UmlnaHQgPSBmdWxsQm91bmRpbmdCb3gubGVmdCArIGZ1bGxCb3VuZGluZ0JveC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkJvdHRvbSA9IGZ1bGxCb3VuZGluZ0JveC50b3AgKyBmdWxsQm91bmRpbmdCb3guaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBmdWxsQm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKGZ1bGxCb3VuZGluZ0JveC5sZWZ0LCBib3VuZGluZ1JlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxCb3VuZGluZ0JveC50b3AgPSBNYXRoLm1pbihmdWxsQm91bmRpbmdCb3gudG9wLCBib3VuZGluZ1JlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChwcmV2UmlnaHQsIGJvdW5kaW5nUmVjdC5sZWZ0ICsgYm91bmRpbmdSZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgocHJldkJvdHRvbSwgYm91bmRpbmdSZWN0LnRvcCArIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBmdWxsQm91bmRpbmdCb3gud2lkdGggPSByaWdodCAtIGZ1bGxCb3VuZGluZ0JveC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBmdWxsQm91bmRpbmdCb3guaGVpZ2h0ID0gYm90dG9tIC0gZnVsbEJvdW5kaW5nQm94LnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxCb3VuZGluZ0JveCA9IGJvdW5kaW5nUmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZnVsbEJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKCgwLCBleHBvcnRzLmdldE91dGxpbmVFbGVtZW50KShwYXJlbnRQb3J0LCBPdXRsaW5lVHlwZS5QUklNQVJZLCBmdWxsQm91bmRpbmdCb3gubGVmdCwgZnVsbEJvdW5kaW5nQm94LnRvcCwgZnVsbEJvdW5kaW5nQm94LndpZHRoLCBmdWxsQm91bmRpbmdCb3guaGVpZ2h0LCB0cnVlLCBgJHttdWx0aXNlbGVjdGVkRWxlbWVudEtleXMubGVuZ3RofSBFbGVtZW50c2AsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlzZWxlY3RlZEVsZW1lbnRLZXlzLmZvckVhY2goKGVsZW1lbnRLZXkpID0+IHtcbiAgICAgICAgICAgIGNyZWF0ZU91dGxpbmVzRm9yRWxlbWVudEtleShlbGVtZW50S2V5LCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGVjdGVkRWxlbWVudEtleSkge1xuICAgICAgICBjcmVhdGVPdXRsaW5lc0ZvckVsZW1lbnRLZXkoc2VsZWN0ZWRFbGVtZW50S2V5LCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgb3V0bGluZXNcbiAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoYC4ke2lkZW50aWZpZXJVdGlsc18xLlRFTVBPX0lOU1RBTlRfRElWX0RSQVdfQ0xBU1N9YCkuZWFjaCgoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgYm91bmRpbmdSZWN0ID0gaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZCgoMCwgZXhwb3J0cy5nZXRPdXRsaW5lRWxlbWVudCkocGFyZW50UG9ydCwgT3V0bGluZVR5cGUuUFJJTUFSWSwgYm91bmRpbmdSZWN0LmxlZnQsIGJvdW5kaW5nUmVjdC50b3AsIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LmhlaWdodCkpO1xuICAgIH0pO1xuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShgKlske2lkZW50aWZpZXJVdGlsc18xLlRFTVBPX09VVExJTkVfVU5USUxfUkVGRVNIfT10cnVlXWApLmVhY2goKGluZGV4LCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IGl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoKDAsIGV4cG9ydHMuZ2V0T3V0bGluZUVsZW1lbnQpKHBhcmVudFBvcnQsIE91dGxpbmVUeXBlLlBSSU1BUlksIGJvdW5kaW5nUmVjdC5sZWZ0LCBib3VuZGluZ1JlY3QudG9wLCBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpKTtcbiAgICB9KTtcbiAgICAvLyBDcmVhdGUgc2Vjb25kYXJ5IG91dGxpbmVzIGZvciBhbGwgbWF0Y2hpbmcgSURzIGluIHRoZSBjb2RlYmFzZSBmb3IgdGhlIGNsaWNrZWQgZWxlbWVudFxuICAgIGlmIChzZWxlY3RlZEVsZW1lbnQgPT09IG51bGwgfHwgc2VsZWN0ZWRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZEVsZW1lbnQuY29kZWJhc2VJZCkge1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoJ2JvZHknKVxuICAgICAgICAgICAgLmZpbmQoYC4ke3NlbGVjdGVkRWxlbWVudCA9PT0gbnVsbCB8fCBzZWxlY3RlZEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkRWxlbWVudC5jb2RlYmFzZUlkfWApXG4gICAgICAgICAgICAubm90KGAuJHtpZGVudGlmaWVyVXRpbHNfMS5FTEVNRU5UX0tFWV9QUkVGSVh9JHtzZWxlY3RlZEVsZW1lbnRLZXl9YClcbiAgICAgICAgICAgIC5ub3QoYC4ke2lkZW50aWZpZXJVdGlsc18xLkVMRU1FTlRfS0VZX1BSRUZJWH0ke2hvdmVyZWRFbGVtZW50S2V5fWApXG4gICAgICAgICAgICAuZWFjaCgoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IGl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKCgwLCBleHBvcnRzLmdldE91dGxpbmVFbGVtZW50KShwYXJlbnRQb3J0LCBPdXRsaW5lVHlwZS5TRUNPTkRBUlksIGJvdW5kaW5nUmVjdC5sZWZ0LCBib3VuZGluZ1JlY3QudG9wLCBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmV4cG9ydHMudXBkYXRlT3V0bGluZXMgPSB1cGRhdGVPdXRsaW5lcztcbmNvbnN0IGlzTm9kZU91dGxpbmUgPSAobm9kZSkgPT4ge1xuICAgIGlmICghKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5jbGFzc0xpc3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGlzT3V0bGluZSA9IGZhbHNlO1xuICAgIG5vZGUuY2xhc3NMaXN0LmZvckVhY2goKGNscykgPT4ge1xuICAgICAgICBpZiAoY2xzID09PSBpZGVudGlmaWVyVXRpbHNfMS5PVVRMSU5FX0NMQVNTKSB7XG4gICAgICAgICAgICBpc091dGxpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzT3V0bGluZTtcbn07XG5leHBvcnRzLmlzTm9kZU91dGxpbmUgPSBpc05vZGVPdXRsaW5lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/outlineUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/resqUtils.js":
/*!************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/resqUtils.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Code taken and adapted from the resq library: https://github.com/baruchvlz/resq\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findElementInTree = exports.getElementName = exports.clearLookupsFromTree = exports.buildTreeLookupMap = exports.removeUniqueLoookupFromReactTreeNode = exports.addUniqueLoookupToReactTreeNode = exports.getUniqueLoookupFromReactTreeNode = exports.getDomElementForReactNode = exports.buildNodeTree = exports.getRootReactElement = exports.findReactInstance = void 0;\nconst identifierUtils_1 = __webpack_require__(/*! ./identifierUtils */ \"(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/identifierUtils.js\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\");\n/**\n * Taken from https://github.com/baruchvlz/resq/blob/master/src/utils.js\n * but improved to work with all versions of react\n */\nconst findReactInstance = (element) => {\n    if (element.hasOwnProperty('_reactRootContainer')) {\n        if (element._reactRootContainer._internalRoot) {\n            return element._reactRootContainer._internalRoot.current;\n        }\n        else {\n            return element._reactRootContainer.current;\n        }\n    }\n    const instanceId = Object.keys(element).find((key) => key.startsWith('__reactInternalInstance') ||\n        key.startsWith('__reactFiber') ||\n        key.startsWith('__reactContainer'));\n    if (instanceId) {\n        return element[instanceId];\n    }\n};\nexports.findReactInstance = findReactInstance;\n//Returns true if it is a DOM element\nfunction isElement(o) {\n    return typeof HTMLElement === 'object'\n        ? o instanceof HTMLElement //DOM2\n        : o &&\n            typeof o === 'object' &&\n            o !== null &&\n            o.nodeType === 1 &&\n            typeof o.nodeName === 'string';\n}\nconst getRootReactElement = () => {\n    var _a;\n    let rootSelector = '#root';\n    if (!document.querySelector(rootSelector)) {\n        rootSelector = '#__next';\n    }\n    const root = document.querySelector(rootSelector);\n    let findInstance = null;\n    if (root) {\n        findInstance = (0, exports.findReactInstance)(root);\n    }\n    else {\n        // hacky fallback; if there's no root element so we grab the first one we find\n        document\n            .getElementsByTagName('body')[0]\n            .childNodes.forEach((childNode) => {\n            if (findInstance) {\n                return;\n            }\n            if (childNode.tagName !== 'DIV') {\n                return;\n            }\n            findInstance = (0, exports.findReactInstance)(childNode);\n        });\n    }\n    // June 12 2024 fix:\n    // Sometimes the react tree only loads correctly in the \"alternate slot\"\n    // Replace the current tree with the alternate tree if that is the case\n    if (findInstance && !findInstance.child && ((_a = findInstance.alternate) === null || _a === void 0 ? void 0 : _a.child)) {\n        findInstance = findInstance.alternate;\n    }\n    return findInstance;\n};\nexports.getRootReactElement = getRootReactElement;\nconst removeChildrenFromProps = (props) => {\n    // if the props is a string, we can assume that it's just the text inside a html element\n    if (!props || typeof props === 'string') {\n        return props;\n    }\n    const returnProps = Object.assign({}, props);\n    delete returnProps.children;\n    return returnProps;\n};\nconst getElementState = (elementState) => {\n    if (!elementState) {\n        return undefined;\n    }\n    const { baseState } = elementState;\n    if (baseState) {\n        return baseState;\n    }\n    return elementState;\n};\nconst buildNodeTree = (element, parentTreeNode) => {\n    var _a, _b;\n    let tree = { children: [] };\n    tree.element = element;\n    tree.parent = parentTreeNode;\n    if (!element) {\n        return tree;\n    }\n    tree.name = (0, exports.getElementName)(element.type);\n    if (typeof tree.name !== 'string') {\n        tree.name = (_b = (_a = tree.name) === null || _a === void 0 ? void 0 : _a.toString) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    tree.props = removeChildrenFromProps(element.memoizedProps);\n    tree.state = getElementState(element.memoizedState);\n    let { child } = element;\n    if (child) {\n        tree.children.push(child);\n        while (child.sibling) {\n            tree.children.push(child.sibling);\n            child = child.sibling;\n        }\n    }\n    tree.children = tree.children.map((child) => (0, exports.buildNodeTree)(child, tree));\n    return tree;\n};\nexports.buildNodeTree = buildNodeTree;\nconst getDomElementForReactNode = (node) => {\n    var _a, _b;\n    let stateNode = (_a = node === null || node === void 0 ? void 0 : node.element) === null || _a === void 0 ? void 0 : _a.stateNode;\n    if (stateNode && ((_b = stateNode === null || stateNode === void 0 ? void 0 : stateNode.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'FiberRootNode') {\n        stateNode = stateNode.containerInfo;\n    }\n    if (isElement(stateNode)) {\n        return stateNode;\n    }\n    return null;\n};\nexports.getDomElementForReactNode = getDomElementForReactNode;\nconst getUniqueLoookupFromReactTreeNode = (node) => {\n    const stateNode = (0, exports.getDomElementForReactNode)(node);\n    if (stateNode) {\n        return (0, identifierUtils_1.getUniqueLookupFromNode)(stateNode);\n    }\n    return null;\n};\nexports.getUniqueLoookupFromReactTreeNode = getUniqueLoookupFromReactTreeNode;\nconst addUniqueLoookupToReactTreeNode = (node, uniqueLookup) => {\n    const stateNode = (0, exports.getDomElementForReactNode)(node);\n    if (stateNode) {\n        (0, identifierUtils_1.addUniqueLookupAsClass)(stateNode, uniqueLookup);\n        return true;\n    }\n    return false;\n};\nexports.addUniqueLoookupToReactTreeNode = addUniqueLoookupToReactTreeNode;\nconst removeUniqueLoookupFromReactTreeNode = (node) => {\n    const stateNode = (0, exports.getDomElementForReactNode)(node);\n    if (stateNode) {\n        (0, identifierUtils_1.removeUniqueLookupFromNode)(stateNode);\n        return true;\n    }\n    return false;\n};\nexports.removeUniqueLoookupFromReactTreeNode = removeUniqueLoookupFromReactTreeNode;\n/**\n * Builds a lookup map with generated uuids that are added to the HTML elements under the hood as classes.\n * Make sure to clear the lookups from the tree after you are done with it.\n * @param tree\n * @param map\n */\nconst buildTreeLookupMap = (tree, map) => {\n    const newUniqueLookup = (0, uuid_1.v4)();\n    const added = (0, exports.addUniqueLoookupToReactTreeNode)(tree, newUniqueLookup);\n    if (added) {\n        map[newUniqueLookup] = tree;\n    }\n    tree.children.forEach((child) => {\n        (0, exports.buildTreeLookupMap)(child, map);\n    });\n};\nexports.buildTreeLookupMap = buildTreeLookupMap;\n/**\n * Build tree lookup map adds a class name for lookups, we want to remove these after the tree is built\n * @param tree\n */\nconst clearLookupsFromTree = (tree) => {\n    (0, exports.removeUniqueLoookupFromReactTreeNode)(tree);\n    tree.children.forEach((child) => {\n        (0, exports.clearLookupsFromTree)(child);\n    });\n};\nexports.clearLookupsFromTree = clearLookupsFromTree;\nconst isFunction = (type) => {\n    return typeof type === 'function';\n};\nconst isObject = (type) => {\n    return typeof type === 'object';\n};\nconst getElementName = (type) => {\n    var _a;\n    if (!type) {\n        return type;\n    }\n    if (isFunction(type) || isObject(type)) {\n        if (type.displayName) {\n            if (isFunction(type.displayName)) {\n                return type.displayName();\n            }\n            else {\n                return type.displayName;\n            }\n        }\n        if (type.name) {\n            if (isFunction(type.name)) {\n                return type.name();\n            }\n            else {\n                return type.name;\n            }\n        }\n        if ((_a = type.render) === null || _a === void 0 ? void 0 : _a.name) {\n            return type.render.name;\n        }\n        return null;\n    }\n    return type;\n};\nexports.getElementName = getElementName;\n/**\n * @param tree\n * @param searchFn\n * @param firstOnly if set, returns only the first element in a breadth-firth search\n * @returns\n */\nconst findElementInTree = (tree, searchFn, firstOnly) => {\n    let searchQueue = [tree];\n    const foundNodes = [];\n    while (searchQueue.length > 0) {\n        const node = searchQueue.shift();\n        if (searchFn(node)) {\n            foundNodes.push(node);\n            if (firstOnly) {\n                break;\n            }\n        }\n        searchQueue = searchQueue.concat(node.children || []);\n    }\n    return foundNodes;\n};\nexports.findElementInTree = findElementInTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL3Jlc3FVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLDRCQUE0QixHQUFHLDBCQUEwQixHQUFHLDRDQUE0QyxHQUFHLHVDQUF1QyxHQUFHLHlDQUF5QyxHQUFHLGlDQUFpQyxHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLHlCQUF5QjtBQUN6VywwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBbUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLDhEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3lhaGlcXE9uZURyaXZlXFzYs9i32K0g2KfZhNmF2YPYqtioXFxHYXNzaW1cXGhlYWRzaG90bWFrZXJhaXByb1xcbm9kZV9tb2R1bGVzXFx0ZW1wby1kZXZ0b29sc1xcZGlzdFxcY2hhbm5lbE1lc3NhZ2luZ1xccmVzcVV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29kZSB0YWtlbiBhbmQgYWRhcHRlZCBmcm9tIHRoZSByZXNxIGxpYnJhcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYXJ1Y2h2bHovcmVzcVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maW5kRWxlbWVudEluVHJlZSA9IGV4cG9ydHMuZ2V0RWxlbWVudE5hbWUgPSBleHBvcnRzLmNsZWFyTG9va3Vwc0Zyb21UcmVlID0gZXhwb3J0cy5idWlsZFRyZWVMb29rdXBNYXAgPSBleHBvcnRzLnJlbW92ZVVuaXF1ZUxvb29rdXBGcm9tUmVhY3RUcmVlTm9kZSA9IGV4cG9ydHMuYWRkVW5pcXVlTG9vb2t1cFRvUmVhY3RUcmVlTm9kZSA9IGV4cG9ydHMuZ2V0VW5pcXVlTG9vb2t1cEZyb21SZWFjdFRyZWVOb2RlID0gZXhwb3J0cy5nZXREb21FbGVtZW50Rm9yUmVhY3ROb2RlID0gZXhwb3J0cy5idWlsZE5vZGVUcmVlID0gZXhwb3J0cy5nZXRSb290UmVhY3RFbGVtZW50ID0gZXhwb3J0cy5maW5kUmVhY3RJbnN0YW5jZSA9IHZvaWQgMDtcbmNvbnN0IGlkZW50aWZpZXJVdGlsc18xID0gcmVxdWlyZShcIi4vaWRlbnRpZmllclV0aWxzXCIpO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG4vKipcbiAqIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JhcnVjaHZsei9yZXNxL2Jsb2IvbWFzdGVyL3NyYy91dGlscy5qc1xuICogYnV0IGltcHJvdmVkIHRvIHdvcmsgd2l0aCBhbGwgdmVyc2lvbnMgb2YgcmVhY3RcbiAqL1xuY29uc3QgZmluZFJlYWN0SW5zdGFuY2UgPSAoZWxlbWVudCkgPT4ge1xuICAgIGlmIChlbGVtZW50Lmhhc093blByb3BlcnR5KCdfcmVhY3RSb290Q29udGFpbmVyJykpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuX3JlYWN0Um9vdENvbnRhaW5lci5faW50ZXJuYWxSb290KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5fcmVhY3RSb290Q29udGFpbmVyLl9pbnRlcm5hbFJvb3QuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Ll9yZWFjdFJvb3RDb250YWluZXIuY3VycmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZUlkID0gT2JqZWN0LmtleXMoZWxlbWVudCkuZmluZCgoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnX19yZWFjdEludGVybmFsSW5zdGFuY2UnKSB8fFxuICAgICAgICBrZXkuc3RhcnRzV2l0aCgnX19yZWFjdEZpYmVyJykgfHxcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgoJ19fcmVhY3RDb250YWluZXInKSk7XG4gICAgaWYgKGluc3RhbmNlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRbaW5zdGFuY2VJZF07XG4gICAgfVxufTtcbmV4cG9ydHMuZmluZFJlYWN0SW5zdGFuY2UgPSBmaW5kUmVhY3RJbnN0YW5jZTtcbi8vUmV0dXJucyB0cnVlIGlmIGl0IGlzIGEgRE9NIGVsZW1lbnRcbmZ1bmN0aW9uIGlzRWxlbWVudChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ29iamVjdCdcbiAgICAgICAgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgLy9ET00yXG4gICAgICAgIDogbyAmJlxuICAgICAgICAgICAgdHlwZW9mIG8gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBvICE9PSBudWxsICYmXG4gICAgICAgICAgICBvLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG59XG5jb25zdCBnZXRSb290UmVhY3RFbGVtZW50ID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcm9vdFNlbGVjdG9yID0gJyNyb290JztcbiAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdFNlbGVjdG9yKSkge1xuICAgICAgICByb290U2VsZWN0b3IgPSAnI19fbmV4dCc7XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3RTZWxlY3Rvcik7XG4gICAgbGV0IGZpbmRJbnN0YW5jZSA9IG51bGw7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgICAgZmluZEluc3RhbmNlID0gKDAsIGV4cG9ydHMuZmluZFJlYWN0SW5zdGFuY2UpKHJvb3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaGFja3kgZmFsbGJhY2s7IGlmIHRoZXJlJ3Mgbm8gcm9vdCBlbGVtZW50IHNvIHdlIGdyYWIgdGhlIGZpcnN0IG9uZSB3ZSBmaW5kXG4gICAgICAgIGRvY3VtZW50XG4gICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXVxuICAgICAgICAgICAgLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmluZEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS50YWdOYW1lICE9PSAnRElWJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmRJbnN0YW5jZSA9ICgwLCBleHBvcnRzLmZpbmRSZWFjdEluc3RhbmNlKShjaGlsZE5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSnVuZSAxMiAyMDI0IGZpeDpcbiAgICAvLyBTb21ldGltZXMgdGhlIHJlYWN0IHRyZWUgb25seSBsb2FkcyBjb3JyZWN0bHkgaW4gdGhlIFwiYWx0ZXJuYXRlIHNsb3RcIlxuICAgIC8vIFJlcGxhY2UgdGhlIGN1cnJlbnQgdHJlZSB3aXRoIHRoZSBhbHRlcm5hdGUgdHJlZSBpZiB0aGF0IGlzIHRoZSBjYXNlXG4gICAgaWYgKGZpbmRJbnN0YW5jZSAmJiAhZmluZEluc3RhbmNlLmNoaWxkICYmICgoX2EgPSBmaW5kSW5zdGFuY2UuYWx0ZXJuYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGQpKSB7XG4gICAgICAgIGZpbmRJbnN0YW5jZSA9IGZpbmRJbnN0YW5jZS5hbHRlcm5hdGU7XG4gICAgfVxuICAgIHJldHVybiBmaW5kSW5zdGFuY2U7XG59O1xuZXhwb3J0cy5nZXRSb290UmVhY3RFbGVtZW50ID0gZ2V0Um9vdFJlYWN0RWxlbWVudDtcbmNvbnN0IHJlbW92ZUNoaWxkcmVuRnJvbVByb3BzID0gKHByb3BzKSA9PiB7XG4gICAgLy8gaWYgdGhlIHByb3BzIGlzIGEgc3RyaW5nLCB3ZSBjYW4gYXNzdW1lIHRoYXQgaXQncyBqdXN0IHRoZSB0ZXh0IGluc2lkZSBhIGh0bWwgZWxlbWVudFxuICAgIGlmICghcHJvcHMgfHwgdHlwZW9mIHByb3BzID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICAgIGNvbnN0IHJldHVyblByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpO1xuICAgIGRlbGV0ZSByZXR1cm5Qcm9wcy5jaGlsZHJlbjtcbiAgICByZXR1cm4gcmV0dXJuUHJvcHM7XG59O1xuY29uc3QgZ2V0RWxlbWVudFN0YXRlID0gKGVsZW1lbnRTdGF0ZSkgPT4ge1xuICAgIGlmICghZWxlbWVudFN0YXRlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHsgYmFzZVN0YXRlIH0gPSBlbGVtZW50U3RhdGU7XG4gICAgaWYgKGJhc2VTdGF0ZSkge1xuICAgICAgICByZXR1cm4gYmFzZVN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudFN0YXRlO1xufTtcbmNvbnN0IGJ1aWxkTm9kZVRyZWUgPSAoZWxlbWVudCwgcGFyZW50VHJlZU5vZGUpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCB0cmVlID0geyBjaGlsZHJlbjogW10gfTtcbiAgICB0cmVlLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRyZWUucGFyZW50ID0gcGFyZW50VHJlZU5vZGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbiAgICB0cmVlLm5hbWUgPSAoMCwgZXhwb3J0cy5nZXRFbGVtZW50TmFtZSkoZWxlbWVudC50eXBlKTtcbiAgICBpZiAodHlwZW9mIHRyZWUubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJlZS5uYW1lID0gKF9iID0gKF9hID0gdHJlZS5uYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgdHJlZS5wcm9wcyA9IHJlbW92ZUNoaWxkcmVuRnJvbVByb3BzKGVsZW1lbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgdHJlZS5zdGF0ZSA9IGdldEVsZW1lbnRTdGF0ZShlbGVtZW50Lm1lbW9pemVkU3RhdGUpO1xuICAgIGxldCB7IGNoaWxkIH0gPSBlbGVtZW50O1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgICB0cmVlLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB3aGlsZSAoY2hpbGQuc2libGluZykge1xuICAgICAgICAgICAgdHJlZS5jaGlsZHJlbi5wdXNoKGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyZWUuY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+ICgwLCBleHBvcnRzLmJ1aWxkTm9kZVRyZWUpKGNoaWxkLCB0cmVlKSk7XG4gICAgcmV0dXJuIHRyZWU7XG59O1xuZXhwb3J0cy5idWlsZE5vZGVUcmVlID0gYnVpbGROb2RlVHJlZTtcbmNvbnN0IGdldERvbUVsZW1lbnRGb3JSZWFjdE5vZGUgPSAobm9kZSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IHN0YXRlTm9kZSA9IChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGVOb2RlO1xuICAgIGlmIChzdGF0ZU5vZGUgJiYgKChfYiA9IHN0YXRlTm9kZSA9PT0gbnVsbCB8fCBzdGF0ZU5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRlTm9kZS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSAnRmliZXJSb290Tm9kZScpIHtcbiAgICAgICAgc3RhdGVOb2RlID0gc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQoc3RhdGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gc3RhdGVOb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLmdldERvbUVsZW1lbnRGb3JSZWFjdE5vZGUgPSBnZXREb21FbGVtZW50Rm9yUmVhY3ROb2RlO1xuY29uc3QgZ2V0VW5pcXVlTG9vb2t1cEZyb21SZWFjdFRyZWVOb2RlID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBzdGF0ZU5vZGUgPSAoMCwgZXhwb3J0cy5nZXREb21FbGVtZW50Rm9yUmVhY3ROb2RlKShub2RlKTtcbiAgICBpZiAoc3RhdGVOb2RlKSB7XG4gICAgICAgIHJldHVybiAoMCwgaWRlbnRpZmllclV0aWxzXzEuZ2V0VW5pcXVlTG9va3VwRnJvbU5vZGUpKHN0YXRlTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmV4cG9ydHMuZ2V0VW5pcXVlTG9vb2t1cEZyb21SZWFjdFRyZWVOb2RlID0gZ2V0VW5pcXVlTG9vb2t1cEZyb21SZWFjdFRyZWVOb2RlO1xuY29uc3QgYWRkVW5pcXVlTG9vb2t1cFRvUmVhY3RUcmVlTm9kZSA9IChub2RlLCB1bmlxdWVMb29rdXApID0+IHtcbiAgICBjb25zdCBzdGF0ZU5vZGUgPSAoMCwgZXhwb3J0cy5nZXREb21FbGVtZW50Rm9yUmVhY3ROb2RlKShub2RlKTtcbiAgICBpZiAoc3RhdGVOb2RlKSB7XG4gICAgICAgICgwLCBpZGVudGlmaWVyVXRpbHNfMS5hZGRVbmlxdWVMb29rdXBBc0NsYXNzKShzdGF0ZU5vZGUsIHVuaXF1ZUxvb2t1cCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5hZGRVbmlxdWVMb29va3VwVG9SZWFjdFRyZWVOb2RlID0gYWRkVW5pcXVlTG9vb2t1cFRvUmVhY3RUcmVlTm9kZTtcbmNvbnN0IHJlbW92ZVVuaXF1ZUxvb29rdXBGcm9tUmVhY3RUcmVlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgY29uc3Qgc3RhdGVOb2RlID0gKDAsIGV4cG9ydHMuZ2V0RG9tRWxlbWVudEZvclJlYWN0Tm9kZSkobm9kZSk7XG4gICAgaWYgKHN0YXRlTm9kZSkge1xuICAgICAgICAoMCwgaWRlbnRpZmllclV0aWxzXzEucmVtb3ZlVW5pcXVlTG9va3VwRnJvbU5vZGUpKHN0YXRlTm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5yZW1vdmVVbmlxdWVMb29va3VwRnJvbVJlYWN0VHJlZU5vZGUgPSByZW1vdmVVbmlxdWVMb29va3VwRnJvbVJlYWN0VHJlZU5vZGU7XG4vKipcbiAqIEJ1aWxkcyBhIGxvb2t1cCBtYXAgd2l0aCBnZW5lcmF0ZWQgdXVpZHMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIEhUTUwgZWxlbWVudHMgdW5kZXIgdGhlIGhvb2QgYXMgY2xhc3Nlcy5cbiAqIE1ha2Ugc3VyZSB0byBjbGVhciB0aGUgbG9va3VwcyBmcm9tIHRoZSB0cmVlIGFmdGVyIHlvdSBhcmUgZG9uZSB3aXRoIGl0LlxuICogQHBhcmFtIHRyZWVcbiAqIEBwYXJhbSBtYXBcbiAqL1xuY29uc3QgYnVpbGRUcmVlTG9va3VwTWFwID0gKHRyZWUsIG1hcCkgPT4ge1xuICAgIGNvbnN0IG5ld1VuaXF1ZUxvb2t1cCA9ICgwLCB1dWlkXzEudjQpKCk7XG4gICAgY29uc3QgYWRkZWQgPSAoMCwgZXhwb3J0cy5hZGRVbmlxdWVMb29va3VwVG9SZWFjdFRyZWVOb2RlKSh0cmVlLCBuZXdVbmlxdWVMb29rdXApO1xuICAgIGlmIChhZGRlZCkge1xuICAgICAgICBtYXBbbmV3VW5pcXVlTG9va3VwXSA9IHRyZWU7XG4gICAgfVxuICAgIHRyZWUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgKDAsIGV4cG9ydHMuYnVpbGRUcmVlTG9va3VwTWFwKShjaGlsZCwgbWFwKTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmJ1aWxkVHJlZUxvb2t1cE1hcCA9IGJ1aWxkVHJlZUxvb2t1cE1hcDtcbi8qKlxuICogQnVpbGQgdHJlZSBsb29rdXAgbWFwIGFkZHMgYSBjbGFzcyBuYW1lIGZvciBsb29rdXBzLCB3ZSB3YW50IHRvIHJlbW92ZSB0aGVzZSBhZnRlciB0aGUgdHJlZSBpcyBidWlsdFxuICogQHBhcmFtIHRyZWVcbiAqL1xuY29uc3QgY2xlYXJMb29rdXBzRnJvbVRyZWUgPSAodHJlZSkgPT4ge1xuICAgICgwLCBleHBvcnRzLnJlbW92ZVVuaXF1ZUxvb29rdXBGcm9tUmVhY3RUcmVlTm9kZSkodHJlZSk7XG4gICAgdHJlZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAoMCwgZXhwb3J0cy5jbGVhckxvb2t1cHNGcm9tVHJlZSkoY2hpbGQpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuY2xlYXJMb29rdXBzRnJvbVRyZWUgPSBjbGVhckxvb2t1cHNGcm9tVHJlZTtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodHlwZSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5jb25zdCBpc09iamVjdCA9ICh0eXBlKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jztcbn07XG5jb25zdCBnZXRFbGVtZW50TmFtZSA9ICh0eXBlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24odHlwZSkgfHwgaXNPYmplY3QodHlwZSkpIHtcbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHR5cGUuZGlzcGxheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlLm5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoX2EgPSB0eXBlLnJlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLnJlbmRlci5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn07XG5leHBvcnRzLmdldEVsZW1lbnROYW1lID0gZ2V0RWxlbWVudE5hbWU7XG4vKipcbiAqIEBwYXJhbSB0cmVlXG4gKiBAcGFyYW0gc2VhcmNoRm5cbiAqIEBwYXJhbSBmaXJzdE9ubHkgaWYgc2V0LCByZXR1cm5zIG9ubHkgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBicmVhZHRoLWZpcnRoIHNlYXJjaFxuICogQHJldHVybnNcbiAqL1xuY29uc3QgZmluZEVsZW1lbnRJblRyZWUgPSAodHJlZSwgc2VhcmNoRm4sIGZpcnN0T25seSkgPT4ge1xuICAgIGxldCBzZWFyY2hRdWV1ZSA9IFt0cmVlXTtcbiAgICBjb25zdCBmb3VuZE5vZGVzID0gW107XG4gICAgd2hpbGUgKHNlYXJjaFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHNlYXJjaFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzZWFyY2hGbihub2RlKSkge1xuICAgICAgICAgICAgZm91bmROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGZpcnN0T25seSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlYXJjaFF1ZXVlID0gc2VhcmNoUXVldWUuY29uY2F0KG5vZGUuY2hpbGRyZW4gfHwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmROb2Rlcztcbn07XG5leHBvcnRzLmZpbmRFbGVtZW50SW5UcmVlID0gZmluZEVsZW1lbnRJblRyZWU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/resqUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeSessionStorageItem = exports.setSessionStorageItem = exports.getSessionStorageItem = exports.removeMemoryStorageItem = exports.setMemoryStorageItem = exports.getMemoryStorageItem = exports.CURRENT_NAV_TREE = exports.ELEMENT_KEY_TO_NAV_NODE = exports.ELEMENT_KEY_TO_LOOKUP_LIST = exports.NAV_TREE_CALLBACKS = exports.IS_FLUSHING = exports.HOT_RELOADING = exports.TEXT_EDIT = exports.HOVERED_ELEMENT_KEY = exports.MULTI_SELECTED_ELEMENT_KEYS = exports.SELECTED_ELEMENT_KEY = exports.SAVED_STORYBOARD_COMPONENT_FILENAME = exports.ORIGINAL_STORYBOARD_URL = exports.STORYBOARD_TYPE = exports.STORYBOARD_COMPONENT = exports.SCOPE_LOOKUP = exports.TREE_ELEMENT_LOOKUP = void 0;\n// Memory Storage Objects\nexports.TREE_ELEMENT_LOOKUP = 'TREE_ELEMENT_LOOKUP';\nexports.SCOPE_LOOKUP = 'SCOPE_LOOKUP';\nexports.STORYBOARD_COMPONENT = 'STORYBOARD_COMPONENT';\nexports.STORYBOARD_TYPE = 'STORYBOARD_TYPE';\nexports.ORIGINAL_STORYBOARD_URL = 'ORIGINAL_STORYBOARD_URL';\nexports.SAVED_STORYBOARD_COMPONENT_FILENAME = 'SAVED_STORYBOARD_COMPONENT_FILENAME';\nexports.SELECTED_ELEMENT_KEY = 'SELECTED_ELEMENT_KEY';\nexports.MULTI_SELECTED_ELEMENT_KEYS = 'MULTI_SELECTED_ELEMENT_KEYS';\nexports.HOVERED_ELEMENT_KEY = 'HOVERED_ELEMENT_KEY';\nexports.TEXT_EDIT = 'TEXT_EDIT';\nexports.HOT_RELOADING = 'HOT_RELOADING';\nexports.IS_FLUSHING = 'IS_FLUSHING';\nexports.NAV_TREE_CALLBACKS = 'NAV_TREE_CALLBACKS';\n// Generated when creating the nav tree, used for outlines\nexports.ELEMENT_KEY_TO_LOOKUP_LIST = 'ELEMENT_KEY_TO_LOOKUP_LIST';\nexports.ELEMENT_KEY_TO_NAV_NODE = 'ELEMENT_KEY_TO_NAV_NODE';\nexports.CURRENT_NAV_TREE = 'CURRENT_NAV_TREE';\nconst inMemoryStorage = {};\nconst getMemoryStorageItem = (key) => {\n    return inMemoryStorage[key];\n};\nexports.getMemoryStorageItem = getMemoryStorageItem;\nconst setMemoryStorageItem = (key, value) => {\n    inMemoryStorage[key] = value;\n    if (!value) {\n        delete inMemoryStorage[key];\n    }\n};\nexports.setMemoryStorageItem = setMemoryStorageItem;\nconst removeMemoryStorageItem = (key) => {\n    delete inMemoryStorage[key];\n};\nexports.removeMemoryStorageItem = removeMemoryStorageItem;\nconst getSessionStorageItem = (key, storyboardId) => {\n    return sessionStorage.getItem(`${storyboardId}_${key}`);\n};\nexports.getSessionStorageItem = getSessionStorageItem;\nconst setSessionStorageItem = (key, value, storyboardId) => {\n    if (!value) {\n        (0, exports.removeSessionStorageItem)(key, storyboardId);\n        return;\n    }\n    sessionStorage.setItem(`${storyboardId}_${key}`, value);\n};\nexports.setSessionStorageItem = setSessionStorageItem;\nconst removeSessionStorageItem = (key, storyboardId) => {\n    sessionStorage.removeItem(`${storyboardId}_${key}`);\n};\nexports.removeSessionStorageItem = removeSessionStorageItem;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL3Nlc3Npb25TdG9yYWdlVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcsNkJBQTZCLEdBQUcsNkJBQTZCLEdBQUcsK0JBQStCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsd0JBQXdCLEdBQUcsK0JBQStCLEdBQUcsa0NBQWtDLEdBQUcsMEJBQTBCLEdBQUcsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcsMkJBQTJCLEdBQUcsbUNBQW1DLEdBQUcsNEJBQTRCLEdBQUcsMkNBQTJDLEdBQUcsK0JBQStCLEdBQUcsdUJBQXVCLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcsMkJBQTJCO0FBQ2xxQjtBQUNBLDJCQUEyQjtBQUMzQixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IsMkNBQTJDO0FBQzNDLDRCQUE0QjtBQUM1QixtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQjtBQUNBLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0Isd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsYUFBYSxHQUFHLElBQUk7QUFDekQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhLEdBQUcsSUFBSTtBQUNsRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGlDQUFpQyxhQUFhLEdBQUcsSUFBSTtBQUNyRDtBQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHRlbXBvLWRldnRvb2xzXFxkaXN0XFxjaGFubmVsTWVzc2FnaW5nXFxzZXNzaW9uU3RvcmFnZVV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZW1vdmVTZXNzaW9uU3RvcmFnZUl0ZW0gPSBleHBvcnRzLnNldFNlc3Npb25TdG9yYWdlSXRlbSA9IGV4cG9ydHMuZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtID0gZXhwb3J0cy5yZW1vdmVNZW1vcnlTdG9yYWdlSXRlbSA9IGV4cG9ydHMuc2V0TWVtb3J5U3RvcmFnZUl0ZW0gPSBleHBvcnRzLmdldE1lbW9yeVN0b3JhZ2VJdGVtID0gZXhwb3J0cy5DVVJSRU5UX05BVl9UUkVFID0gZXhwb3J0cy5FTEVNRU5UX0tFWV9UT19OQVZfTk9ERSA9IGV4cG9ydHMuRUxFTUVOVF9LRVlfVE9fTE9PS1VQX0xJU1QgPSBleHBvcnRzLk5BVl9UUkVFX0NBTExCQUNLUyA9IGV4cG9ydHMuSVNfRkxVU0hJTkcgPSBleHBvcnRzLkhPVF9SRUxPQURJTkcgPSBleHBvcnRzLlRFWFRfRURJVCA9IGV4cG9ydHMuSE9WRVJFRF9FTEVNRU5UX0tFWSA9IGV4cG9ydHMuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTID0gZXhwb3J0cy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSA9IGV4cG9ydHMuU0FWRURfU1RPUllCT0FSRF9DT01QT05FTlRfRklMRU5BTUUgPSBleHBvcnRzLk9SSUdJTkFMX1NUT1JZQk9BUkRfVVJMID0gZXhwb3J0cy5TVE9SWUJPQVJEX1RZUEUgPSBleHBvcnRzLlNUT1JZQk9BUkRfQ09NUE9ORU5UID0gZXhwb3J0cy5TQ09QRV9MT09LVVAgPSBleHBvcnRzLlRSRUVfRUxFTUVOVF9MT09LVVAgPSB2b2lkIDA7XG4vLyBNZW1vcnkgU3RvcmFnZSBPYmplY3RzXG5leHBvcnRzLlRSRUVfRUxFTUVOVF9MT09LVVAgPSAnVFJFRV9FTEVNRU5UX0xPT0tVUCc7XG5leHBvcnRzLlNDT1BFX0xPT0tVUCA9ICdTQ09QRV9MT09LVVAnO1xuZXhwb3J0cy5TVE9SWUJPQVJEX0NPTVBPTkVOVCA9ICdTVE9SWUJPQVJEX0NPTVBPTkVOVCc7XG5leHBvcnRzLlNUT1JZQk9BUkRfVFlQRSA9ICdTVE9SWUJPQVJEX1RZUEUnO1xuZXhwb3J0cy5PUklHSU5BTF9TVE9SWUJPQVJEX1VSTCA9ICdPUklHSU5BTF9TVE9SWUJPQVJEX1VSTCc7XG5leHBvcnRzLlNBVkVEX1NUT1JZQk9BUkRfQ09NUE9ORU5UX0ZJTEVOQU1FID0gJ1NBVkVEX1NUT1JZQk9BUkRfQ09NUE9ORU5UX0ZJTEVOQU1FJztcbmV4cG9ydHMuU0VMRUNURURfRUxFTUVOVF9LRVkgPSAnU0VMRUNURURfRUxFTUVOVF9LRVknO1xuZXhwb3J0cy5NVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMgPSAnTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTJztcbmV4cG9ydHMuSE9WRVJFRF9FTEVNRU5UX0tFWSA9ICdIT1ZFUkVEX0VMRU1FTlRfS0VZJztcbmV4cG9ydHMuVEVYVF9FRElUID0gJ1RFWFRfRURJVCc7XG5leHBvcnRzLkhPVF9SRUxPQURJTkcgPSAnSE9UX1JFTE9BRElORyc7XG5leHBvcnRzLklTX0ZMVVNISU5HID0gJ0lTX0ZMVVNISU5HJztcbmV4cG9ydHMuTkFWX1RSRUVfQ0FMTEJBQ0tTID0gJ05BVl9UUkVFX0NBTExCQUNLUyc7XG4vLyBHZW5lcmF0ZWQgd2hlbiBjcmVhdGluZyB0aGUgbmF2IHRyZWUsIHVzZWQgZm9yIG91dGxpbmVzXG5leHBvcnRzLkVMRU1FTlRfS0VZX1RPX0xPT0tVUF9MSVNUID0gJ0VMRU1FTlRfS0VZX1RPX0xPT0tVUF9MSVNUJztcbmV4cG9ydHMuRUxFTUVOVF9LRVlfVE9fTkFWX05PREUgPSAnRUxFTUVOVF9LRVlfVE9fTkFWX05PREUnO1xuZXhwb3J0cy5DVVJSRU5UX05BVl9UUkVFID0gJ0NVUlJFTlRfTkFWX1RSRUUnO1xuY29uc3QgaW5NZW1vcnlTdG9yYWdlID0ge307XG5jb25zdCBnZXRNZW1vcnlTdG9yYWdlSXRlbSA9IChrZXkpID0+IHtcbiAgICByZXR1cm4gaW5NZW1vcnlTdG9yYWdlW2tleV07XG59O1xuZXhwb3J0cy5nZXRNZW1vcnlTdG9yYWdlSXRlbSA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtO1xuY29uc3Qgc2V0TWVtb3J5U3RvcmFnZUl0ZW0gPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGluTWVtb3J5U3RvcmFnZVtrZXldID0gdmFsdWU7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBkZWxldGUgaW5NZW1vcnlTdG9yYWdlW2tleV07XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0TWVtb3J5U3RvcmFnZUl0ZW0gPSBzZXRNZW1vcnlTdG9yYWdlSXRlbTtcbmNvbnN0IHJlbW92ZU1lbW9yeVN0b3JhZ2VJdGVtID0gKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBpbk1lbW9yeVN0b3JhZ2Vba2V5XTtcbn07XG5leHBvcnRzLnJlbW92ZU1lbW9yeVN0b3JhZ2VJdGVtID0gcmVtb3ZlTWVtb3J5U3RvcmFnZUl0ZW07XG5jb25zdCBnZXRTZXNzaW9uU3RvcmFnZUl0ZW0gPSAoa2V5LCBzdG9yeWJvYXJkSWQpID0+IHtcbiAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShgJHtzdG9yeWJvYXJkSWR9XyR7a2V5fWApO1xufTtcbmV4cG9ydHMuZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtID0gZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtO1xuY29uc3Qgc2V0U2Vzc2lvblN0b3JhZ2VJdGVtID0gKGtleSwgdmFsdWUsIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMucmVtb3ZlU2Vzc2lvblN0b3JhZ2VJdGVtKShrZXksIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShgJHtzdG9yeWJvYXJkSWR9XyR7a2V5fWAsIHZhbHVlKTtcbn07XG5leHBvcnRzLnNldFNlc3Npb25TdG9yYWdlSXRlbSA9IHNldFNlc3Npb25TdG9yYWdlSXRlbTtcbmNvbnN0IHJlbW92ZVNlc3Npb25TdG9yYWdlSXRlbSA9IChrZXksIHN0b3J5Ym9hcmRJZCkgPT4ge1xuICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oYCR7c3Rvcnlib2FyZElkfV8ke2tleX1gKTtcbn07XG5leHBvcnRzLnJlbW92ZVNlc3Npb25TdG9yYWdlSXRlbSA9IHJlbW92ZVNlc3Npb25TdG9yYWdlSXRlbTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/sessionStorageUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TempoElement = void 0;\n// Matches the interface in tempo web\nconst STORYBOARD_TOP_CONSTANT = 'STORYBOARD-TOP-CONSTANT';\n/**\n * Used to uniquely identify an element in the DOM or a component in the nav tree.\n *\n * Created when building the nav tree\n */\nclass TempoElement {\n    /**\n     * If codebase ID is undefined then it doesn't exist in our codebase, but is still a valid lookup\n     */\n    constructor(codebaseId, storyboardId, uniquePath) {\n        if (codebaseId && /[^0-9a-zA-Z-_]/.test(codebaseId)) {\n            throw new Error('Codebase ID contains invalid chars :' + codebaseId);\n        }\n        if (storyboardId && /[^0-9a-zA-Z-_]/.test(storyboardId)) {\n            throw new Error('Storyboard ID contains invalid chars :' + codebaseId);\n        }\n        this.codebaseId = codebaseId || '';\n        this.storyboardId = storyboardId;\n        this.uniquePath = uniquePath;\n        this.cachedKey = null;\n    }\n    isEqual(other) {\n        return (this.codebaseId === other.codebaseId &&\n            this.storyboardId === other.storyboardId &&\n            this.uniquePath === other.uniquePath);\n    }\n    getKey() {\n        if (this.cachedKey) {\n            return this.cachedKey;\n        }\n        // Also start it with TE_ since it has to start with a name\n        this.cachedKey = `TE_${this.codebaseId}_${this.storyboardId}_${this.uniquePath}`;\n        return this.cachedKey;\n    }\n    /**\n     * Note, codebase ID is allowed to be empty but not the storyboard ID or unique path\n     */\n    isEmpty() {\n        if (this.storyboardId && this.uniquePath) {\n            return false;\n        }\n        return true;\n    }\n    static fromKey(key) {\n        if (!key) {\n            return TempoElement.empty();\n        }\n        // Account for the TE_ prefix\n        const [_, codebaseId, storyboardId, uniquePath] = key.split('_');\n        if (!storyboardId || !uniquePath) {\n            return TempoElement.empty();\n        }\n        return new TempoElement(codebaseId, storyboardId, uniquePath);\n    }\n    static fromOtherElement(other) {\n        return new TempoElement(other.codebaseId, other.storyboardId, other.uniquePath);\n    }\n    static empty() {\n        return new TempoElement('', '', '');\n    }\n    /**\n     * Returns a tempo element that can be used to represent the storyboard itself\n     */\n    static forStoryboard(storyboardId) {\n        return new TempoElement(STORYBOARD_TOP_CONSTANT, storyboardId, '0');\n    }\n    /**\n     * If the storyboardId is passed in it checks if it is equal to this particular storyboard\n     */\n    isStoryboard(storyboardId) {\n        return (this.codebaseId === STORYBOARD_TOP_CONSTANT &&\n            (!storyboardId || this.storyboardId === storyboardId));\n    }\n    /**\n     * @returns if this element is inside a storyboard and known in the codebase\n     */\n    isKnownElement() {\n        return (!this.isEmpty() &&\n            Boolean(this.codebaseId) &&\n            this.codebaseId !== STORYBOARD_TOP_CONSTANT);\n    }\n    isParentOf(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.isStoryboard()) {\n            return (this.storyboardId === other.storyboardId &&\n                this.uniquePath !== other.uniquePath);\n        }\n        return (this.storyboardId === other.storyboardId &&\n            this.uniquePath !== other.uniquePath &&\n            Boolean(this.uniquePath) &&\n            Boolean(other.uniquePath) &&\n            other.uniquePath.startsWith(this.uniquePath));\n    }\n    isSiblingOf(other) {\n        if (!other || !this.uniquePath || !other.uniquePath) {\n            return false;\n        }\n        if (this.isEqual(other)) {\n            return false;\n        }\n        if (this.isStoryboard()) {\n            return other.isStoryboard();\n        }\n        const pathUntilLastSegment = this.uniquePath\n            .split('-')\n            .slice(0, -1)\n            .join('-');\n        const otherPathUntilLastSegment = other.uniquePath\n            .split('-')\n            .slice(0, -1)\n            .join('-');\n        return (this.storyboardId === other.storyboardId &&\n            this.uniquePath !== other.uniquePath &&\n            Boolean(pathUntilLastSegment) &&\n            Boolean(otherPathUntilLastSegment) &&\n            pathUntilLastSegment === otherPathUntilLastSegment);\n    }\n}\nexports.TempoElement = TempoElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9jaGFubmVsTWVzc2FnaW5nL3RlbXBvRWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzeWFoaVxcT25lRHJpdmVcXNiz2LfYrSDYp9mE2YXZg9iq2KhcXEdhc3NpbVxcaGVhZHNob3RtYWtlcmFpcHJvXFxub2RlX21vZHVsZXNcXHRlbXBvLWRldnRvb2xzXFxkaXN0XFxjaGFubmVsTWVzc2FnaW5nXFx0ZW1wb0VsZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRlbXBvRWxlbWVudCA9IHZvaWQgMDtcbi8vIE1hdGNoZXMgdGhlIGludGVyZmFjZSBpbiB0ZW1wbyB3ZWJcbmNvbnN0IFNUT1JZQk9BUkRfVE9QX0NPTlNUQU5UID0gJ1NUT1JZQk9BUkQtVE9QLUNPTlNUQU5UJztcbi8qKlxuICogVXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBhbiBlbGVtZW50IGluIHRoZSBET00gb3IgYSBjb21wb25lbnQgaW4gdGhlIG5hdiB0cmVlLlxuICpcbiAqIENyZWF0ZWQgd2hlbiBidWlsZGluZyB0aGUgbmF2IHRyZWVcbiAqL1xuY2xhc3MgVGVtcG9FbGVtZW50IHtcbiAgICAvKipcbiAgICAgKiBJZiBjb2RlYmFzZSBJRCBpcyB1bmRlZmluZWQgdGhlbiBpdCBkb2Vzbid0IGV4aXN0IGluIG91ciBjb2RlYmFzZSwgYnV0IGlzIHN0aWxsIGEgdmFsaWQgbG9va3VwXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29kZWJhc2VJZCwgc3Rvcnlib2FyZElkLCB1bmlxdWVQYXRoKSB7XG4gICAgICAgIGlmIChjb2RlYmFzZUlkICYmIC9bXjAtOWEtekEtWi1fXS8udGVzdChjb2RlYmFzZUlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlYmFzZSBJRCBjb250YWlucyBpbnZhbGlkIGNoYXJzIDonICsgY29kZWJhc2VJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3J5Ym9hcmRJZCAmJiAvW14wLTlhLXpBLVotX10vLnRlc3Qoc3Rvcnlib2FyZElkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdG9yeWJvYXJkIElEIGNvbnRhaW5zIGludmFsaWQgY2hhcnMgOicgKyBjb2RlYmFzZUlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvZGViYXNlSWQgPSBjb2RlYmFzZUlkIHx8ICcnO1xuICAgICAgICB0aGlzLnN0b3J5Ym9hcmRJZCA9IHN0b3J5Ym9hcmRJZDtcbiAgICAgICAgdGhpcy51bmlxdWVQYXRoID0gdW5pcXVlUGF0aDtcbiAgICAgICAgdGhpcy5jYWNoZWRLZXkgPSBudWxsO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jb2RlYmFzZUlkID09PSBvdGhlci5jb2RlYmFzZUlkICYmXG4gICAgICAgICAgICB0aGlzLnN0b3J5Ym9hcmRJZCA9PT0gb3RoZXIuc3Rvcnlib2FyZElkICYmXG4gICAgICAgICAgICB0aGlzLnVuaXF1ZVBhdGggPT09IG90aGVyLnVuaXF1ZVBhdGgpO1xuICAgIH1cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkS2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsc28gc3RhcnQgaXQgd2l0aCBURV8gc2luY2UgaXQgaGFzIHRvIHN0YXJ0IHdpdGggYSBuYW1lXG4gICAgICAgIHRoaXMuY2FjaGVkS2V5ID0gYFRFXyR7dGhpcy5jb2RlYmFzZUlkfV8ke3RoaXMuc3Rvcnlib2FyZElkfV8ke3RoaXMudW5pcXVlUGF0aH1gO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGUsIGNvZGViYXNlIElEIGlzIGFsbG93ZWQgdG8gYmUgZW1wdHkgYnV0IG5vdCB0aGUgc3Rvcnlib2FyZCBJRCBvciB1bmlxdWUgcGF0aFxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3J5Ym9hcmRJZCAmJiB0aGlzLnVuaXF1ZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21LZXkoa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gVGVtcG9FbGVtZW50LmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWNjb3VudCBmb3IgdGhlIFRFXyBwcmVmaXhcbiAgICAgICAgY29uc3QgW18sIGNvZGViYXNlSWQsIHN0b3J5Ym9hcmRJZCwgdW5pcXVlUGF0aF0gPSBrZXkuc3BsaXQoJ18nKTtcbiAgICAgICAgaWYgKCFzdG9yeWJvYXJkSWQgfHwgIXVuaXF1ZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBUZW1wb0VsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBvRWxlbWVudChjb2RlYmFzZUlkLCBzdG9yeWJvYXJkSWQsIHVuaXF1ZVBhdGgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU90aGVyRWxlbWVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBvRWxlbWVudChvdGhlci5jb2RlYmFzZUlkLCBvdGhlci5zdG9yeWJvYXJkSWQsIG90aGVyLnVuaXF1ZVBhdGgpO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcG9FbGVtZW50KCcnLCAnJywgJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdGVtcG8gZWxlbWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgc3Rvcnlib2FyZCBpdHNlbGZcbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yU3Rvcnlib2FyZChzdG9yeWJvYXJkSWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wb0VsZW1lbnQoU1RPUllCT0FSRF9UT1BfQ09OU1RBTlQsIHN0b3J5Ym9hcmRJZCwgJzAnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHN0b3J5Ym9hcmRJZCBpcyBwYXNzZWQgaW4gaXQgY2hlY2tzIGlmIGl0IGlzIGVxdWFsIHRvIHRoaXMgcGFydGljdWxhciBzdG9yeWJvYXJkXG4gICAgICovXG4gICAgaXNTdG9yeWJvYXJkKHN0b3J5Ym9hcmRJZCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29kZWJhc2VJZCA9PT0gU1RPUllCT0FSRF9UT1BfQ09OU1RBTlQgJiZcbiAgICAgICAgICAgICghc3Rvcnlib2FyZElkIHx8IHRoaXMuc3Rvcnlib2FyZElkID09PSBzdG9yeWJvYXJkSWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgaWYgdGhpcyBlbGVtZW50IGlzIGluc2lkZSBhIHN0b3J5Ym9hcmQgYW5kIGtub3duIGluIHRoZSBjb2RlYmFzZVxuICAgICAqL1xuICAgIGlzS25vd25FbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmlzRW1wdHkoKSAmJlxuICAgICAgICAgICAgQm9vbGVhbih0aGlzLmNvZGViYXNlSWQpICYmXG4gICAgICAgICAgICB0aGlzLmNvZGViYXNlSWQgIT09IFNUT1JZQk9BUkRfVE9QX0NPTlNUQU5UKTtcbiAgICB9XG4gICAgaXNQYXJlbnRPZihvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTdG9yeWJvYXJkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zdG9yeWJvYXJkSWQgPT09IG90aGVyLnN0b3J5Ym9hcmRJZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMudW5pcXVlUGF0aCAhPT0gb3RoZXIudW5pcXVlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnN0b3J5Ym9hcmRJZCA9PT0gb3RoZXIuc3Rvcnlib2FyZElkICYmXG4gICAgICAgICAgICB0aGlzLnVuaXF1ZVBhdGggIT09IG90aGVyLnVuaXF1ZVBhdGggJiZcbiAgICAgICAgICAgIEJvb2xlYW4odGhpcy51bmlxdWVQYXRoKSAmJlxuICAgICAgICAgICAgQm9vbGVhbihvdGhlci51bmlxdWVQYXRoKSAmJlxuICAgICAgICAgICAgb3RoZXIudW5pcXVlUGF0aC5zdGFydHNXaXRoKHRoaXMudW5pcXVlUGF0aCkpO1xuICAgIH1cbiAgICBpc1NpYmxpbmdPZihvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyIHx8ICF0aGlzLnVuaXF1ZVBhdGggfHwgIW90aGVyLnVuaXF1ZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0VxdWFsKG90aGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3Rvcnlib2FyZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuaXNTdG9yeWJvYXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aFVudGlsTGFzdFNlZ21lbnQgPSB0aGlzLnVuaXF1ZVBhdGhcbiAgICAgICAgICAgIC5zcGxpdCgnLScpXG4gICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAuam9pbignLScpO1xuICAgICAgICBjb25zdCBvdGhlclBhdGhVbnRpbExhc3RTZWdtZW50ID0gb3RoZXIudW5pcXVlUGF0aFxuICAgICAgICAgICAgLnNwbGl0KCctJylcbiAgICAgICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIC5qb2luKCctJyk7XG4gICAgICAgIHJldHVybiAodGhpcy5zdG9yeWJvYXJkSWQgPT09IG90aGVyLnN0b3J5Ym9hcmRJZCAmJlxuICAgICAgICAgICAgdGhpcy51bmlxdWVQYXRoICE9PSBvdGhlci51bmlxdWVQYXRoICYmXG4gICAgICAgICAgICBCb29sZWFuKHBhdGhVbnRpbExhc3RTZWdtZW50KSAmJlxuICAgICAgICAgICAgQm9vbGVhbihvdGhlclBhdGhVbnRpbExhc3RTZWdtZW50KSAmJlxuICAgICAgICAgICAgcGF0aFVudGlsTGFzdFNlZ21lbnQgPT09IG90aGVyUGF0aFVudGlsTGFzdFNlZ21lbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuVGVtcG9FbGVtZW50ID0gVGVtcG9FbGVtZW50O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/channelMessaging/tempoElement.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/// <reference path=\"./tempo-routes.d.ts\" />\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TempoDevtools = void 0;\nvar TempoDevtools_js_1 = __webpack_require__(/*! ./TempoDevtools.js */ \"(ssr)/./node_modules/tempo-devtools/dist/TempoDevtools.js\");\nObject.defineProperty(exports, \"TempoDevtools\", ({ enumerable: true, get: function () { return TempoDevtools_js_1.TempoDevtools; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQix5QkFBeUIsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDckQsaURBQWdELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHN5YWhpXFxPbmVEcml2ZVxc2LPYt9itINin2YTZhdmD2KrYqFxcR2Fzc2ltXFxoZWFkc2hvdG1ha2VyYWlwcm9cXG5vZGVfbW9kdWxlc1xcdGVtcG8tZGV2dG9vbHNcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vdGVtcG8tcm91dGVzLmQudHNcIiAvPlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZW1wb0RldnRvb2xzID0gdm9pZCAwO1xudmFyIFRlbXBvRGV2dG9vbHNfanNfMSA9IHJlcXVpcmUoXCIuL1RlbXBvRGV2dG9vbHMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZW1wb0RldnRvb2xzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBUZW1wb0RldnRvb2xzX2pzXzEuVGVtcG9EZXZ0b29sczsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/tempo-devtools/dist/posthog.js":
/*!*****************************************************!*\
  !*** ./node_modules/tempo-devtools/dist/posthog.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostHog = {\n    init: () => {\n        !(function (t, e) {\n            var o, n, p, r;\n            e.__SV ||\n                ((window.posthog = e),\n                    (e._i = []),\n                    (e.init = function (i, s, a) {\n                        function g(t, e) {\n                            var o = e.split('.');\n                            2 == o.length && ((t = t[o[0]]), (e = o[1])),\n                                (t[e] = function () {\n                                    t.push([e].concat(Array.prototype.slice.call(arguments, 0)));\n                                });\n                        }\n                        ((p = t.createElement('script')).type = 'text/javascript'),\n                            (p.async = !0),\n                            (p.src = s.api_host + '/static/array.js'),\n                            (r = t.getElementsByTagName('script')[0]).parentNode.insertBefore(p, r);\n                        var u = e;\n                        for (void 0 !== a ? (u = e[a] = []) : (a = 'posthog'),\n                            u.people = u.people || [],\n                            u.toString = function (t) {\n                                var e = 'posthog';\n                                return ('posthog' !== a && (e += '.' + a), t || (e += ' (stub)'), e);\n                            },\n                            u.people.toString = function () {\n                                return u.toString(1) + '.people (stub)';\n                            },\n                            o =\n                                'capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys getNextSurveyStep onSessionId'.split(' '),\n                            n = 0; n < o.length; n++)\n                            g(u, o[n]);\n                        e._i.push([i, s, a]);\n                    }),\n                    (e.__SV = 1));\n        })(document, window.posthog || []);\n        posthog.init('phc_jjpEvBVV0R2mp44ePAL8Yt4jdtX5HW1lc493rkpUwwa', {\n            api_host: 'https://us.i.posthog.com',\n            person_profiles: 'identified_only',\n            session_recording: {\n                recordCrossOriginIframes: true,\n                maskAllInputs: false,\n                maskInputOptions: {\n                    password: true,\n                },\n            },\n        });\n    },\n};\nexports[\"default\"] = PostHog;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG8tZGV2dG9vbHMvZGlzdC9wb3N0aG9nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3lhaGlcXE9uZURyaXZlXFzYs9i32K0g2KfZhNmF2YPYqtioXFxHYXNzaW1cXGhlYWRzaG90bWFrZXJhaXByb1xcbm9kZV9tb2R1bGVzXFx0ZW1wby1kZXZ0b29sc1xcZGlzdFxccG9zdGhvZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvc3RIb2cgPSB7XG4gICAgaW5pdDogKCkgPT4ge1xuICAgICAgICAhKGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICB2YXIgbywgbiwgcCwgcjtcbiAgICAgICAgICAgIGUuX19TViB8fFxuICAgICAgICAgICAgICAgICgod2luZG93LnBvc3Rob2cgPSBlKSxcbiAgICAgICAgICAgICAgICAgICAgKGUuX2kgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgIChlLmluaXQgPSBmdW5jdGlvbiAoaSwgcywgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZyh0LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBlLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiA9PSBvLmxlbmd0aCAmJiAoKHQgPSB0W29bMF1dKSwgKGUgPSBvWzFdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0W2VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5wdXNoKFtlXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICgocCA9IHQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHAuYXN5bmMgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHAuc3JjID0gcy5hcGlfaG9zdCArICcvc3RhdGljL2FycmF5LmpzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHIgPSB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSkucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocCwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZvaWQgMCAhPT0gYSA/ICh1ID0gZVthXSA9IFtdKSA6IChhID0gJ3Bvc3Rob2cnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1LnBlb3BsZSA9IHUucGVvcGxlIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUudG9TdHJpbmcgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9ICdwb3N0aG9nJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgncG9zdGhvZycgIT09IGEgJiYgKGUgKz0gJy4nICsgYSksIHQgfHwgKGUgKz0gJyAoc3R1YiknKSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1LnBlb3BsZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHUudG9TdHJpbmcoMSkgKyAnLnBlb3BsZSAoc3R1YiknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjYXB0dXJlIGlkZW50aWZ5IGFsaWFzIHBlb3BsZS5zZXQgcGVvcGxlLnNldF9vbmNlIHNldF9jb25maWcgcmVnaXN0ZXIgcmVnaXN0ZXJfb25jZSB1bnJlZ2lzdGVyIG9wdF9vdXRfY2FwdHVyaW5nIGhhc19vcHRlZF9vdXRfY2FwdHVyaW5nIG9wdF9pbl9jYXB0dXJpbmcgcmVzZXQgaXNGZWF0dXJlRW5hYmxlZCBvbkZlYXR1cmVGbGFncyBnZXRGZWF0dXJlRmxhZyBnZXRGZWF0dXJlRmxhZ1BheWxvYWQgcmVsb2FkRmVhdHVyZUZsYWdzIGdyb3VwIHVwZGF0ZUVhcmx5QWNjZXNzRmVhdHVyZUVucm9sbG1lbnQgZ2V0RWFybHlBY2Nlc3NGZWF0dXJlcyBnZXRBY3RpdmVNYXRjaGluZ1N1cnZleXMgZ2V0U3VydmV5cyBnZXROZXh0U3VydmV5U3RlcCBvblNlc3Npb25JZCcuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMDsgbiA8IG8ubGVuZ3RoOyBuKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyh1LCBvW25dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuX2kucHVzaChbaSwgcywgYV0pO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgKGUuX19TViA9IDEpKTtcbiAgICAgICAgfSkoZG9jdW1lbnQsIHdpbmRvdy5wb3N0aG9nIHx8IFtdKTtcbiAgICAgICAgcG9zdGhvZy5pbml0KCdwaGNfampwRXZCVlYwUjJtcDQ0ZVBBTDhZdDRqZHRYNUhXMWxjNDkzcmtwVXd3YScsIHtcbiAgICAgICAgICAgIGFwaV9ob3N0OiAnaHR0cHM6Ly91cy5pLnBvc3Rob2cuY29tJyxcbiAgICAgICAgICAgIHBlcnNvbl9wcm9maWxlczogJ2lkZW50aWZpZWRfb25seScsXG4gICAgICAgICAgICBzZXNzaW9uX3JlY29yZGluZzoge1xuICAgICAgICAgICAgICAgIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtYXNrQWxsSW5wdXRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBvc3RIb2c7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tempo-devtools/dist/posthog.js\n");

/***/ })

};
;